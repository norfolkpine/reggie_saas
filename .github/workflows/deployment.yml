name: Deploy to GCP VM

on:
  push:
    branches: [main, dev]

env:
  PROJECT_ID: bh-opie
  REGION: australia-southeast1
  IMAGE_NAME_WEB: opie-web
  IMAGE_NAME_Y_PROVIDER: opie-y-provider
  ARTIFACT_REGISTRY_URL: australia-southeast1-docker.pkg.dev/bh-opie/containers

jobs:
  deploy:
    runs-on: ubuntu-latest  # GitHub Actions runner (Ubuntu)
    environment: bh-opie    # Deploying TO Debian VM
    permissions:
      contents: read
      id-token: write  # Required for Workload Identity Federation

    steps:
    - name: Debug Environment and Secrets
      run: |
        echo "=== Environment Debug ==="
        echo "GitHub Environment: ${{ github.environment }}"
        echo "Repository: ${{ github.repository }}"
        echo "Ref: ${{ github.ref }}"
        echo ""
        echo "=== VM Secrets Debug ==="
        echo "VM_HOST: '${{ secrets.VM_HOST }}'"
        echo "VM_USER: '${{ secrets.VM_USER }}'"
        echo "VM_SSH_KEY length: ${#VM_SSH_KEY}"
        echo ""
        echo "=== Environment Secrets Debug ==="
        echo "Environment: ${{ github.environment }}"
        echo "VM_HOST from env: '${{ env.VM_HOST }}'"
        echo "VM_USER from env: '${{ env.VM_USER }}'"
        echo ""
        echo "=== All Environment Variables ==="
        env | grep -E "^(VM_|GCP_|SECRET_|DATABASE_)" | sort || echo "No matching secrets found"
        echo ""
        echo "=== Test Secret Access ==="
        if [ -n "${{ secrets.VM_HOST }}" ]; then
          echo "✅ VM_HOST is accessible: '${{ secrets.VM_HOST }}'"
        else
          echo "❌ VM_HOST is empty or not accessible"
        fi

    - name: Checkout
      uses: actions/checkout@v3
      with:
        fetch-depth: 0

    - name: GCP Authentication
      uses: google-github-actions/auth@v2
      with:
        workload_identity_provider: 'projects/204023632747/locations/global/workloadIdentityPools/github-actions-pool/providers/github'
        service_account: 'terraform-deployer@bh-opie.iam.gserviceaccount.com'

    - name: Check VM Status and Startup Script Logs
      run: |
        echo "=== Checking VM Status ==="
        echo "VM_HOST: ${{ secrets.VM_HOST }}"
        echo "PROJECT_ID: ${{ env.PROJECT_ID }}"
        
        # Check current authentication
        echo "Current authenticated account:"
        gcloud auth list --filter=status:ACTIVE --format="value(account)"
        
        # Check if VM exists and get detailed status
        echo "Checking VM status..."
        VM_STATUS=$(gcloud compute instances describe opie-stack-vm --zone=australia-southeast1-a --project=${{ env.PROJECT_ID }} --format="value(status)" 2>/dev/null || echo "VM_NOT_FOUND")
        echo "VM Status: $VM_STATUS"
        
        if [ "$VM_STATUS" = "VM_NOT_FOUND" ]; then
          echo "❌ VM not found! Checking if it exists with different name..."
          gcloud compute instances list --project=${{ env.PROJECT_ID }} --filter="name~opie" --format="table(name,status,zone)"
        elif [ "$VM_STATUS" = "RUNNING" ]; then
          echo "✅ VM is running"
        else
          echo "⚠️ VM status: $VM_STATUS"
        fi
        
        # Get VM external IP
        echo "Getting VM external IP..."
        VM_IP=$(gcloud compute instances describe opie-stack-vm --zone=australia-southeast1-a --project=${{ env.PROJECT_ID }} --format="value(networkInterfaces[0].accessConfigs[0].natIP)" 2>/dev/null || echo "NO_IP")
        echo "VM External IP: $VM_IP"
        echo "Expected VM_HOST: ${{ secrets.VM_HOST }}"
        
        if [ "$VM_IP" != "${{ secrets.VM_HOST }}" ] && [ "$VM_IP" != "NO_IP" ]; then
          echo "⚠️ IP mismatch! VM IP: $VM_IP, Expected: ${{ secrets.VM_HOST }}"
        fi
        
        # Check VM startup script logs
        echo "Checking VM startup script logs..."
        echo "=== STARTUP SCRIPT LOGS ==="
        gcloud compute instances get-serial-port-output opie-stack-vm --zone=australia-southeast1-a --project=${{ env.PROJECT_ID }} --start=0 2>/dev/null | tail -100 || echo "Failed to get startup script logs"
        echo "=== END STARTUP SCRIPT LOGS ==="
        
        # Check if VM is reachable
        echo "Testing VM connectivity..."
        if ping -c 3 -W 5 ${{ secrets.VM_HOST }} >/dev/null 2>&1; then
          echo "✅ VM is reachable via ping"
        else
          echo "❌ VM is not reachable via ping"
          echo "Trying to ping the actual VM IP..."
          if [ "$VM_IP" != "NO_IP" ] && [ "$VM_IP" != "${{ secrets.VM_HOST }}" ]; then
            if ping -c 3 -W 5 $VM_IP >/dev/null 2>&1; then
              echo "✅ VM is reachable via actual IP: $VM_IP"
            else
              echo "❌ VM is not reachable via actual IP: $VM_IP"
            fi
          fi
        fi

    - name: Configure Docker for Artifact Registry
      run: gcloud auth configure-docker australia-southeast1-docker.pkg.dev --quiet

    - name: Setup Docker Buildx
      run: |
        docker buildx create --use --name multiarch
        docker buildx inspect --bootstrap

    - name: Build and Push Docker image (web)
      run: |
        echo "=== Building Docker image (web) ==="
        IMAGE_WEB=australia-southeast1-docker.pkg.dev/${{ env.PROJECT_ID }}/containers/${{ env.IMAGE_NAME_WEB }}:latest
        echo "Image: $IMAGE_WEB"
        # Note: Using Workload Identity Federation, no service account key needed
        docker buildx build --no-cache \
          -f Dockerfile.web \
          --build-arg SECRET_KEY="${{ secrets.SECRET_KEY }}" \
          --build-arg DEBUG=0 \
          --build-arg DATABASE_URL="${{ secrets.DATABASE_URL }}" \
          --build-arg DJANGO_API_KEY="${{ secrets.DJANGO_API_KEY }}" \
          --build-arg FORCE_GCP_DETECTION="${{ vars.FORCE_GCP_DETECTION }}" \
          -t $IMAGE_WEB \
          --push \
          .
        echo "✅ Web image built and pushed successfully"

    # - name: Build and Push Docker image (y-provider)
    #   run: |
    #     echo "=== Building Docker image (y-provider) ==="
    #     cd opie-y-provider
    #     IMAGE_Y_PROVIDER=australia-southeast1-docker.pkg.dev/${{ env.PROJECT_ID }}/containers/${{ env.IMAGE_NAME_Y_PROVIDER }}:latest
    #     echo "Image: $IMAGE_Y_PROVIDER"
    #     docker buildx build --no-cache -f Dockerfile -t $IMAGE_Y_PROVIDER --push .
    #     cd ..
    #     echo "✅ Y-provider image built and pushed successfully"

    - name: Set up SSH
      run: |
        echo "=== SSH Setup Debug ==="
        echo "VM_HOST: ${{ secrets.VM_HOST }}"
        echo "VM_USER: ${{ secrets.VM_USER }}"
        echo "SSH_KEY length: ${#VM_SSH_KEY}"
        echo "SSH_KEY first 50 chars: ${VM_SSH_KEY:0:50}..."
        
        mkdir -p ~/.ssh
        echo "${{ secrets.VM_SSH_KEY }}" > ~/.ssh/id_rsa
        chmod 600 ~/.ssh/id_rsa
        
        echo "=== SSH Key Setup Complete ==="
        echo "SSH key file size: $(wc -c < ~/.ssh/id_rsa)"
        echo "SSH key permissions: $(ls -la ~/.ssh/id_rsa)"
        
        # Add VM to known_hosts
        echo "=== Adding VM to known_hosts ==="
        ssh-keyscan -H ${{ secrets.VM_HOST }} >> ~/.ssh/known_hosts
        echo "Known hosts updated"
        
        # Test SSH connection as debian user first (default user)
        echo "=== Testing SSH as debian user ==="
        if timeout 10 ssh -o "StrictHostKeyChecking=no" -o "ConnectTimeout=5" "debian@${{ secrets.VM_HOST }}" "echo 'SSH as debian user successful'"; then
          echo "✅ SSH as debian user successful"
          echo "Checking VM details and startup script status..."
          ssh -o "StrictHostKeyChecking=no" "debian@${{ secrets.VM_HOST }}" "
            echo '=== VM Service Account Info ==='
            curl -H 'Metadata-Flavor: Google' http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/email 2>/dev/null || echo 'Could not get service account'
            echo ''
            echo '=== Checking users on VM ==='
            cat /etc/passwd | grep github-actions || echo 'github-actions user not found'
            echo ''
            echo '=== Checking startup script status ==='
            systemctl status google-startup-scripts || echo 'Startup script service not found'
            echo ''
            echo '=== Checking recent startup script logs ==='
            journalctl -u google-startup-scripts --no-pager -n 30 || echo 'No startup script logs found'
            echo ''
            echo '=== Checking if Docker is running ==='
            systemctl status docker || echo 'Docker service not found'
            echo ''
            echo '=== Checking if github-actions user can access Docker ==='
            sudo -u github-actions docker ps 2>&1 || echo 'github-actions user cannot access Docker'
            echo ''
            echo '=== Checking file permissions ==='
            ls -la /home/github-actions/ 2>/dev/null || echo 'github-actions home directory not found'
            echo ''
            echo '=== Checking if startup script completed ==='
            if [ -f /var/log/startup-script.log ]; then
              echo 'Startup script log found:'
              tail -20 /var/log/startup-script.log
            else
              echo 'No startup script log found'
            fi
          "
        else
          echo "❌ SSH as debian user failed"
        fi
        
        # Wait for VM to be ready (startup script completion)
        echo "=== VM Connection Testing ==="
        echo "Waiting for VM to complete startup..."
        echo "Testing connectivity to: ${{ secrets.VM_HOST }}"
        
        for i in {1..20}; do
          echo "Attempt $i/20: Testing SSH connection..."
          
          # Test basic connectivity first
          echo "Testing ping connectivity..."
          if ping -c 1 -W 5 ${{ secrets.VM_HOST }} >/dev/null 2>&1; then
            echo "✅ VM is reachable via ping"
          else
            echo "❌ VM is not reachable via ping"
          fi
          
          # Test SSH with different users and check for github-actions user existence
          echo "Testing SSH as github-actions user..."
          if timeout 15 ssh -v -o "StrictHostKeyChecking=no" -o "ConnectTimeout=10" "github-actions@${{ secrets.VM_HOST }}" "id github-actions && echo 'VM is ready'" 2>&1 | grep -q "VM is ready"; then
            echo "✅ VM is ready for deployment via github-actions user!"
            break
          else
            echo "❌ SSH as github-actions failed or user not ready"
          fi
          
          # Try with VM_USER as fallback
          echo "Testing SSH as ${{ secrets.VM_USER }} user..."
          if timeout 15 ssh -v -o "StrictHostKeyChecking=no" -o "ConnectTimeout=10" "${{ secrets.VM_USER }}@${{ secrets.VM_HOST }}" "id github-actions && echo 'VM is ready'" 2>&1 | grep -q "VM is ready"; then
            echo "✅ VM is ready for deployment via ${{ secrets.VM_USER }} user!"
            break
          else
            echo "❌ SSH as ${{ secrets.VM_USER }} failed or github-actions user not ready"
          fi
          
          echo "⏳ VM not ready yet, waiting 30 seconds..."
          sleep 30
        done
        
        # Add VM to known_hosts
        echo "=== Adding VM to known_hosts ==="
        ssh-keyscan -H ${{ secrets.VM_HOST }} >> ~/.ssh/known_hosts
        echo "Known hosts updated"

    - name: Setup VM for deployment
      run: |
        # Note: VM setup is handled by Terraform startup script
        # The github-actions user and directories are created automatically
        # No service account keys needed with Workload Identity Federation


    - name: Verify VM and user setup
      run: |
        echo "=== Verifying VM and user setup ==="
        echo "VM_HOST: ${{ secrets.VM_HOST }}"
        
        # Test SSH connection and verify github-actions user exists
        echo "Testing SSH connection and user verification..."
        if ssh -o "StrictHostKeyChecking=no" "github-actions@${{ secrets.VM_HOST }}" "
          echo 'SSH connection successful'
          echo 'Checking github-actions user...'
          if id github-actions >/dev/null 2>&1; then
            echo '✅ github-actions user exists'
            echo 'User details:'
            id github-actions
            echo 'Home directory:'
            ls -la /home/github-actions/
            echo 'Docker group membership:'
            groups github-actions
          else
            echo '❌ github-actions user does not exist'
            exit 1
          fi
        "; then
          echo "✅ VM and user setup verified"
        else
          echo "❌ VM or user setup verification failed"
          echo "Attempting to create github-actions user manually..."
          
          # Try to create the user manually as debian user
          if ssh -o "StrictHostKeyChecking=no" "debian@${{ secrets.VM_HOST }}" "
            echo 'Creating github-actions user manually...'
            sudo useradd -m -s /bin/bash github-actions || echo 'User already exists'
            sudo mkdir -p /home/github-actions/.gcp/creds
            sudo chown -R github-actions:github-actions /home/github-actions
            sudo chmod 755 /home/github-actions
            sudo chmod 700 /home/github-actions/.gcp
            sudo chmod 755 /home/github-actions/.gcp/creds
            sudo usermod -aG docker github-actions
            sudo usermod -aG sudo github-actions
            echo 'User created successfully'
            id github-actions
          "; then
            echo "✅ github-actions user created manually"
          else
            echo "❌ Failed to create github-actions user manually"
            exit 1
          fi
        fi

    - name: Create deployment environment file on VM
      run: |
        echo "=== Creating deployment.env on VM ==="
        echo "VM_HOST: ${{ secrets.VM_HOST }}"
        echo "PROJECT_ID: ${{ env.PROJECT_ID }}"
        echo "IMAGE_NAME_WEB: ${{ env.IMAGE_NAME_WEB }}"
        echo "IMAGE_NAME_Y_PROVIDER: ${{ env.IMAGE_NAME_Y_PROVIDER }}"
        echo "ARTIFACT_REGISTRY_URL: ${{ env.ARTIFACT_REGISTRY_URL }}"
        
        # Create deployment.env directly using github-actions user
        echo "Creating deployment.env file..."
        ssh -o "StrictHostKeyChecking=no" "github-actions@${{ secrets.VM_HOST }}" "
          echo 'Creating deployment.env file...'
          echo 'PROJECT_ID=${{ env.PROJECT_ID }}' > /home/github-actions/deployment.env
          echo 'IMAGE_NAME_WEB=${{ env.IMAGE_NAME_WEB }}' >> /home/github-actions/deployment.env
          echo 'IMAGE_NAME_Y_PROVIDER=${{ env.IMAGE_NAME_Y_PROVIDER }}' >> /home/github-actions/deployment.env
          echo 'ARTIFACT_REGISTRY_URL=${{ env.ARTIFACT_REGISTRY_URL }}' >> /home/github-actions/deployment.env
          echo 'DB_PASS=${{ secrets.DB_PASS }}' >> /home/github-actions/deployment.env
          echo 'DB_USER=${{ secrets.DB_USER }}' >> /home/github-actions/deployment.env
          echo 'DB_NAME=bh_opie' >> /home/github-actions/deployment.env
          chmod 644 /home/github-actions/deployment.env
          echo 'File created successfully'
          echo 'File contents:'
          cat /home/github-actions/deployment.env
        "

    - name: Upload docker-compose.prod.yml to VM
      run: |
        echo "=== Uploading docker-compose.prod.yml ==="
        echo "VM_HOST: ${{ secrets.VM_HOST }}"
        echo "Local file exists: $(ls -la docker-compose.prod.yml 2>/dev/null || echo 'File not found')"
        
        # Upload the file directly to github-actions user
        echo "Uploading file..."
        if scp -o "StrictHostKeyChecking=no" docker-compose.prod.yml "github-actions@${{ secrets.VM_HOST }}:/home/github-actions/docker-compose.prod.yml"; then
          echo "✅ docker-compose.prod.yml uploaded successfully"
        else
          echo "❌ Failed to upload docker-compose.prod.yml"
          exit 1
        fi
        
        # Verify file was uploaded
        echo "Verifying file upload..."
        ssh -o "StrictHostKeyChecking=no" "github-actions@${{ secrets.VM_HOST }}" "ls -la /home/github-actions/docker-compose.prod.yml"

    # - name: Upload Cloud SQL proxy scripts to VM
    #   run: |
    #     echo "=== Uploading Cloud SQL proxy scripts ==="
    #     echo "VM_HOST: ${{ secrets.VM_HOST }}"
    #     echo "Scripts directory contents:"
    #     ls -la scripts/ || echo "Scripts directory not found"
        
    #     # Upload our Cloud SQL proxy scripts directly to github-actions user
    #     echo "Uploading start-cloudsql-proxy-production.sh..."
    #     if scp -o "StrictHostKeyChecking=no" scripts/start-cloudsql-proxy-production.sh "github-actions@${{ secrets.VM_HOST }}:/home/github-actions/start-cloudsql-proxy-production.sh"; then
    #       echo "✅ start-cloudsql-proxy-production.sh uploaded successfully"
    #     else
    #       echo "❌ Failed to upload start-cloudsql-proxy-production.sh"
    #       exit 1
    #     fi
        
    #     echo "Uploading install-cloudsql-proxy-service.sh..."
    #     if scp -o "StrictHostKeyChecking=no" scripts/install-cloudsql-proxy-service.sh "github-actions@${{ secrets.VM_HOST }}:/home/github-actions/install-cloudsql-proxy-service.sh"; then
    #       echo "✅ install-cloudsql-proxy-service.sh uploaded successfully"
    #     else
    #       echo "❌ Failed to upload install-cloudsql-proxy-service.sh"
    #       exit 1
    #     fi
        
    #     # Make scripts executable
    #     echo "Making scripts executable..."
    #     ssh -o "StrictHostKeyChecking=no" "github-actions@${{ secrets.VM_HOST }}" "
    #       chmod +x /home/github-actions/start-cloudsql-proxy-production.sh /home/github-actions/install-cloudsql-proxy-service.sh
    #       echo 'Scripts made executable'
    #       ls -la /home/github-actions/*.sh
    #     "

    - name: SSH and deploy full stack
      run: |
        ssh -o "StrictHostKeyChecking=no" "github-actions@${{ secrets.VM_HOST }}" '
          # Ensure directory exists
          mkdir -p /home/github-actions
          
          # Setup GCP authentication on VM
          echo "Setting up GCP authentication on VM..."
          
          # Set project (gcloud CLI is already installed on GCP VM)
          gcloud config set project ${{ env.PROJECT_ID }}
          
          # Use VM's default service account (bh-opie-vm-sa)
          echo "Using VM's default service account for authentication..."
          echo "VM service account should be: bh-opie-vm-sa@bh-opie.iam.gserviceaccount.com"
          
          # Check current authentication
          echo "Current authentication status:"
          gcloud auth list --filter=status:ACTIVE --format="table(account,status)" || echo "No active authentication"
          
          # Test if we can access required services
          echo "Testing service account permissions..."
          echo "Testing Secret Manager access..."
          if gcloud secrets list --limit=1 >/dev/null 2>&1; then
            echo "✅ Secret Manager access confirmed"
          else
            echo "❌ Secret Manager access failed"
          fi
          
          echo "Testing Artifact Registry access..."
          if gcloud artifacts repositories list --location=australia-southeast1 >/dev/null 2>&1; then
            echo "✅ Artifact Registry access confirmed"
          else
            echo "❌ Artifact Registry access failed"
          fi
          
          # Configure Docker authentication for Artifact Registry
          echo "Configuring Docker authentication for Artifact Registry..."
          gcloud auth configure-docker australia-southeast1-docker.pkg.dev --quiet
          
          # Add github-actions user to docker group
          echo "Adding github-actions user to docker group..."
          sudo usermod -aG docker github-actions || echo "User already in docker group"
          
          # Load configuration from GCP Secret Manager
          echo "Loading configuration from GCP Secret Manager..."
          
          # Initialize environment file
          touch /home/github-actions/.env.production
          
          # Load main application secrets
          echo "Loading bh-opie-backend secrets..."
          if gcloud secrets versions access latest --secret="bh-opie-backend" --project="${{ env.PROJECT_ID }}" > /home/github-actions/.env.production 2>/dev/null; then
            echo "✅ Backend secrets loaded successfully"
          else
            echo "❌ Failed to load backend secrets, using fallback values"
            echo "DEBUG=0" > /home/github-actions/.env.production
            echo "SECRET_KEY=fallback-secret-key-for-development" >> /home/github-actions/.env.production
          fi
          
          # # Load additional secrets and append
          # echo "Loading llamaindex-ingester-env secrets..."
          # if gcloud secrets versions access latest --secret="llamaindex-ingester-env" --project="${{ env.PROJECT_ID }}" >> /home/github-actions/.env.production 2>/dev/null; then
          #   echo "✅ Additional secrets loaded successfully"
          # else
          #   echo "❌ Failed to load additional secrets"
          # fi
          
          # # Load y-provider configuration from GCP Secret Manager
          # echo "Loading bh-y-provider secrets..."
          # if gcloud secrets versions access latest --secret="bh-y-provider" --project="${{ env.PROJECT_ID }}" > /home/github-actions/.env.y-provider 2>/dev/null; then
          #   echo "✅ Y-provider secrets loaded successfully"
          # else
          #   echo "❌ Failed to load y-provider secrets"
          #   echo "Y_PROVIDER_API_KEY=fallback-key" > /home/github-actions/.env.y-provider
          # fi
          
          # Debug: Show what secrets were loaded
          echo "=== Debug: Checking loaded secrets ==="
          echo "Backend secrets loaded:"
          head -5 /home/github-actions/.env.production || echo "No backend secrets found"
          echo "Additional secrets loaded:"
          tail -5 /home/github-actions/.env.production || echo "No additional secrets found"
          
          # Add static configuration
          echo "DEBUG=0" >> /home/github-actions/.env.production
          echo "GCP_PROJECT=${{ env.PROJECT_ID }}" >> /home/github-actions/.env.production
          echo "STATIC_BUCKET=bh-opie-static" >> /home/github-actions/.env.production
          echo "MEDIA_BUCKET=bh-opie-media" >> /home/github-actions/.env.production
          echo "DOCS_BUCKET=bh-opie-docs" >> /home/github-actions/.env.production
          echo "GCS_PREFIX=opie-data/global/library/" >> /home/github-actions/.env.production
          echo "PGVECTOR_SCHEMA=ai" >> /home/github-actions/.env.production
          echo "PGVECTOR_TABLE=kb__vector_table" >> /home/github-actions/.env.production
          echo "VAULT_PGVECTOR_TABLE=vault_vector_table" >> /home/github-actions/.env.production
          echo "DJANGO_API_URL=https://api.opie.sh" >> /home/github-actions/.env.production
          echo "LOCAL_DEVELOPMENT=false" >> /home/github-actions/.env.production
          
          # Add database connection variables
          echo "DB_CONNECTION_NAME=bh-opie:australia-southeast1:db0" >> /home/github-actions/.env.production
          echo "DB_NAME=bh_opie" >> /home/github-actions/.env.production
          echo "DB_USER=${{ secrets.DB_USER }}" >> /home/github-actions/.env.production
          echo "DB_PASS=${{ secrets.DB_PASS }}" >> /home/github-actions/.env.production
          
          cd /home/github-actions
          
          # Stop existing containers gracefully
          echo "Stopping existing containers..."
          for container in opie-web opie-celery-worker opie-celery-beat opie-celery-worker-heavy opie-flower y-provider redis; do
            if sudo docker ps -q -f name=$container | grep -q .; then
              echo "Stopping container: $container"
              sudo docker stop $container || true
              sudo docker rm $container || true
            else
              echo "Container $container not found, skipping"
            fi
          done
          
          # Pull latest images
          echo "Pulling latest images..."
          sudo docker pull ${{ env.ARTIFACT_REGISTRY_URL }}/${{ env.IMAGE_NAME_WEB }}:latest || true
          
          # Start Redis in background
          echo "Starting Redis..."
          sudo docker run -d --name redis --network host \
            redis:latest redis-server --appendonly yes
          
          # Wait for services to be ready
          echo "Waiting for services to be ready..."
          sleep 30
          
          # Start main application
          echo "Starting main application..."
          echo "Using VM default service account authentication..."
          echo "VM service account: bh-opie-vm-sa@bh-opie.iam.gserviceaccount.com"
          
          sudo docker run -d --name opie-web --network host \
            -e GOOGLE_CLOUD_PROJECT=${{ env.PROJECT_ID }} \
            -e FORCE_GCP_DETECTION=${{ vars.FORCE_GCP_DETECTION }} \
            -e SKIP_COLLECTSTATIC=${{ vars.SKIP_COLLECTSTATIC }} \
            -e SKIP_DATA_LOADING=${{ vars.SKIP_DATA_LOADING }} \
            -e SKIP_MIGRATIONS=${{ vars.SKIP_MIGRATIONS }} \
            -e DATABASE_URL="postgresql://${{ secrets.DB_USER }}:${{ secrets.DB_PASS }}@localhost:5432/bh_opie" \
            ${{ env.ARTIFACT_REGISTRY_URL }}/${{ env.IMAGE_NAME_WEB }}:latest
          
          sudo docker image prune -f || true
          
          # Verify deployment
          echo "Verifying deployment..."
          echo "Waiting for all services to be fully ready..."
          sleep 60
          
          # Check if web container is healthy
          echo "Checking web container status..."
          if sudo docker ps --format "table {{.Names}}\t{{.Status}}" | grep -q "opie-web.*Up"; then
            echo "✅ Web container is running"
          else
            echo "❌ Web container is not running properly"
            sudo docker ps --format "table {{.Names}}\t{{.Status}}"
          fi
          
          # Check web container logs for any errors
          echo "Checking web container logs for errors..."
          sudo docker logs opie-web --tail 20 || echo "Could not get web container logs"
          
          # Try health check with retries
          echo "Attempting health check with retries..."
          for i in {1..10}; do
            echo "Health check attempt $i/10..."
            if curl -f --connect-timeout 10 --max-time 30 http://localhost:8000/; then
              echo "✅ Health check successful!"
              break
            else
              echo "❌ Health check failed (attempt $i/10)"
              if [ $i -lt 10 ]; then
                echo "Waiting 10 seconds before retry..."
                sleep 10
              else
                echo "❌ All health check attempts failed"
                echo "Final container status:"
                sudo docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
                echo "Web container logs (last 50 lines):"
                sudo docker logs opie-web --tail 50 || echo "Could not get logs"
              fi
            fi
          done
        '