name: Deploy to GCP VM

on:
  push:
    branches: [main, dev]

env:
  PROJECT_ID: bh-opie
  REGION: australia-southeast1
  IMAGE_NAME_WEB: opie-web
  IMAGE_NAME_Y_PROVIDER: opie-y-provider
  ARTIFACT_REGISTRY_URL: australia-southeast1-docker.pkg.dev/bh-opie/containers

jobs:
  deploy:
    runs-on: ubuntu-latest  # GitHub Actions runner (Ubuntu)
    environment: bh-opie    # Deploying TO Debian VM
    permissions:
      contents: read
      id-token: write  # Required for Workload Identity Federation

    steps:
    - name: Debug Environment and Secrets
      run: |
        echo "=== Environment Debug ==="
        echo "GitHub Environment: ${{ github.environment }}"
        echo "Repository: ${{ github.repository }}"
        echo "Ref: ${{ github.ref }}"
        echo ""
        echo "=== VM Secrets Debug ==="
        echo "VM_HOST: '${{ secrets.VM_HOST }}'"
        echo "VM_USER: '${{ secrets.VM_USER }}'"
        echo "VM_SSH_KEY length: ${#VM_SSH_KEY}"
        echo ""
        echo "=== Environment Secrets Debug ==="
        echo "Environment: ${{ github.environment }}"
        echo "VM_HOST from env: '${{ env.VM_HOST }}'"
        echo "VM_USER from env: '${{ env.VM_USER }}'"
        echo ""
        echo "=== All Environment Variables ==="
        env | grep -E "^(VM_|GCP_|SECRET_|DATABASE_)" | sort || echo "No matching secrets found"
        echo ""
        echo "=== Test Secret Access ==="
        if [ -n "${{ secrets.VM_HOST }}" ]; then
          echo "✅ VM_HOST is accessible: '${{ secrets.VM_HOST }}'"
        else
          echo "❌ VM_HOST is empty or not accessible"
        fi

    - name: Checkout
      uses: actions/checkout@v3
      with:
        fetch-depth: 0

    - name: GCP Authentication
      uses: google-github-actions/auth@v2
      with:
        workload_identity_provider: 'projects/204023632747/locations/global/workloadIdentityPools/github-actions-pool/providers/github'
        service_account: 'terraform-deployer@bh-opie.iam.gserviceaccount.com'

    - name: Configure Docker for Artifact Registry
      run: gcloud auth configure-docker australia-southeast1-docker.pkg.dev --quiet

    - name: Setup Docker Buildx
      run: |
        docker buildx create --use --name multiarch
        docker buildx inspect --bootstrap

    - name: Build and Push Docker image (web)
      run: |
        echo "=== Building Docker image (web) ==="
        IMAGE_WEB=australia-southeast1-docker.pkg.dev/${{ env.PROJECT_ID }}/containers/${{ env.IMAGE_NAME_WEB }}:latest
        echo "Image: $IMAGE_WEB"
        # Note: Using Workload Identity Federation, no service account key needed
        docker buildx build --no-cache \
          -f Dockerfile.web \
          --build-arg SECRET_KEY="${{ secrets.SECRET_KEY }}" \
          --build-arg DEBUG=0 \
          --build-arg DATABASE_URL="${{ secrets.DATABASE_URL }}" \
          --build-arg DJANGO_API_KEY="${{ secrets.DJANGO_API_KEY }}" \
          --build-arg FORCE_GCP_DETECTION="${{ vars.FORCE_GCP_DETECTION }}" \
          -t $IMAGE_WEB \
          --push \
          .
        echo "✅ Web image built and pushed successfully"

    - name: Build and Push Docker image (y-provider)
      run: |
        echo "=== Building Docker image (y-provider) ==="
        cd opie-y-provider
        IMAGE_Y_PROVIDER=australia-southeast1-docker.pkg.dev/${{ env.PROJECT_ID }}/containers/${{ env.IMAGE_NAME_Y_PROVIDER }}:latest
        echo "Image: $IMAGE_Y_PROVIDER"
        docker buildx build --no-cache -f Dockerfile -t $IMAGE_Y_PROVIDER --push .
        cd ..
        echo "✅ Y-provider image built and pushed successfully"

    - name: Set up SSH
      run: |
        echo "=== SSH Setup Debug ==="
        echo "VM_HOST: ${{ secrets.VM_HOST }}"
        echo "VM_USER: ${{ secrets.VM_USER }}"
        echo "SSH_KEY length: ${#VM_SSH_KEY}"
        echo "SSH_KEY first 50 chars: ${VM_SSH_KEY:0:50}..."
        
        mkdir -p ~/.ssh
        echo "${{ secrets.VM_SSH_KEY }}" > ~/.ssh/id_rsa
        chmod 600 ~/.ssh/id_rsa
        
        echo "=== SSH Key Setup Complete ==="
        echo "SSH key file size: $(wc -c < ~/.ssh/id_rsa)"
        echo "SSH key permissions: $(ls -la ~/.ssh/id_rsa)"
        
        # Wait for VM to be ready (startup script completion)
        echo "=== VM Connection Testing ==="
        echo "Waiting for VM to complete startup..."
        echo "Testing connectivity to: ${{ secrets.VM_HOST }}"
        
        for i in {1..30}; do
          echo "Attempt $i/30: Testing SSH connection..."
          
          # Test basic connectivity first
          echo "Testing ping connectivity..."
          if ping -c 1 -W 5 ${{ secrets.VM_HOST }} >/dev/null 2>&1; then
            echo "✅ VM is reachable via ping"
          else
            echo "❌ VM is not reachable via ping"
          fi
          
          # Test SSH with different users
          echo "Testing SSH as github-actions user..."
          if timeout 10 ssh -v -o "StrictHostKeyChecking=no" -o "ConnectTimeout=5" "github-actions@${{ secrets.VM_HOST }}" "echo 'VM is ready'" 2>&1 | grep -q "VM is ready"; then
            echo "✅ VM is ready for deployment via github-actions user!"
            break
          else
            echo "❌ SSH as github-actions failed"
          fi
          
          # Try with VM_USER as fallback
          echo "Testing SSH as ${{ secrets.VM_USER }} user..."
          if timeout 10 ssh -v -o "StrictHostKeyChecking=no" -o "ConnectTimeout=5" "${{ secrets.VM_USER }}@${{ secrets.VM_HOST }}" "echo 'VM is ready'" 2>&1 | grep -q "VM is ready"; then
            echo "✅ VM is ready for deployment via ${{ secrets.VM_USER }} user!"
            break
          else
            echo "❌ SSH as ${{ secrets.VM_USER }} failed"
          fi
          
          echo "⏳ VM not ready yet, waiting 30 seconds..."
          sleep 30
        done
        
        # Add VM to known_hosts
        echo "=== Adding VM to known_hosts ==="
        ssh-keyscan -H ${{ secrets.VM_HOST }} >> ~/.ssh/known_hosts
        echo "Known hosts updated"

    - name: Setup VM for deployment
      run: |
        # Note: VM setup is handled by Terraform startup script
        # The github-actions user and directories are created automatically
        # No service account keys needed with Workload Identity Federation


    - name: Create deployment environment file on VM
      run: |
        echo "=== Creating deployment.env on VM ==="
        echo "VM_HOST: ${{ secrets.VM_HOST }}"
        echo "PROJECT_ID: ${{ env.PROJECT_ID }}"
        echo "IMAGE_NAME_WEB: ${{ env.IMAGE_NAME_WEB }}"
        echo "IMAGE_NAME_Y_PROVIDER: ${{ env.IMAGE_NAME_Y_PROVIDER }}"
        echo "ARTIFACT_REGISTRY_URL: ${{ env.ARTIFACT_REGISTRY_URL }}"
        
        # Test SSH connection first
        echo "Testing SSH connection to VM..."
        if ssh -o "StrictHostKeyChecking=no" "github-actions@${{ secrets.VM_HOST }}" "echo 'SSH connection successful'"; then
          echo "✅ SSH connection successful"
        else
          echo "❌ SSH connection failed"
          exit 1
        fi
        
        # Create deployment.env directly using github-actions user
        echo "Creating deployment.env file..."
        ssh -o "StrictHostKeyChecking=no" "github-actions@${{ secrets.VM_HOST }}" "
          echo 'Creating deployment.env file...'
          echo 'PROJECT_ID=${{ env.PROJECT_ID }}' > /home/github-actions/deployment.env
          echo 'IMAGE_NAME_WEB=${{ env.IMAGE_NAME_WEB }}' >> /home/github-actions/deployment.env
          echo 'IMAGE_NAME_Y_PROVIDER=${{ env.IMAGE_NAME_Y_PROVIDER }}' >> /home/github-actions/deployment.env
          echo 'ARTIFACT_REGISTRY_URL=${{ env.ARTIFACT_REGISTRY_URL }}' >> /home/github-actions/deployment.env
          echo 'DB_PASS=zJkaqQzBN1IM28bOxjuSg+tLlhuiofCrwBetbwHJqSo=' >> /home/github-actions/deployment.env
          echo 'DB_USER=opieuser' >> /home/github-actions/deployment.env
          echo 'DB_NAME=bh_opie' >> /home/github-actions/deployment.env
          chmod 644 /home/github-actions/deployment.env
          echo 'File created successfully'
          echo 'File contents:'
          cat /home/github-actions/deployment.env
        "

    - name: Upload docker-compose.prod.yml to VM
      run: |
        echo "=== Uploading docker-compose.prod.yml ==="
        echo "VM_HOST: ${{ secrets.VM_HOST }}"
        echo "Local file exists: $(ls -la docker-compose.prod.yml 2>/dev/null || echo 'File not found')"
        
        # Upload the file directly to github-actions user
        echo "Uploading file..."
        if scp -o "StrictHostKeyChecking=no" docker-compose.prod.yml "github-actions@${{ secrets.VM_HOST }}:/home/github-actions/docker-compose.prod.yml"; then
          echo "✅ docker-compose.prod.yml uploaded successfully"
        else
          echo "❌ Failed to upload docker-compose.prod.yml"
          exit 1
        fi
        
        # Verify file was uploaded
        echo "Verifying file upload..."
        ssh -o "StrictHostKeyChecking=no" "github-actions@${{ secrets.VM_HOST }}" "ls -la /home/github-actions/docker-compose.prod.yml"

    - name: Upload Cloud SQL proxy scripts to VM
      run: |
        echo "=== Uploading Cloud SQL proxy scripts ==="
        echo "VM_HOST: ${{ secrets.VM_HOST }}"
        echo "Scripts directory contents:"
        ls -la scripts/ || echo "Scripts directory not found"
        
        # Upload our Cloud SQL proxy scripts directly to github-actions user
        echo "Uploading start-cloudsql-proxy-production.sh..."
        if scp -o "StrictHostKeyChecking=no" scripts/start-cloudsql-proxy-production.sh "github-actions@${{ secrets.VM_HOST }}:/home/github-actions/start-cloudsql-proxy-production.sh"; then
          echo "✅ start-cloudsql-proxy-production.sh uploaded successfully"
        else
          echo "❌ Failed to upload start-cloudsql-proxy-production.sh"
          exit 1
        fi
        
        echo "Uploading install-cloudsql-proxy-service.sh..."
        if scp -o "StrictHostKeyChecking=no" scripts/install-cloudsql-proxy-service.sh "github-actions@${{ secrets.VM_HOST }}:/home/github-actions/install-cloudsql-proxy-service.sh"; then
          echo "✅ install-cloudsql-proxy-service.sh uploaded successfully"
        else
          echo "❌ Failed to upload install-cloudsql-proxy-service.sh"
          exit 1
        fi
        
        # Make scripts executable
        echo "Making scripts executable..."
        ssh -o "StrictHostKeyChecking=no" "github-actions@${{ secrets.VM_HOST }}" "
          chmod +x /home/github-actions/start-cloudsql-proxy-production.sh /home/github-actions/install-cloudsql-proxy-service.sh
          echo 'Scripts made executable'
          ls -la /home/github-actions/*.sh
        "

    - name: SSH and deploy full stack
      run: |
        ssh -o "StrictHostKeyChecking=no" "github-actions@${{ secrets.VM_HOST }}" "
          # Ensure directory exists
          mkdir -p /home/github-actions
          
          # Load all configuration from GCP Secret Manager
          echo 'Loading configuration from GCP Secret Manager...'
          
          # Initialize environment file
          touch /home/github-actions/.env.production
          
          # Load main application secrets
          echo 'Loading bh-opie-backend secrets...'
          if gcloud secrets versions access latest --secret='bh-opie-backend' --project='${{ env.PROJECT_ID }}' > /home/github-actions/.env.production 2>/dev/null; then
            echo '✅ Backend secrets loaded successfully'
          else
            echo '❌ Failed to load backend secrets, using fallback values'
            echo 'DEBUG=0' > /home/github-actions/.env.production
            echo 'SECRET_KEY=fallback-secret-key-for-development' >> /home/github-actions/.env.production
          fi
          
          # Load additional secrets and append
          echo 'Loading llamaindex-ingester-env secrets...'
          if gcloud secrets versions access latest --secret='llamaindex-ingester-env' --project='${{ env.PROJECT_ID }}' >> /home/github-actions/.env.production 2>/dev/null; then
            echo '✅ Additional secrets loaded successfully'
          else
            echo '❌ Failed to load additional secrets'
          fi
          
          # Load y-provider configuration from GCP Secret Manager
          echo 'Loading bh-y-provider secrets...'
          if gcloud secrets versions access latest --secret='bh-y-provider' --project='${{ env.PROJECT_ID }}' > /home/github-actions/.env.y-provider 2>/dev/null; then
            echo '✅ Y-provider secrets loaded successfully'
          else
            echo '❌ Failed to load y-provider secrets'
            echo 'Y_PROVIDER_API_KEY=fallback-key' > /home/github-actions/.env.y-provider
          fi
          
          # Debug: Show what secrets were loaded
          echo '=== Debug: Checking loaded secrets ==='
          echo 'Backend secrets loaded:'
          head -5 /home/github-actions/.env.production || echo 'No backend secrets found'
          echo 'Additional secrets loaded:'
          tail -5 /home/github-actions/.env.production || echo 'No additional secrets found'
          
          # Add static configuration
          echo 'DEBUG=0' >> /home/github-actions/.env.production
          echo 'GCP_PROJECT=${{ env.PROJECT_ID }}' >> /home/github-actions/.env.production
          echo 'STATIC_BUCKET=bh-opie-static' >> /home/github-actions/.env.production
          echo 'MEDIA_BUCKET=bh-opie-media' >> /home/github-actions/.env.production
          echo 'DOCS_BUCKET=bh-opie-docs' >> /home/github-actions/.env.production
          echo 'GCS_PREFIX=opie-data/global/library/' >> /home/github-actions/.env.production
          echo 'PGVECTOR_SCHEMA=ai' >> /home/github-actions/.env.production
          echo 'PGVECTOR_TABLE=kb__vector_table' >> /home/github-actions/.env.production
          echo 'VAULT_PGVECTOR_TABLE=vault_vector_table' >> /home/github-actions/.env.production
          echo 'DJANGO_API_URL=https://api.opie.sh' >> /home/github-actions/.env.production
          echo 'LOCAL_DEVELOPMENT=false' >> /home/github-actions/.env.production
          
          # Add database connection variables for Cloud SQL proxy
          echo 'DB_CONNECTION_NAME=bh-opie:australia-southeast1:db0' >> /home/github-actions/.env.production
          echo 'DB_NAME=bh_opie' >> /home/github-actions/.env.production
          
          # Set database password (use the one from deployment.env as fallback)
          echo 'DB_USER=opieuser' >> /home/github-actions/.env.production
          echo 'DB_PASS=zJkaqQzBN1IM28bOxjuSg+tLlhuiofCrwBetbwHJqSo=' >> /home/github-actions/.env.production
          
          # Extract database password from DATABASE_URL if it exists
          echo 'Extracting database password from DATABASE_URL...'
          if grep -q 'DATABASE_URL=' /home/github-actions/.env.production; then
            # Extract password from DATABASE_URL (format: postgresql://user:password@host:port/dbname)
            DB_PASS_FROM_URL=\$(grep 'DATABASE_URL=' /home/github-actions/.env.production | sed 's/.*:\/\/[^:]*:\([^@]*\)@.*/\1/')
            if [ -n \"\$DB_PASS_FROM_URL\" ]; then
              # Update DB_PASS with the extracted value
              sed -i 's/^DB_PASS=.*/DB_PASS='\$DB_PASS_FROM_URL'/' /home/github-actions/.env.production
              echo 'Database password extracted from DATABASE_URL'
            else
              echo 'Could not extract password from DATABASE_URL, using fallback'
            fi
          else
            echo 'DATABASE_URL not found in secrets, using fallback password'
          fi
          cd /home/github-actions
          export \$(cat deployment.env | xargs)
          export FORCE_GCP_DETECTION=${{ vars.FORCE_GCP_DETECTION }}
          export SKIP_COLLECTSTATIC=${{ vars.SKIP_COLLECTSTATIC }}
          export SKIP_DATA_LOADING=${{ vars.SKIP_DATA_LOADING }}
          
          # Configure Docker authentication for Artifact Registry
          echo 'Configuring Docker authentication for Artifact Registry...'
          gcloud auth configure-docker australia-southeast1-docker.pkg.dev --quiet
          
          # Setup Cloud SQL proxy for database access
          echo 'Setting up Cloud SQL proxy...'
          sudo ./install-cloudsql-proxy-service.sh --install || echo 'Cloud SQL proxy service already installed'
          
          # Cloud SQL proxy will use deployment.env for database credentials
          echo 'Cloud SQL proxy will use deployment.env for database credentials'
          
          # Start Cloud SQL proxy
          echo 'Starting Cloud SQL proxy...'
          sudo -E ./start-cloudsql-proxy-production.sh --start-iam &
          sleep 10
          
          # Wait for database to be ready
          echo 'Waiting for database connection...'
          timeout 60 bash -c 'until sudo -E ./start-cloudsql-proxy-production.sh --test; do sleep 2; done' || echo 'Database connection timeout'
          
          # Configure PgBouncer with actual database password
          echo 'Configuring PgBouncer...'
          DB_PASS=$(grep '^DB_PASS=' deployment.env | cut -d'=' -f2- | sed 's/\$//g')
          if [ -n "$DB_PASS" ]; then
            # Generate MD5 hash for PgBouncer
            PGBOUNCER_PASSWORD_HASH=$(echo -n "${DB_PASS}opieuser" | md5sum | cut -d' ' -f1)
            echo "\"opieuser\" \"md5${PGBOUNCER_PASSWORD_HASH}\"" | sudo tee /etc/pgbouncer/userlist.txt > /dev/null
            sudo systemctl restart pgbouncer
            echo 'PgBouncer configured and restarted'
          else
            echo 'Warning: DB_PASS not found, PgBouncer will use placeholder password'
          fi
          
          # Run database migrations
          echo 'Running database migrations...'
          sudo docker run --rm --network host \
            -e DJANGO_SETTINGS_MODULE=bh_opie.settings.Production \
            -e DATABASE_URL=\"${{ secrets.DATABASE_URL }}\" \
            ${{ env.ARTIFACT_REGISTRY_URL }}/${{ env.IMAGE_NAME_WEB }}:latest \
            python manage.py migrate
          
          # Deploy application stack
          echo 'Deploying application stack...'
          sudo docker-compose -f docker-compose.prod.yml down --remove-orphans
          sudo docker system prune -af
          sudo -E docker-compose -f docker-compose.prod.yml pull || true
          sudo -E docker-compose -f docker-compose.prod.yml up -d --remove-orphans
          sudo docker image prune -f || true
          
          # Verify deployment
          echo 'Verifying deployment...'
          sleep 30
          curl -f http://localhost:8000/health/ || echo 'Health check failed'
        "