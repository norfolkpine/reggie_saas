"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@lifeomic";
exports.ids = ["vendor-chunks/@lifeomic"];
exports.modules = {

/***/ "(ssr)/./node_modules/@lifeomic/attempt/dist/es6/src/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@lifeomic/attempt/dist/es6/src/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   defaultCalculateDelay: () => (/* binding */ defaultCalculateDelay),\n/* harmony export */   retry: () => (/* binding */ retry),\n/* harmony export */   sleep: () => (/* binding */ sleep)\n/* harmony export */ });\nfunction applyDefaults(options) {\n    if (!options) {\n        options = {};\n    }\n    return {\n        delay: (options.delay === undefined) ? 200 : options.delay,\n        initialDelay: (options.initialDelay === undefined) ? 0 : options.initialDelay,\n        minDelay: (options.minDelay === undefined) ? 0 : options.minDelay,\n        maxDelay: (options.maxDelay === undefined) ? 0 : options.maxDelay,\n        factor: (options.factor === undefined) ? 0 : options.factor,\n        maxAttempts: (options.maxAttempts === undefined) ? 3 : options.maxAttempts,\n        timeout: (options.timeout === undefined) ? 0 : options.timeout,\n        jitter: (options.jitter === true),\n        initialJitter: (options.initialJitter === true),\n        handleError: (options.handleError === undefined) ? null : options.handleError,\n        handleTimeout: (options.handleTimeout === undefined) ? null : options.handleTimeout,\n        beforeAttempt: (options.beforeAttempt === undefined) ? null : options.beforeAttempt,\n        calculateDelay: (options.calculateDelay === undefined) ? null : options.calculateDelay\n    };\n}\nasync function sleep(delay) {\n    return new Promise((resolve) => setTimeout(resolve, delay));\n}\nfunction defaultCalculateDelay(context, options) {\n    let delay = options.delay;\n    if (delay === 0) {\n        // no delay between attempts\n        return 0;\n    }\n    if (options.factor) {\n        delay *= Math.pow(options.factor, context.attemptNum - 1);\n        if (options.maxDelay !== 0) {\n            delay = Math.min(delay, options.maxDelay);\n        }\n    }\n    if (options.jitter) {\n        // Jitter will result in a random value between `minDelay` and\n        // calculated delay for a given attempt.\n        // See https://www.awsarchitectureblog.com/2015/03/backoff.html\n        // We're using the \"full jitter\" strategy.\n        const min = Math.ceil(options.minDelay);\n        const max = Math.floor(delay);\n        delay = Math.floor(Math.random() * (max - min + 1)) + min;\n    }\n    return Math.round(delay);\n}\nasync function retry(attemptFunc, attemptOptions) {\n    const options = applyDefaults(attemptOptions);\n    for (const prop of [\n        'delay',\n        'initialDelay',\n        'minDelay',\n        'maxDelay',\n        'maxAttempts',\n        'timeout'\n    ]) {\n        const value = options[prop];\n        if (!Number.isInteger(value) || (value < 0)) {\n            throw new Error(`Value for ${prop} must be an integer greater than or equal to 0`);\n        }\n    }\n    if ((options.factor.constructor !== Number) || (options.factor < 0)) {\n        throw new Error(`Value for factor must be a number greater than or equal to 0`);\n    }\n    if (options.delay < options.minDelay) {\n        throw new Error(`delay cannot be less than minDelay (delay: ${options.delay}, minDelay: ${options.minDelay}`);\n    }\n    const context = {\n        attemptNum: 0,\n        attemptsRemaining: options.maxAttempts ? options.maxAttempts : -1,\n        aborted: false,\n        abort() {\n            context.aborted = true;\n        }\n    };\n    const calculateDelay = options.calculateDelay || defaultCalculateDelay;\n    async function makeAttempt() {\n        if (options.beforeAttempt) {\n            options.beforeAttempt(context, options);\n        }\n        if (context.aborted) {\n            const err = new Error(`Attempt aborted`);\n            err.code = 'ATTEMPT_ABORTED';\n            throw err;\n        }\n        const onError = async (err) => {\n            if (options.handleError) {\n                await options.handleError(err, context, options);\n            }\n            if (context.aborted || (context.attemptsRemaining === 0)) {\n                throw err;\n            }\n            // We are about to try again so increment attempt number\n            context.attemptNum++;\n            const delay = calculateDelay(context, options);\n            if (delay) {\n                await sleep(delay);\n            }\n            return makeAttempt();\n        };\n        if (context.attemptsRemaining > 0) {\n            context.attemptsRemaining--;\n        }\n        if (options.timeout) {\n            return new Promise((resolve, reject) => {\n                const timer = setTimeout(() => {\n                    if (options.handleTimeout) {\n                        // If calling handleTimeout throws an error that is not wrapped in a promise\n                        // we want to catch the error and reject.\n                        try {\n                            resolve(options.handleTimeout(context, options));\n                        }\n                        catch (e) {\n                            reject(e);\n                        }\n                    }\n                    else {\n                        const err = new Error(`Retry timeout (attemptNum: ${context.attemptNum}, timeout: ${options.timeout})`);\n                        err.code = 'ATTEMPT_TIMEOUT';\n                        reject(err);\n                    }\n                }, options.timeout);\n                attemptFunc(context, options).then((result) => {\n                    clearTimeout(timer);\n                    resolve(result);\n                }).catch((err) => {\n                    clearTimeout(timer);\n                    // Calling resolve with a Promise that rejects here will result\n                    // in an unhandled rejection. Calling `reject` with errors\n                    // does not result in an unhandled rejection\n                    onError(err).then(resolve).catch(reject);\n                });\n            });\n        }\n        else {\n            // No timeout provided so wait indefinitely for the returned promise\n            // to be resolved.\n            return attemptFunc(context, options).catch(onError);\n        }\n    }\n    const initialDelay = options.calculateDelay\n        ? options.calculateDelay(context, options)\n        : options.initialDelay;\n    if (initialDelay) {\n        await sleep(initialDelay);\n    }\n    if (context.attemptNum < 1 && options.initialJitter) {\n        const delay = calculateDelay(context, options);\n        if (delay) {\n            await sleep(delay);\n        }\n    }\n    return makeAttempt();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpZmVvbWljL2F0dGVtcHQvZGlzdC9lczYvc3JjL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLE1BQU07QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLGNBQWMsY0FBYyxpQkFBaUI7QUFDbkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLG1CQUFtQixhQUFhLGdCQUFnQjtBQUM1SDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BsaXZlYmxvY2tzLWV4YW1wbGVzL25leHRqcy15anMtYmxvY2tub3RlLWFkdmFuY2VkLy4vbm9kZV9tb2R1bGVzL0BsaWZlb21pYy9hdHRlbXB0L2Rpc3QvZXM2L3NyYy9pbmRleC5qcz9hYTgwIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGFwcGx5RGVmYXVsdHMob3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0ge307XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGRlbGF5OiAob3B0aW9ucy5kZWxheSA9PT0gdW5kZWZpbmVkKSA/IDIwMCA6IG9wdGlvbnMuZGVsYXksXG4gICAgICAgIGluaXRpYWxEZWxheTogKG9wdGlvbnMuaW5pdGlhbERlbGF5ID09PSB1bmRlZmluZWQpID8gMCA6IG9wdGlvbnMuaW5pdGlhbERlbGF5LFxuICAgICAgICBtaW5EZWxheTogKG9wdGlvbnMubWluRGVsYXkgPT09IHVuZGVmaW5lZCkgPyAwIDogb3B0aW9ucy5taW5EZWxheSxcbiAgICAgICAgbWF4RGVsYXk6IChvcHRpb25zLm1heERlbGF5ID09PSB1bmRlZmluZWQpID8gMCA6IG9wdGlvbnMubWF4RGVsYXksXG4gICAgICAgIGZhY3RvcjogKG9wdGlvbnMuZmFjdG9yID09PSB1bmRlZmluZWQpID8gMCA6IG9wdGlvbnMuZmFjdG9yLFxuICAgICAgICBtYXhBdHRlbXB0czogKG9wdGlvbnMubWF4QXR0ZW1wdHMgPT09IHVuZGVmaW5lZCkgPyAzIDogb3B0aW9ucy5tYXhBdHRlbXB0cyxcbiAgICAgICAgdGltZW91dDogKG9wdGlvbnMudGltZW91dCA9PT0gdW5kZWZpbmVkKSA/IDAgOiBvcHRpb25zLnRpbWVvdXQsXG4gICAgICAgIGppdHRlcjogKG9wdGlvbnMuaml0dGVyID09PSB0cnVlKSxcbiAgICAgICAgaW5pdGlhbEppdHRlcjogKG9wdGlvbnMuaW5pdGlhbEppdHRlciA9PT0gdHJ1ZSksXG4gICAgICAgIGhhbmRsZUVycm9yOiAob3B0aW9ucy5oYW5kbGVFcnJvciA9PT0gdW5kZWZpbmVkKSA/IG51bGwgOiBvcHRpb25zLmhhbmRsZUVycm9yLFxuICAgICAgICBoYW5kbGVUaW1lb3V0OiAob3B0aW9ucy5oYW5kbGVUaW1lb3V0ID09PSB1bmRlZmluZWQpID8gbnVsbCA6IG9wdGlvbnMuaGFuZGxlVGltZW91dCxcbiAgICAgICAgYmVmb3JlQXR0ZW1wdDogKG9wdGlvbnMuYmVmb3JlQXR0ZW1wdCA9PT0gdW5kZWZpbmVkKSA/IG51bGwgOiBvcHRpb25zLmJlZm9yZUF0dGVtcHQsXG4gICAgICAgIGNhbGN1bGF0ZURlbGF5OiAob3B0aW9ucy5jYWxjdWxhdGVEZWxheSA9PT0gdW5kZWZpbmVkKSA/IG51bGwgOiBvcHRpb25zLmNhbGN1bGF0ZURlbGF5XG4gICAgfTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzbGVlcChkZWxheSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCBkZWxheSkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRDYWxjdWxhdGVEZWxheShjb250ZXh0LCBvcHRpb25zKSB7XG4gICAgbGV0IGRlbGF5ID0gb3B0aW9ucy5kZWxheTtcbiAgICBpZiAoZGVsYXkgPT09IDApIHtcbiAgICAgICAgLy8gbm8gZGVsYXkgYmV0d2VlbiBhdHRlbXB0c1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuZmFjdG9yKSB7XG4gICAgICAgIGRlbGF5ICo9IE1hdGgucG93KG9wdGlvbnMuZmFjdG9yLCBjb250ZXh0LmF0dGVtcHROdW0gLSAxKTtcbiAgICAgICAgaWYgKG9wdGlvbnMubWF4RGVsYXkgIT09IDApIHtcbiAgICAgICAgICAgIGRlbGF5ID0gTWF0aC5taW4oZGVsYXksIG9wdGlvbnMubWF4RGVsYXkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmppdHRlcikge1xuICAgICAgICAvLyBKaXR0ZXIgd2lsbCByZXN1bHQgaW4gYSByYW5kb20gdmFsdWUgYmV0d2VlbiBgbWluRGVsYXlgIGFuZFxuICAgICAgICAvLyBjYWxjdWxhdGVkIGRlbGF5IGZvciBhIGdpdmVuIGF0dGVtcHQuXG4gICAgICAgIC8vIFNlZSBodHRwczovL3d3dy5hd3NhcmNoaXRlY3R1cmVibG9nLmNvbS8yMDE1LzAzL2JhY2tvZmYuaHRtbFxuICAgICAgICAvLyBXZSdyZSB1c2luZyB0aGUgXCJmdWxsIGppdHRlclwiIHN0cmF0ZWd5LlxuICAgICAgICBjb25zdCBtaW4gPSBNYXRoLmNlaWwob3B0aW9ucy5taW5EZWxheSk7XG4gICAgICAgIGNvbnN0IG1heCA9IE1hdGguZmxvb3IoZGVsYXkpO1xuICAgICAgICBkZWxheSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4gKyAxKSkgKyBtaW47XG4gICAgfVxuICAgIHJldHVybiBNYXRoLnJvdW5kKGRlbGF5KTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZXRyeShhdHRlbXB0RnVuYywgYXR0ZW1wdE9wdGlvbnMpIHtcbiAgICBjb25zdCBvcHRpb25zID0gYXBwbHlEZWZhdWx0cyhhdHRlbXB0T3B0aW9ucyk7XG4gICAgZm9yIChjb25zdCBwcm9wIG9mIFtcbiAgICAgICAgJ2RlbGF5JyxcbiAgICAgICAgJ2luaXRpYWxEZWxheScsXG4gICAgICAgICdtaW5EZWxheScsXG4gICAgICAgICdtYXhEZWxheScsXG4gICAgICAgICdtYXhBdHRlbXB0cycsXG4gICAgICAgICd0aW1lb3V0J1xuICAgIF0pIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBvcHRpb25zW3Byb3BdO1xuICAgICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIodmFsdWUpIHx8ICh2YWx1ZSA8IDApKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFZhbHVlIGZvciAke3Byb3B9IG11c3QgYmUgYW4gaW50ZWdlciBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMGApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICgob3B0aW9ucy5mYWN0b3IuY29uc3RydWN0b3IgIT09IE51bWJlcikgfHwgKG9wdGlvbnMuZmFjdG9yIDwgMCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBWYWx1ZSBmb3IgZmFjdG9yIG11c3QgYmUgYSBudW1iZXIgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDBgKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuZGVsYXkgPCBvcHRpb25zLm1pbkRlbGF5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZGVsYXkgY2Fubm90IGJlIGxlc3MgdGhhbiBtaW5EZWxheSAoZGVsYXk6ICR7b3B0aW9ucy5kZWxheX0sIG1pbkRlbGF5OiAke29wdGlvbnMubWluRGVsYXl9YCk7XG4gICAgfVxuICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgIGF0dGVtcHROdW06IDAsXG4gICAgICAgIGF0dGVtcHRzUmVtYWluaW5nOiBvcHRpb25zLm1heEF0dGVtcHRzID8gb3B0aW9ucy5tYXhBdHRlbXB0cyA6IC0xLFxuICAgICAgICBhYm9ydGVkOiBmYWxzZSxcbiAgICAgICAgYWJvcnQoKSB7XG4gICAgICAgICAgICBjb250ZXh0LmFib3J0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBjYWxjdWxhdGVEZWxheSA9IG9wdGlvbnMuY2FsY3VsYXRlRGVsYXkgfHwgZGVmYXVsdENhbGN1bGF0ZURlbGF5O1xuICAgIGFzeW5jIGZ1bmN0aW9uIG1ha2VBdHRlbXB0KCkge1xuICAgICAgICBpZiAob3B0aW9ucy5iZWZvcmVBdHRlbXB0KSB7XG4gICAgICAgICAgICBvcHRpb25zLmJlZm9yZUF0dGVtcHQoY29udGV4dCwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnRleHQuYWJvcnRlZCkge1xuICAgICAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKGBBdHRlbXB0IGFib3J0ZWRgKTtcbiAgICAgICAgICAgIGVyci5jb2RlID0gJ0FUVEVNUFRfQUJPUlRFRCc7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb25FcnJvciA9IGFzeW5jIChlcnIpID0+IHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmhhbmRsZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgb3B0aW9ucy5oYW5kbGVFcnJvcihlcnIsIGNvbnRleHQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbnRleHQuYWJvcnRlZCB8fCAoY29udGV4dC5hdHRlbXB0c1JlbWFpbmluZyA9PT0gMCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXZSBhcmUgYWJvdXQgdG8gdHJ5IGFnYWluIHNvIGluY3JlbWVudCBhdHRlbXB0IG51bWJlclxuICAgICAgICAgICAgY29udGV4dC5hdHRlbXB0TnVtKys7XG4gICAgICAgICAgICBjb25zdCBkZWxheSA9IGNhbGN1bGF0ZURlbGF5KGNvbnRleHQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKGRlbGF5KSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgc2xlZXAoZGVsYXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1ha2VBdHRlbXB0KCk7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChjb250ZXh0LmF0dGVtcHRzUmVtYWluaW5nID4gMCkge1xuICAgICAgICAgICAgY29udGV4dC5hdHRlbXB0c1JlbWFpbmluZy0tO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLnRpbWVvdXQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuaGFuZGxlVGltZW91dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgY2FsbGluZyBoYW5kbGVUaW1lb3V0IHRocm93cyBhbiBlcnJvciB0aGF0IGlzIG5vdCB3cmFwcGVkIGluIGEgcHJvbWlzZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2Ugd2FudCB0byBjYXRjaCB0aGUgZXJyb3IgYW5kIHJlamVjdC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShvcHRpb25zLmhhbmRsZVRpbWVvdXQoY29udGV4dCwgb3B0aW9ucykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoYFJldHJ5IHRpbWVvdXQgKGF0dGVtcHROdW06ICR7Y29udGV4dC5hdHRlbXB0TnVtfSwgdGltZW91dDogJHtvcHRpb25zLnRpbWVvdXR9KWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyLmNvZGUgPSAnQVRURU1QVF9USU1FT1VUJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgb3B0aW9ucy50aW1lb3V0KTtcbiAgICAgICAgICAgICAgICBhdHRlbXB0RnVuYyhjb250ZXh0LCBvcHRpb25zKS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FsbGluZyByZXNvbHZlIHdpdGggYSBQcm9taXNlIHRoYXQgcmVqZWN0cyBoZXJlIHdpbGwgcmVzdWx0XG4gICAgICAgICAgICAgICAgICAgIC8vIGluIGFuIHVuaGFuZGxlZCByZWplY3Rpb24uIENhbGxpbmcgYHJlamVjdGAgd2l0aCBlcnJvcnNcbiAgICAgICAgICAgICAgICAgICAgLy8gZG9lcyBub3QgcmVzdWx0IGluIGFuIHVuaGFuZGxlZCByZWplY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcihlcnIpLnRoZW4ocmVzb2x2ZSkuY2F0Y2gocmVqZWN0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gTm8gdGltZW91dCBwcm92aWRlZCBzbyB3YWl0IGluZGVmaW5pdGVseSBmb3IgdGhlIHJldHVybmVkIHByb21pc2VcbiAgICAgICAgICAgIC8vIHRvIGJlIHJlc29sdmVkLlxuICAgICAgICAgICAgcmV0dXJuIGF0dGVtcHRGdW5jKGNvbnRleHQsIG9wdGlvbnMpLmNhdGNoKG9uRXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGluaXRpYWxEZWxheSA9IG9wdGlvbnMuY2FsY3VsYXRlRGVsYXlcbiAgICAgICAgPyBvcHRpb25zLmNhbGN1bGF0ZURlbGF5KGNvbnRleHQsIG9wdGlvbnMpXG4gICAgICAgIDogb3B0aW9ucy5pbml0aWFsRGVsYXk7XG4gICAgaWYgKGluaXRpYWxEZWxheSkge1xuICAgICAgICBhd2FpdCBzbGVlcChpbml0aWFsRGVsYXkpO1xuICAgIH1cbiAgICBpZiAoY29udGV4dC5hdHRlbXB0TnVtIDwgMSAmJiBvcHRpb25zLmluaXRpYWxKaXR0ZXIpIHtcbiAgICAgICAgY29uc3QgZGVsYXkgPSBjYWxjdWxhdGVEZWxheShjb250ZXh0LCBvcHRpb25zKTtcbiAgICAgICAgaWYgKGRlbGF5KSB7XG4gICAgICAgICAgICBhd2FpdCBzbGVlcChkZWxheSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1ha2VBdHRlbXB0KCk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lifeomic/attempt/dist/es6/src/index.js\n");

/***/ })

};
;