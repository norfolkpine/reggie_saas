"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@hocuspocus";
exports.ids = ["vendor-chunks/@hocuspocus"];
exports.modules = {

/***/ "(ssr)/./node_modules/@hocuspocus/common/dist/hocuspocus-common.esm.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@hocuspocus/common/dist/hocuspocus-common.esm.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConnectionTimeout: () => (/* binding */ ConnectionTimeout),\n/* harmony export */   Forbidden: () => (/* binding */ Forbidden),\n/* harmony export */   MessageTooBig: () => (/* binding */ MessageTooBig),\n/* harmony export */   ResetConnection: () => (/* binding */ ResetConnection),\n/* harmony export */   Unauthorized: () => (/* binding */ Unauthorized),\n/* harmony export */   WsReadyStates: () => (/* binding */ WsReadyStates),\n/* harmony export */   awarenessStatesToArray: () => (/* binding */ awarenessStatesToArray),\n/* harmony export */   readAuthMessage: () => (/* binding */ readAuthMessage),\n/* harmony export */   writeAuthenticated: () => (/* binding */ writeAuthenticated),\n/* harmony export */   writeAuthentication: () => (/* binding */ writeAuthentication),\n/* harmony export */   writePermissionDenied: () => (/* binding */ writePermissionDenied)\n/* harmony export */ });\n/**\n * Common Math expressions.\n *\n * @module math\n */\n\nconst floor = Math.floor;\n\n/**\n * @function\n * @param {number} a\n * @param {number} b\n * @return {number} The smaller element of a and b\n */\nconst min = (a, b) => a < b ? a : b;\n\n/**\n * @function\n * @param {number} a\n * @param {number} b\n * @return {number} The bigger element of a and b\n */\nconst max = (a, b) => a > b ? a : b;\n\n/* eslint-env browser */\n\nconst BIT8 = 128;\nconst BITS7 = 127;\n\n/**\n * Utility helpers for working with numbers.\n *\n * @module number\n */\n\n\nconst MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER;\n\n/**\n * @param {string} str\n * @return {Uint8Array}\n */\nconst _encodeUtf8Polyfill = str => {\n  const encodedString = unescape(encodeURIComponent(str));\n  const len = encodedString.length;\n  const buf = new Uint8Array(len);\n  for (let i = 0; i < len; i++) {\n    buf[i] = /** @type {number} */ (encodedString.codePointAt(i));\n  }\n  return buf\n};\n\n/* c8 ignore next */\nconst utf8TextEncoder = /** @type {TextEncoder} */ (typeof TextEncoder !== 'undefined' ? new TextEncoder() : null);\n\n/**\n * @param {string} str\n * @return {Uint8Array}\n */\nconst _encodeUtf8Native = str => utf8TextEncoder.encode(str);\n\n/**\n * @param {string} str\n * @return {Uint8Array}\n */\n/* c8 ignore next */\nconst encodeUtf8 = utf8TextEncoder ? _encodeUtf8Native : _encodeUtf8Polyfill;\n\n/* c8 ignore next */\nlet utf8TextDecoder = typeof TextDecoder === 'undefined' ? null : new TextDecoder('utf-8', { fatal: true, ignoreBOM: true });\n\n/* c8 ignore start */\nif (utf8TextDecoder && utf8TextDecoder.decode(new Uint8Array()).length === 1) {\n  // Safari doesn't handle BOM correctly.\n  // This fixes a bug in Safari 13.0.5 where it produces a BOM the first time it is called.\n  // utf8TextDecoder.decode(new Uint8Array()).length === 1 on the first call and\n  // utf8TextDecoder.decode(new Uint8Array()).length === 1 on the second call\n  // Another issue is that from then on no BOM chars are recognized anymore\n  /* c8 ignore next */\n  utf8TextDecoder = null;\n}\n\n/**\n * Efficient schema-less binary encoding with support for variable length encoding.\n *\n * Use [lib0/encoding] with [lib0/decoding]. Every encoding function has a corresponding decoding function.\n *\n * Encodes numbers in little-endian order (least to most significant byte order)\n * and is compatible with Golang's binary encoding (https://golang.org/pkg/encoding/binary/)\n * which is also used in Protocol Buffers.\n *\n * ```js\n * // encoding step\n * const encoder = encoding.createEncoder()\n * encoding.writeVarUint(encoder, 256)\n * encoding.writeVarString(encoder, 'Hello world!')\n * const buf = encoding.toUint8Array(encoder)\n * ```\n *\n * ```js\n * // decoding step\n * const decoder = decoding.createDecoder(buf)\n * decoding.readVarUint(decoder) // => 256\n * decoding.readVarString(decoder) // => 'Hello world!'\n * decoding.hasContent(decoder) // => false - all data is read\n * ```\n *\n * @module encoding\n */\n\n\n/**\n * Write one byte to the encoder.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The byte that is to be encoded.\n */\nconst write = (encoder, num) => {\n  const bufferLen = encoder.cbuf.length;\n  if (encoder.cpos === bufferLen) {\n    encoder.bufs.push(encoder.cbuf);\n    encoder.cbuf = new Uint8Array(bufferLen * 2);\n    encoder.cpos = 0;\n  }\n  encoder.cbuf[encoder.cpos++] = num;\n};\n\n/**\n * Write a variable length unsigned integer. Max encodable integer is 2^53.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nconst writeVarUint = (encoder, num) => {\n  while (num > BITS7) {\n    write(encoder, BIT8 | (BITS7 & num));\n    num = floor(num / 128); // shift >>> 7\n  }\n  write(encoder, BITS7 & num);\n};\n\n/**\n * A cache to store strings temporarily\n */\nconst _strBuffer = new Uint8Array(30000);\nconst _maxStrBSize = _strBuffer.length / 3;\n\n/**\n * Write a variable length string.\n *\n * @function\n * @param {Encoder} encoder\n * @param {String} str The string that is to be encoded.\n */\nconst _writeVarStringNative = (encoder, str) => {\n  if (str.length < _maxStrBSize) {\n    // We can encode the string into the existing buffer\n    /* c8 ignore next */\n    const written = utf8TextEncoder.encodeInto(str, _strBuffer).written || 0;\n    writeVarUint(encoder, written);\n    for (let i = 0; i < written; i++) {\n      write(encoder, _strBuffer[i]);\n    }\n  } else {\n    writeVarUint8Array(encoder, encodeUtf8(str));\n  }\n};\n\n/**\n * Write a variable length string.\n *\n * @function\n * @param {Encoder} encoder\n * @param {String} str The string that is to be encoded.\n */\nconst _writeVarStringPolyfill = (encoder, str) => {\n  const encodedString = unescape(encodeURIComponent(str));\n  const len = encodedString.length;\n  writeVarUint(encoder, len);\n  for (let i = 0; i < len; i++) {\n    write(encoder, /** @type {number} */ (encodedString.codePointAt(i)));\n  }\n};\n\n/**\n * Write a variable length string.\n *\n * @function\n * @param {Encoder} encoder\n * @param {String} str The string that is to be encoded.\n */\n/* c8 ignore next */\nconst writeVarString = (utf8TextEncoder && /** @type {any} */ (utf8TextEncoder).encodeInto) ? _writeVarStringNative : _writeVarStringPolyfill;\n\n/**\n * Append fixed-length Uint8Array to the encoder.\n *\n * @function\n * @param {Encoder} encoder\n * @param {Uint8Array} uint8Array\n */\nconst writeUint8Array = (encoder, uint8Array) => {\n  const bufferLen = encoder.cbuf.length;\n  const cpos = encoder.cpos;\n  const leftCopyLen = min(bufferLen - cpos, uint8Array.length);\n  const rightCopyLen = uint8Array.length - leftCopyLen;\n  encoder.cbuf.set(uint8Array.subarray(0, leftCopyLen), cpos);\n  encoder.cpos += leftCopyLen;\n  if (rightCopyLen > 0) {\n    // Still something to write, write right half..\n    // Append new buffer\n    encoder.bufs.push(encoder.cbuf);\n    // must have at least size of remaining buffer\n    encoder.cbuf = new Uint8Array(max(bufferLen * 2, rightCopyLen));\n    // copy array\n    encoder.cbuf.set(uint8Array.subarray(leftCopyLen));\n    encoder.cpos = rightCopyLen;\n  }\n};\n\n/**\n * Append an Uint8Array to Encoder.\n *\n * @function\n * @param {Encoder} encoder\n * @param {Uint8Array} uint8Array\n */\nconst writeVarUint8Array = (encoder, uint8Array) => {\n  writeVarUint(encoder, uint8Array.byteLength);\n  writeUint8Array(encoder, uint8Array);\n};\n\n/**\n * Error helpers.\n *\n * @module error\n */\n\n/**\n * @param {string} s\n * @return {Error}\n */\n/* c8 ignore next */\nconst create = s => new Error(s);\n\n/**\n * Efficient schema-less binary decoding with support for variable length encoding.\n *\n * Use [lib0/decoding] with [lib0/encoding]. Every encoding function has a corresponding decoding function.\n *\n * Encodes numbers in little-endian order (least to most significant byte order)\n * and is compatible with Golang's binary encoding (https://golang.org/pkg/encoding/binary/)\n * which is also used in Protocol Buffers.\n *\n * ```js\n * // encoding step\n * const encoder = encoding.createEncoder()\n * encoding.writeVarUint(encoder, 256)\n * encoding.writeVarString(encoder, 'Hello world!')\n * const buf = encoding.toUint8Array(encoder)\n * ```\n *\n * ```js\n * // decoding step\n * const decoder = decoding.createDecoder(buf)\n * decoding.readVarUint(decoder) // => 256\n * decoding.readVarString(decoder) // => 'Hello world!'\n * decoding.hasContent(decoder) // => false - all data is read\n * ```\n *\n * @module decoding\n */\n\n\nconst errorUnexpectedEndOfArray = create('Unexpected end of array');\nconst errorIntegerOutOfRange = create('Integer out of Range');\n\n/**\n * Create an Uint8Array view of the next `len` bytes and advance the position by `len`.\n *\n * Important: The Uint8Array still points to the underlying ArrayBuffer. Make sure to discard the result as soon as possible to prevent any memory leaks.\n *            Use `buffer.copyUint8Array` to copy the result into a new Uint8Array.\n *\n * @function\n * @param {Decoder} decoder The decoder instance\n * @param {number} len The length of bytes to read\n * @return {Uint8Array}\n */\nconst readUint8Array = (decoder, len) => {\n  const view = new Uint8Array(decoder.arr.buffer, decoder.pos + decoder.arr.byteOffset, len);\n  decoder.pos += len;\n  return view\n};\n\n/**\n * Read variable length Uint8Array.\n *\n * Important: The Uint8Array still points to the underlying ArrayBuffer. Make sure to discard the result as soon as possible to prevent any memory leaks.\n *            Use `buffer.copyUint8Array` to copy the result into a new Uint8Array.\n *\n * @function\n * @param {Decoder} decoder\n * @return {Uint8Array}\n */\nconst readVarUint8Array = decoder => readUint8Array(decoder, readVarUint(decoder));\n\n/**\n * Read one byte as unsigned integer.\n * @function\n * @param {Decoder} decoder The decoder instance\n * @return {number} Unsigned 8-bit integer\n */\nconst readUint8 = decoder => decoder.arr[decoder.pos++];\n\n/**\n * Read unsigned integer (32bit) with variable length.\n * 1/8th of the storage is used as encoding overhead.\n *  * numbers < 2^7 is stored in one bytlength\n *  * numbers < 2^14 is stored in two bylength\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.length\n */\nconst readVarUint = decoder => {\n  let num = 0;\n  let mult = 1;\n  const len = decoder.arr.length;\n  while (decoder.pos < len) {\n    const r = decoder.arr[decoder.pos++];\n    // num = num | ((r & binary.BITS7) << len)\n    num = num + (r & BITS7) * mult; // shift $r << (7*#iterations) and add it to num\n    mult *= 128; // next iteration, shift 7 \"more\" to the left\n    if (r < BIT8) {\n      return num\n    }\n    /* c8 ignore start */\n    if (num > MAX_SAFE_INTEGER) {\n      throw errorIntegerOutOfRange\n    }\n    /* c8 ignore stop */\n  }\n  throw errorUnexpectedEndOfArray\n};\n\n/**\n * We don't test this function anymore as we use native decoding/encoding by default now.\n * Better not modify this anymore..\n *\n * Transforming utf8 to a string is pretty expensive. The code performs 10x better\n * when String.fromCodePoint is fed with all characters as arguments.\n * But most environments have a maximum number of arguments per functions.\n * For effiency reasons we apply a maximum of 10000 characters at once.\n *\n * @function\n * @param {Decoder} decoder\n * @return {String} The read String.\n */\n/* c8 ignore start */\nconst _readVarStringPolyfill = decoder => {\n  let remainingLen = readVarUint(decoder);\n  if (remainingLen === 0) {\n    return ''\n  } else {\n    let encodedString = String.fromCodePoint(readUint8(decoder)); // remember to decrease remainingLen\n    if (--remainingLen < 100) { // do not create a Uint8Array for small strings\n      while (remainingLen--) {\n        encodedString += String.fromCodePoint(readUint8(decoder));\n      }\n    } else {\n      while (remainingLen > 0) {\n        const nextLen = remainingLen < 10000 ? remainingLen : 10000;\n        // this is dangerous, we create a fresh array view from the existing buffer\n        const bytes = decoder.arr.subarray(decoder.pos, decoder.pos + nextLen);\n        decoder.pos += nextLen;\n        // Starting with ES5.1 we can supply a generic array-like object as arguments\n        encodedString += String.fromCodePoint.apply(null, /** @type {any} */ (bytes));\n        remainingLen -= nextLen;\n      }\n    }\n    return decodeURIComponent(escape(encodedString))\n  }\n};\n/* c8 ignore stop */\n\n/**\n * @function\n * @param {Decoder} decoder\n * @return {String} The read String\n */\nconst _readVarStringNative = decoder =>\n  /** @type any */ (utf8TextDecoder).decode(readVarUint8Array(decoder));\n\n/**\n * Read string of variable length\n * * varUint is used to store the length of the string\n *\n * @function\n * @param {Decoder} decoder\n * @return {String} The read String\n *\n */\n/* c8 ignore next */\nconst readVarString = utf8TextDecoder ? _readVarStringNative : _readVarStringPolyfill;\n\nvar AuthMessageType;\n(function (AuthMessageType) {\n    AuthMessageType[AuthMessageType[\"Token\"] = 0] = \"Token\";\n    AuthMessageType[AuthMessageType[\"PermissionDenied\"] = 1] = \"PermissionDenied\";\n    AuthMessageType[AuthMessageType[\"Authenticated\"] = 2] = \"Authenticated\";\n})(AuthMessageType || (AuthMessageType = {}));\nconst writeAuthentication = (encoder, auth) => {\n    writeVarUint(encoder, AuthMessageType.Token);\n    writeVarString(encoder, auth);\n};\nconst writePermissionDenied = (encoder, reason) => {\n    writeVarUint(encoder, AuthMessageType.PermissionDenied);\n    writeVarString(encoder, reason);\n};\nconst writeAuthenticated = (encoder, scope) => {\n    writeVarUint(encoder, AuthMessageType.Authenticated);\n    writeVarString(encoder, scope);\n};\nconst readAuthMessage = (decoder, permissionDeniedHandler, authenticatedHandler) => {\n    switch (readVarUint(decoder)) {\n        case AuthMessageType.PermissionDenied: {\n            permissionDeniedHandler(readVarString(decoder));\n            break;\n        }\n        case AuthMessageType.Authenticated: {\n            authenticatedHandler(readVarString(decoder));\n            break;\n        }\n    }\n};\n\n/**\n * The server is terminating the connection because a data frame was received\n * that is too large.\n * See: https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent/code\n */\nconst MessageTooBig = {\n    code: 1009,\n    reason: 'Message Too Big',\n};\n/**\n * The server successfully processed the request, asks that the requester reset\n * its document view, and is not returning any content.\n */\nconst ResetConnection = {\n    code: 4205,\n    reason: 'Reset Connection',\n};\n/**\n * Similar to Forbidden, but specifically for use when authentication is required and has\n * failed or has not yet been provided.\n */\nconst Unauthorized = {\n    code: 4401,\n    reason: 'Unauthorized',\n};\n/**\n * The request contained valid data and was understood by the server, but the server\n * is refusing action.\n */\nconst Forbidden = {\n    code: 4403,\n    reason: 'Forbidden',\n};\n/**\n * The server timed out waiting for the request.\n */\nconst ConnectionTimeout = {\n    code: 4408,\n    reason: 'Connection Timeout',\n};\n\nconst awarenessStatesToArray = (states) => {\n    return Array.from(states.entries()).map(([key, value]) => {\n        return {\n            clientId: key,\n            ...value,\n        };\n    });\n};\n\n/**\n * State of the WebSocket connection.\n * https://developer.mozilla.org/de/docs/Web/API/WebSocket/readyState\n */\nvar WsReadyStates;\n(function (WsReadyStates) {\n    WsReadyStates[WsReadyStates[\"Connecting\"] = 0] = \"Connecting\";\n    WsReadyStates[WsReadyStates[\"Open\"] = 1] = \"Open\";\n    WsReadyStates[WsReadyStates[\"Closing\"] = 2] = \"Closing\";\n    WsReadyStates[WsReadyStates[\"Closed\"] = 3] = \"Closed\";\n})(WsReadyStates || (WsReadyStates = {}));\n\n\n//# sourceMappingURL=hocuspocus-common.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGhvY3VzcG9jdXMvY29tbW9uL2Rpc3QvaG9jdXNwb2N1cy1jb21tb24uZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0Isd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DLGFBQWE7O0FBRWhEO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2RkFBNkYsOEJBQThCOztBQUUzSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0NBQXNDOztBQUV1SztBQUM5TSIsInNvdXJjZXMiOlsid2VicGFjazovL0BsaXZlYmxvY2tzLWV4YW1wbGVzL25leHRqcy15anMtYmxvY2tub3RlLWFkdmFuY2VkLy4vbm9kZV9tb2R1bGVzL0Bob2N1c3BvY3VzL2NvbW1vbi9kaXN0L2hvY3VzcG9jdXMtY29tbW9uLmVzbS5qcz9jMmE1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29tbW9uIE1hdGggZXhwcmVzc2lvbnMuXG4gKlxuICogQG1vZHVsZSBtYXRoXG4gKi9cblxuY29uc3QgZmxvb3IgPSBNYXRoLmZsb29yO1xuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IGFcbiAqIEBwYXJhbSB7bnVtYmVyfSBiXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBzbWFsbGVyIGVsZW1lbnQgb2YgYSBhbmQgYlxuICovXG5jb25zdCBtaW4gPSAoYSwgYikgPT4gYSA8IGIgPyBhIDogYjtcblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBhXG4gKiBAcGFyYW0ge251bWJlcn0gYlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgYmlnZ2VyIGVsZW1lbnQgb2YgYSBhbmQgYlxuICovXG5jb25zdCBtYXggPSAoYSwgYikgPT4gYSA+IGIgPyBhIDogYjtcblxuLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbmNvbnN0IEJJVDggPSAxMjg7XG5jb25zdCBCSVRTNyA9IDEyNztcblxuLyoqXG4gKiBVdGlsaXR5IGhlbHBlcnMgZm9yIHdvcmtpbmcgd2l0aCBudW1iZXJzLlxuICpcbiAqIEBtb2R1bGUgbnVtYmVyXG4gKi9cblxuXG5jb25zdCBNQVhfU0FGRV9JTlRFR0VSID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHJldHVybiB7VWludDhBcnJheX1cbiAqL1xuY29uc3QgX2VuY29kZVV0ZjhQb2x5ZmlsbCA9IHN0ciA9PiB7XG4gIGNvbnN0IGVuY29kZWRTdHJpbmcgPSB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoc3RyKSk7XG4gIGNvbnN0IGxlbiA9IGVuY29kZWRTdHJpbmcubGVuZ3RoO1xuICBjb25zdCBidWYgPSBuZXcgVWludDhBcnJheShsZW4pO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgYnVmW2ldID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChlbmNvZGVkU3RyaW5nLmNvZGVQb2ludEF0KGkpKTtcbiAgfVxuICByZXR1cm4gYnVmXG59O1xuXG4vKiBjOCBpZ25vcmUgbmV4dCAqL1xuY29uc3QgdXRmOFRleHRFbmNvZGVyID0gLyoqIEB0eXBlIHtUZXh0RW5jb2Rlcn0gKi8gKHR5cGVvZiBUZXh0RW5jb2RlciAhPT0gJ3VuZGVmaW5lZCcgPyBuZXcgVGV4dEVuY29kZXIoKSA6IG51bGwpO1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKi9cbmNvbnN0IF9lbmNvZGVVdGY4TmF0aXZlID0gc3RyID0+IHV0ZjhUZXh0RW5jb2Rlci5lbmNvZGUoc3RyKTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICovXG4vKiBjOCBpZ25vcmUgbmV4dCAqL1xuY29uc3QgZW5jb2RlVXRmOCA9IHV0ZjhUZXh0RW5jb2RlciA/IF9lbmNvZGVVdGY4TmF0aXZlIDogX2VuY29kZVV0ZjhQb2x5ZmlsbDtcblxuLyogYzggaWdub3JlIG5leHQgKi9cbmxldCB1dGY4VGV4dERlY29kZXIgPSB0eXBlb2YgVGV4dERlY29kZXIgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IG5ldyBUZXh0RGVjb2RlcigndXRmLTgnLCB7IGZhdGFsOiB0cnVlLCBpZ25vcmVCT006IHRydWUgfSk7XG5cbi8qIGM4IGlnbm9yZSBzdGFydCAqL1xuaWYgKHV0ZjhUZXh0RGVjb2RlciAmJiB1dGY4VGV4dERlY29kZXIuZGVjb2RlKG5ldyBVaW50OEFycmF5KCkpLmxlbmd0aCA9PT0gMSkge1xuICAvLyBTYWZhcmkgZG9lc24ndCBoYW5kbGUgQk9NIGNvcnJlY3RseS5cbiAgLy8gVGhpcyBmaXhlcyBhIGJ1ZyBpbiBTYWZhcmkgMTMuMC41IHdoZXJlIGl0IHByb2R1Y2VzIGEgQk9NIHRoZSBmaXJzdCB0aW1lIGl0IGlzIGNhbGxlZC5cbiAgLy8gdXRmOFRleHREZWNvZGVyLmRlY29kZShuZXcgVWludDhBcnJheSgpKS5sZW5ndGggPT09IDEgb24gdGhlIGZpcnN0IGNhbGwgYW5kXG4gIC8vIHV0ZjhUZXh0RGVjb2Rlci5kZWNvZGUobmV3IFVpbnQ4QXJyYXkoKSkubGVuZ3RoID09PSAxIG9uIHRoZSBzZWNvbmQgY2FsbFxuICAvLyBBbm90aGVyIGlzc3VlIGlzIHRoYXQgZnJvbSB0aGVuIG9uIG5vIEJPTSBjaGFycyBhcmUgcmVjb2duaXplZCBhbnltb3JlXG4gIC8qIGM4IGlnbm9yZSBuZXh0ICovXG4gIHV0ZjhUZXh0RGVjb2RlciA9IG51bGw7XG59XG5cbi8qKlxuICogRWZmaWNpZW50IHNjaGVtYS1sZXNzIGJpbmFyeSBlbmNvZGluZyB3aXRoIHN1cHBvcnQgZm9yIHZhcmlhYmxlIGxlbmd0aCBlbmNvZGluZy5cbiAqXG4gKiBVc2UgW2xpYjAvZW5jb2RpbmddIHdpdGggW2xpYjAvZGVjb2RpbmddLiBFdmVyeSBlbmNvZGluZyBmdW5jdGlvbiBoYXMgYSBjb3JyZXNwb25kaW5nIGRlY29kaW5nIGZ1bmN0aW9uLlxuICpcbiAqIEVuY29kZXMgbnVtYmVycyBpbiBsaXR0bGUtZW5kaWFuIG9yZGVyIChsZWFzdCB0byBtb3N0IHNpZ25pZmljYW50IGJ5dGUgb3JkZXIpXG4gKiBhbmQgaXMgY29tcGF0aWJsZSB3aXRoIEdvbGFuZydzIGJpbmFyeSBlbmNvZGluZyAoaHR0cHM6Ly9nb2xhbmcub3JnL3BrZy9lbmNvZGluZy9iaW5hcnkvKVxuICogd2hpY2ggaXMgYWxzbyB1c2VkIGluIFByb3RvY29sIEJ1ZmZlcnMuXG4gKlxuICogYGBganNcbiAqIC8vIGVuY29kaW5nIHN0ZXBcbiAqIGNvbnN0IGVuY29kZXIgPSBlbmNvZGluZy5jcmVhdGVFbmNvZGVyKClcbiAqIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLCAyNTYpXG4gKiBlbmNvZGluZy53cml0ZVZhclN0cmluZyhlbmNvZGVyLCAnSGVsbG8gd29ybGQhJylcbiAqIGNvbnN0IGJ1ZiA9IGVuY29kaW5nLnRvVWludDhBcnJheShlbmNvZGVyKVxuICogYGBgXG4gKlxuICogYGBganNcbiAqIC8vIGRlY29kaW5nIHN0ZXBcbiAqIGNvbnN0IGRlY29kZXIgPSBkZWNvZGluZy5jcmVhdGVEZWNvZGVyKGJ1ZilcbiAqIGRlY29kaW5nLnJlYWRWYXJVaW50KGRlY29kZXIpIC8vID0+IDI1NlxuICogZGVjb2RpbmcucmVhZFZhclN0cmluZyhkZWNvZGVyKSAvLyA9PiAnSGVsbG8gd29ybGQhJ1xuICogZGVjb2RpbmcuaGFzQ29udGVudChkZWNvZGVyKSAvLyA9PiBmYWxzZSAtIGFsbCBkYXRhIGlzIHJlYWRcbiAqIGBgYFxuICpcbiAqIEBtb2R1bGUgZW5jb2RpbmdcbiAqL1xuXG5cbi8qKlxuICogV3JpdGUgb25lIGJ5dGUgdG8gdGhlIGVuY29kZXIuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW0gVGhlIGJ5dGUgdGhhdCBpcyB0byBiZSBlbmNvZGVkLlxuICovXG5jb25zdCB3cml0ZSA9IChlbmNvZGVyLCBudW0pID0+IHtcbiAgY29uc3QgYnVmZmVyTGVuID0gZW5jb2Rlci5jYnVmLmxlbmd0aDtcbiAgaWYgKGVuY29kZXIuY3BvcyA9PT0gYnVmZmVyTGVuKSB7XG4gICAgZW5jb2Rlci5idWZzLnB1c2goZW5jb2Rlci5jYnVmKTtcbiAgICBlbmNvZGVyLmNidWYgPSBuZXcgVWludDhBcnJheShidWZmZXJMZW4gKiAyKTtcbiAgICBlbmNvZGVyLmNwb3MgPSAwO1xuICB9XG4gIGVuY29kZXIuY2J1ZltlbmNvZGVyLmNwb3MrK10gPSBudW07XG59O1xuXG4vKipcbiAqIFdyaXRlIGEgdmFyaWFibGUgbGVuZ3RoIHVuc2lnbmVkIGludGVnZXIuIE1heCBlbmNvZGFibGUgaW50ZWdlciBpcyAyXjUzLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtIFRoZSBudW1iZXIgdGhhdCBpcyB0byBiZSBlbmNvZGVkLlxuICovXG5jb25zdCB3cml0ZVZhclVpbnQgPSAoZW5jb2RlciwgbnVtKSA9PiB7XG4gIHdoaWxlIChudW0gPiBCSVRTNykge1xuICAgIHdyaXRlKGVuY29kZXIsIEJJVDggfCAoQklUUzcgJiBudW0pKTtcbiAgICBudW0gPSBmbG9vcihudW0gLyAxMjgpOyAvLyBzaGlmdCA+Pj4gN1xuICB9XG4gIHdyaXRlKGVuY29kZXIsIEJJVFM3ICYgbnVtKTtcbn07XG5cbi8qKlxuICogQSBjYWNoZSB0byBzdG9yZSBzdHJpbmdzIHRlbXBvcmFyaWx5XG4gKi9cbmNvbnN0IF9zdHJCdWZmZXIgPSBuZXcgVWludDhBcnJheSgzMDAwMCk7XG5jb25zdCBfbWF4U3RyQlNpemUgPSBfc3RyQnVmZmVyLmxlbmd0aCAvIDM7XG5cbi8qKlxuICogV3JpdGUgYSB2YXJpYWJsZSBsZW5ndGggc3RyaW5nLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdGhhdCBpcyB0byBiZSBlbmNvZGVkLlxuICovXG5jb25zdCBfd3JpdGVWYXJTdHJpbmdOYXRpdmUgPSAoZW5jb2Rlciwgc3RyKSA9PiB7XG4gIGlmIChzdHIubGVuZ3RoIDwgX21heFN0ckJTaXplKSB7XG4gICAgLy8gV2UgY2FuIGVuY29kZSB0aGUgc3RyaW5nIGludG8gdGhlIGV4aXN0aW5nIGJ1ZmZlclxuICAgIC8qIGM4IGlnbm9yZSBuZXh0ICovXG4gICAgY29uc3Qgd3JpdHRlbiA9IHV0ZjhUZXh0RW5jb2Rlci5lbmNvZGVJbnRvKHN0ciwgX3N0ckJ1ZmZlcikud3JpdHRlbiB8fCAwO1xuICAgIHdyaXRlVmFyVWludChlbmNvZGVyLCB3cml0dGVuKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdyaXR0ZW47IGkrKykge1xuICAgICAgd3JpdGUoZW5jb2RlciwgX3N0ckJ1ZmZlcltpXSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHdyaXRlVmFyVWludDhBcnJheShlbmNvZGVyLCBlbmNvZGVVdGY4KHN0cikpO1xuICB9XG59O1xuXG4vKipcbiAqIFdyaXRlIGEgdmFyaWFibGUgbGVuZ3RoIHN0cmluZy5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgc3RyaW5nIHRoYXQgaXMgdG8gYmUgZW5jb2RlZC5cbiAqL1xuY29uc3QgX3dyaXRlVmFyU3RyaW5nUG9seWZpbGwgPSAoZW5jb2Rlciwgc3RyKSA9PiB7XG4gIGNvbnN0IGVuY29kZWRTdHJpbmcgPSB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoc3RyKSk7XG4gIGNvbnN0IGxlbiA9IGVuY29kZWRTdHJpbmcubGVuZ3RoO1xuICB3cml0ZVZhclVpbnQoZW5jb2RlciwgbGVuKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHdyaXRlKGVuY29kZXIsIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoZW5jb2RlZFN0cmluZy5jb2RlUG9pbnRBdChpKSkpO1xuICB9XG59O1xuXG4vKipcbiAqIFdyaXRlIGEgdmFyaWFibGUgbGVuZ3RoIHN0cmluZy5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgc3RyaW5nIHRoYXQgaXMgdG8gYmUgZW5jb2RlZC5cbiAqL1xuLyogYzggaWdub3JlIG5leHQgKi9cbmNvbnN0IHdyaXRlVmFyU3RyaW5nID0gKHV0ZjhUZXh0RW5jb2RlciAmJiAvKiogQHR5cGUge2FueX0gKi8gKHV0ZjhUZXh0RW5jb2RlcikuZW5jb2RlSW50bykgPyBfd3JpdGVWYXJTdHJpbmdOYXRpdmUgOiBfd3JpdGVWYXJTdHJpbmdQb2x5ZmlsbDtcblxuLyoqXG4gKiBBcHBlbmQgZml4ZWQtbGVuZ3RoIFVpbnQ4QXJyYXkgdG8gdGhlIGVuY29kZXIuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gdWludDhBcnJheVxuICovXG5jb25zdCB3cml0ZVVpbnQ4QXJyYXkgPSAoZW5jb2RlciwgdWludDhBcnJheSkgPT4ge1xuICBjb25zdCBidWZmZXJMZW4gPSBlbmNvZGVyLmNidWYubGVuZ3RoO1xuICBjb25zdCBjcG9zID0gZW5jb2Rlci5jcG9zO1xuICBjb25zdCBsZWZ0Q29weUxlbiA9IG1pbihidWZmZXJMZW4gLSBjcG9zLCB1aW50OEFycmF5Lmxlbmd0aCk7XG4gIGNvbnN0IHJpZ2h0Q29weUxlbiA9IHVpbnQ4QXJyYXkubGVuZ3RoIC0gbGVmdENvcHlMZW47XG4gIGVuY29kZXIuY2J1Zi5zZXQodWludDhBcnJheS5zdWJhcnJheSgwLCBsZWZ0Q29weUxlbiksIGNwb3MpO1xuICBlbmNvZGVyLmNwb3MgKz0gbGVmdENvcHlMZW47XG4gIGlmIChyaWdodENvcHlMZW4gPiAwKSB7XG4gICAgLy8gU3RpbGwgc29tZXRoaW5nIHRvIHdyaXRlLCB3cml0ZSByaWdodCBoYWxmLi5cbiAgICAvLyBBcHBlbmQgbmV3IGJ1ZmZlclxuICAgIGVuY29kZXIuYnVmcy5wdXNoKGVuY29kZXIuY2J1Zik7XG4gICAgLy8gbXVzdCBoYXZlIGF0IGxlYXN0IHNpemUgb2YgcmVtYWluaW5nIGJ1ZmZlclxuICAgIGVuY29kZXIuY2J1ZiA9IG5ldyBVaW50OEFycmF5KG1heChidWZmZXJMZW4gKiAyLCByaWdodENvcHlMZW4pKTtcbiAgICAvLyBjb3B5IGFycmF5XG4gICAgZW5jb2Rlci5jYnVmLnNldCh1aW50OEFycmF5LnN1YmFycmF5KGxlZnRDb3B5TGVuKSk7XG4gICAgZW5jb2Rlci5jcG9zID0gcmlnaHRDb3B5TGVuO1xuICB9XG59O1xuXG4vKipcbiAqIEFwcGVuZCBhbiBVaW50OEFycmF5IHRvIEVuY29kZXIuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gdWludDhBcnJheVxuICovXG5jb25zdCB3cml0ZVZhclVpbnQ4QXJyYXkgPSAoZW5jb2RlciwgdWludDhBcnJheSkgPT4ge1xuICB3cml0ZVZhclVpbnQoZW5jb2RlciwgdWludDhBcnJheS5ieXRlTGVuZ3RoKTtcbiAgd3JpdGVVaW50OEFycmF5KGVuY29kZXIsIHVpbnQ4QXJyYXkpO1xufTtcblxuLyoqXG4gKiBFcnJvciBoZWxwZXJzLlxuICpcbiAqIEBtb2R1bGUgZXJyb3JcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzXG4gKiBAcmV0dXJuIHtFcnJvcn1cbiAqL1xuLyogYzggaWdub3JlIG5leHQgKi9cbmNvbnN0IGNyZWF0ZSA9IHMgPT4gbmV3IEVycm9yKHMpO1xuXG4vKipcbiAqIEVmZmljaWVudCBzY2hlbWEtbGVzcyBiaW5hcnkgZGVjb2Rpbmcgd2l0aCBzdXBwb3J0IGZvciB2YXJpYWJsZSBsZW5ndGggZW5jb2RpbmcuXG4gKlxuICogVXNlIFtsaWIwL2RlY29kaW5nXSB3aXRoIFtsaWIwL2VuY29kaW5nXS4gRXZlcnkgZW5jb2RpbmcgZnVuY3Rpb24gaGFzIGEgY29ycmVzcG9uZGluZyBkZWNvZGluZyBmdW5jdGlvbi5cbiAqXG4gKiBFbmNvZGVzIG51bWJlcnMgaW4gbGl0dGxlLWVuZGlhbiBvcmRlciAobGVhc3QgdG8gbW9zdCBzaWduaWZpY2FudCBieXRlIG9yZGVyKVxuICogYW5kIGlzIGNvbXBhdGlibGUgd2l0aCBHb2xhbmcncyBiaW5hcnkgZW5jb2RpbmcgKGh0dHBzOi8vZ29sYW5nLm9yZy9wa2cvZW5jb2RpbmcvYmluYXJ5LylcbiAqIHdoaWNoIGlzIGFsc28gdXNlZCBpbiBQcm90b2NvbCBCdWZmZXJzLlxuICpcbiAqIGBgYGpzXG4gKiAvLyBlbmNvZGluZyBzdGVwXG4gKiBjb25zdCBlbmNvZGVyID0gZW5jb2RpbmcuY3JlYXRlRW5jb2RlcigpXG4gKiBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgMjU2KVxuICogZW5jb2Rpbmcud3JpdGVWYXJTdHJpbmcoZW5jb2RlciwgJ0hlbGxvIHdvcmxkIScpXG4gKiBjb25zdCBidWYgPSBlbmNvZGluZy50b1VpbnQ4QXJyYXkoZW5jb2RlcilcbiAqIGBgYFxuICpcbiAqIGBgYGpzXG4gKiAvLyBkZWNvZGluZyBzdGVwXG4gKiBjb25zdCBkZWNvZGVyID0gZGVjb2RpbmcuY3JlYXRlRGVjb2RlcihidWYpXG4gKiBkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyKSAvLyA9PiAyNTZcbiAqIGRlY29kaW5nLnJlYWRWYXJTdHJpbmcoZGVjb2RlcikgLy8gPT4gJ0hlbGxvIHdvcmxkISdcbiAqIGRlY29kaW5nLmhhc0NvbnRlbnQoZGVjb2RlcikgLy8gPT4gZmFsc2UgLSBhbGwgZGF0YSBpcyByZWFkXG4gKiBgYGBcbiAqXG4gKiBAbW9kdWxlIGRlY29kaW5nXG4gKi9cblxuXG5jb25zdCBlcnJvclVuZXhwZWN0ZWRFbmRPZkFycmF5ID0gY3JlYXRlKCdVbmV4cGVjdGVkIGVuZCBvZiBhcnJheScpO1xuY29uc3QgZXJyb3JJbnRlZ2VyT3V0T2ZSYW5nZSA9IGNyZWF0ZSgnSW50ZWdlciBvdXQgb2YgUmFuZ2UnKTtcblxuLyoqXG4gKiBDcmVhdGUgYW4gVWludDhBcnJheSB2aWV3IG9mIHRoZSBuZXh0IGBsZW5gIGJ5dGVzIGFuZCBhZHZhbmNlIHRoZSBwb3NpdGlvbiBieSBgbGVuYC5cbiAqXG4gKiBJbXBvcnRhbnQ6IFRoZSBVaW50OEFycmF5IHN0aWxsIHBvaW50cyB0byB0aGUgdW5kZXJseWluZyBBcnJheUJ1ZmZlci4gTWFrZSBzdXJlIHRvIGRpc2NhcmQgdGhlIHJlc3VsdCBhcyBzb29uIGFzIHBvc3NpYmxlIHRvIHByZXZlbnQgYW55IG1lbW9yeSBsZWFrcy5cbiAqICAgICAgICAgICAgVXNlIGBidWZmZXIuY29weVVpbnQ4QXJyYXlgIHRvIGNvcHkgdGhlIHJlc3VsdCBpbnRvIGEgbmV3IFVpbnQ4QXJyYXkuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXIgVGhlIGRlY29kZXIgaW5zdGFuY2VcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW4gVGhlIGxlbmd0aCBvZiBieXRlcyB0byByZWFkXG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICovXG5jb25zdCByZWFkVWludDhBcnJheSA9IChkZWNvZGVyLCBsZW4pID0+IHtcbiAgY29uc3QgdmlldyA9IG5ldyBVaW50OEFycmF5KGRlY29kZXIuYXJyLmJ1ZmZlciwgZGVjb2Rlci5wb3MgKyBkZWNvZGVyLmFyci5ieXRlT2Zmc2V0LCBsZW4pO1xuICBkZWNvZGVyLnBvcyArPSBsZW47XG4gIHJldHVybiB2aWV3XG59O1xuXG4vKipcbiAqIFJlYWQgdmFyaWFibGUgbGVuZ3RoIFVpbnQ4QXJyYXkuXG4gKlxuICogSW1wb3J0YW50OiBUaGUgVWludDhBcnJheSBzdGlsbCBwb2ludHMgdG8gdGhlIHVuZGVybHlpbmcgQXJyYXlCdWZmZXIuIE1ha2Ugc3VyZSB0byBkaXNjYXJkIHRoZSByZXN1bHQgYXMgc29vbiBhcyBwb3NzaWJsZSB0byBwcmV2ZW50IGFueSBtZW1vcnkgbGVha3MuXG4gKiAgICAgICAgICAgIFVzZSBgYnVmZmVyLmNvcHlVaW50OEFycmF5YCB0byBjb3B5IHRoZSByZXN1bHQgaW50byBhIG5ldyBVaW50OEFycmF5LlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtEZWNvZGVyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICovXG5jb25zdCByZWFkVmFyVWludDhBcnJheSA9IGRlY29kZXIgPT4gcmVhZFVpbnQ4QXJyYXkoZGVjb2RlciwgcmVhZFZhclVpbnQoZGVjb2RlcikpO1xuXG4vKipcbiAqIFJlYWQgb25lIGJ5dGUgYXMgdW5zaWduZWQgaW50ZWdlci5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtEZWNvZGVyfSBkZWNvZGVyIFRoZSBkZWNvZGVyIGluc3RhbmNlXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFVuc2lnbmVkIDgtYml0IGludGVnZXJcbiAqL1xuY29uc3QgcmVhZFVpbnQ4ID0gZGVjb2RlciA9PiBkZWNvZGVyLmFycltkZWNvZGVyLnBvcysrXTtcblxuLyoqXG4gKiBSZWFkIHVuc2lnbmVkIGludGVnZXIgKDMyYml0KSB3aXRoIHZhcmlhYmxlIGxlbmd0aC5cbiAqIDEvOHRoIG9mIHRoZSBzdG9yYWdlIGlzIHVzZWQgYXMgZW5jb2Rpbmcgb3ZlcmhlYWQuXG4gKiAgKiBudW1iZXJzIDwgMl43IGlzIHN0b3JlZCBpbiBvbmUgYnl0bGVuZ3RoXG4gKiAgKiBudW1iZXJzIDwgMl4xNCBpcyBzdG9yZWQgaW4gdHdvIGJ5bGVuZ3RoXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge251bWJlcn0gQW4gdW5zaWduZWQgaW50ZWdlci5sZW5ndGhcbiAqL1xuY29uc3QgcmVhZFZhclVpbnQgPSBkZWNvZGVyID0+IHtcbiAgbGV0IG51bSA9IDA7XG4gIGxldCBtdWx0ID0gMTtcbiAgY29uc3QgbGVuID0gZGVjb2Rlci5hcnIubGVuZ3RoO1xuICB3aGlsZSAoZGVjb2Rlci5wb3MgPCBsZW4pIHtcbiAgICBjb25zdCByID0gZGVjb2Rlci5hcnJbZGVjb2Rlci5wb3MrK107XG4gICAgLy8gbnVtID0gbnVtIHwgKChyICYgYmluYXJ5LkJJVFM3KSA8PCBsZW4pXG4gICAgbnVtID0gbnVtICsgKHIgJiBCSVRTNykgKiBtdWx0OyAvLyBzaGlmdCAkciA8PCAoNyojaXRlcmF0aW9ucykgYW5kIGFkZCBpdCB0byBudW1cbiAgICBtdWx0ICo9IDEyODsgLy8gbmV4dCBpdGVyYXRpb24sIHNoaWZ0IDcgXCJtb3JlXCIgdG8gdGhlIGxlZnRcbiAgICBpZiAociA8IEJJVDgpIHtcbiAgICAgIHJldHVybiBudW1cbiAgICB9XG4gICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgaWYgKG51bSA+IE1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICAgIHRocm93IGVycm9ySW50ZWdlck91dE9mUmFuZ2VcbiAgICB9XG4gICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgfVxuICB0aHJvdyBlcnJvclVuZXhwZWN0ZWRFbmRPZkFycmF5XG59O1xuXG4vKipcbiAqIFdlIGRvbid0IHRlc3QgdGhpcyBmdW5jdGlvbiBhbnltb3JlIGFzIHdlIHVzZSBuYXRpdmUgZGVjb2RpbmcvZW5jb2RpbmcgYnkgZGVmYXVsdCBub3cuXG4gKiBCZXR0ZXIgbm90IG1vZGlmeSB0aGlzIGFueW1vcmUuLlxuICpcbiAqIFRyYW5zZm9ybWluZyB1dGY4IHRvIGEgc3RyaW5nIGlzIHByZXR0eSBleHBlbnNpdmUuIFRoZSBjb2RlIHBlcmZvcm1zIDEweCBiZXR0ZXJcbiAqIHdoZW4gU3RyaW5nLmZyb21Db2RlUG9pbnQgaXMgZmVkIHdpdGggYWxsIGNoYXJhY3RlcnMgYXMgYXJndW1lbnRzLlxuICogQnV0IG1vc3QgZW52aXJvbm1lbnRzIGhhdmUgYSBtYXhpbXVtIG51bWJlciBvZiBhcmd1bWVudHMgcGVyIGZ1bmN0aW9ucy5cbiAqIEZvciBlZmZpZW5jeSByZWFzb25zIHdlIGFwcGx5IGEgbWF4aW11bSBvZiAxMDAwMCBjaGFyYWN0ZXJzIGF0IG9uY2UuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge1N0cmluZ30gVGhlIHJlYWQgU3RyaW5nLlxuICovXG4vKiBjOCBpZ25vcmUgc3RhcnQgKi9cbmNvbnN0IF9yZWFkVmFyU3RyaW5nUG9seWZpbGwgPSBkZWNvZGVyID0+IHtcbiAgbGV0IHJlbWFpbmluZ0xlbiA9IHJlYWRWYXJVaW50KGRlY29kZXIpO1xuICBpZiAocmVtYWluaW5nTGVuID09PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH0gZWxzZSB7XG4gICAgbGV0IGVuY29kZWRTdHJpbmcgPSBTdHJpbmcuZnJvbUNvZGVQb2ludChyZWFkVWludDgoZGVjb2RlcikpOyAvLyByZW1lbWJlciB0byBkZWNyZWFzZSByZW1haW5pbmdMZW5cbiAgICBpZiAoLS1yZW1haW5pbmdMZW4gPCAxMDApIHsgLy8gZG8gbm90IGNyZWF0ZSBhIFVpbnQ4QXJyYXkgZm9yIHNtYWxsIHN0cmluZ3NcbiAgICAgIHdoaWxlIChyZW1haW5pbmdMZW4tLSkge1xuICAgICAgICBlbmNvZGVkU3RyaW5nICs9IFN0cmluZy5mcm9tQ29kZVBvaW50KHJlYWRVaW50OChkZWNvZGVyKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHdoaWxlIChyZW1haW5pbmdMZW4gPiAwKSB7XG4gICAgICAgIGNvbnN0IG5leHRMZW4gPSByZW1haW5pbmdMZW4gPCAxMDAwMCA/IHJlbWFpbmluZ0xlbiA6IDEwMDAwO1xuICAgICAgICAvLyB0aGlzIGlzIGRhbmdlcm91cywgd2UgY3JlYXRlIGEgZnJlc2ggYXJyYXkgdmlldyBmcm9tIHRoZSBleGlzdGluZyBidWZmZXJcbiAgICAgICAgY29uc3QgYnl0ZXMgPSBkZWNvZGVyLmFyci5zdWJhcnJheShkZWNvZGVyLnBvcywgZGVjb2Rlci5wb3MgKyBuZXh0TGVuKTtcbiAgICAgICAgZGVjb2Rlci5wb3MgKz0gbmV4dExlbjtcbiAgICAgICAgLy8gU3RhcnRpbmcgd2l0aCBFUzUuMSB3ZSBjYW4gc3VwcGx5IGEgZ2VuZXJpYyBhcnJheS1saWtlIG9iamVjdCBhcyBhcmd1bWVudHNcbiAgICAgICAgZW5jb2RlZFN0cmluZyArPSBTdHJpbmcuZnJvbUNvZGVQb2ludC5hcHBseShudWxsLCAvKiogQHR5cGUge2FueX0gKi8gKGJ5dGVzKSk7XG4gICAgICAgIHJlbWFpbmluZ0xlbiAtPSBuZXh0TGVuO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGVzY2FwZShlbmNvZGVkU3RyaW5nKSlcbiAgfVxufTtcbi8qIGM4IGlnbm9yZSBzdG9wICovXG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge1N0cmluZ30gVGhlIHJlYWQgU3RyaW5nXG4gKi9cbmNvbnN0IF9yZWFkVmFyU3RyaW5nTmF0aXZlID0gZGVjb2RlciA9PlxuICAvKiogQHR5cGUgYW55ICovICh1dGY4VGV4dERlY29kZXIpLmRlY29kZShyZWFkVmFyVWludDhBcnJheShkZWNvZGVyKSk7XG5cbi8qKlxuICogUmVhZCBzdHJpbmcgb2YgdmFyaWFibGUgbGVuZ3RoXG4gKiAqIHZhclVpbnQgaXMgdXNlZCB0byBzdG9yZSB0aGUgbGVuZ3RoIG9mIHRoZSBzdHJpbmdcbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlclxuICogQHJldHVybiB7U3RyaW5nfSBUaGUgcmVhZCBTdHJpbmdcbiAqXG4gKi9cbi8qIGM4IGlnbm9yZSBuZXh0ICovXG5jb25zdCByZWFkVmFyU3RyaW5nID0gdXRmOFRleHREZWNvZGVyID8gX3JlYWRWYXJTdHJpbmdOYXRpdmUgOiBfcmVhZFZhclN0cmluZ1BvbHlmaWxsO1xuXG52YXIgQXV0aE1lc3NhZ2VUeXBlO1xuKGZ1bmN0aW9uIChBdXRoTWVzc2FnZVR5cGUpIHtcbiAgICBBdXRoTWVzc2FnZVR5cGVbQXV0aE1lc3NhZ2VUeXBlW1wiVG9rZW5cIl0gPSAwXSA9IFwiVG9rZW5cIjtcbiAgICBBdXRoTWVzc2FnZVR5cGVbQXV0aE1lc3NhZ2VUeXBlW1wiUGVybWlzc2lvbkRlbmllZFwiXSA9IDFdID0gXCJQZXJtaXNzaW9uRGVuaWVkXCI7XG4gICAgQXV0aE1lc3NhZ2VUeXBlW0F1dGhNZXNzYWdlVHlwZVtcIkF1dGhlbnRpY2F0ZWRcIl0gPSAyXSA9IFwiQXV0aGVudGljYXRlZFwiO1xufSkoQXV0aE1lc3NhZ2VUeXBlIHx8IChBdXRoTWVzc2FnZVR5cGUgPSB7fSkpO1xuY29uc3Qgd3JpdGVBdXRoZW50aWNhdGlvbiA9IChlbmNvZGVyLCBhdXRoKSA9PiB7XG4gICAgd3JpdGVWYXJVaW50KGVuY29kZXIsIEF1dGhNZXNzYWdlVHlwZS5Ub2tlbik7XG4gICAgd3JpdGVWYXJTdHJpbmcoZW5jb2RlciwgYXV0aCk7XG59O1xuY29uc3Qgd3JpdGVQZXJtaXNzaW9uRGVuaWVkID0gKGVuY29kZXIsIHJlYXNvbikgPT4ge1xuICAgIHdyaXRlVmFyVWludChlbmNvZGVyLCBBdXRoTWVzc2FnZVR5cGUuUGVybWlzc2lvbkRlbmllZCk7XG4gICAgd3JpdGVWYXJTdHJpbmcoZW5jb2RlciwgcmVhc29uKTtcbn07XG5jb25zdCB3cml0ZUF1dGhlbnRpY2F0ZWQgPSAoZW5jb2Rlciwgc2NvcGUpID0+IHtcbiAgICB3cml0ZVZhclVpbnQoZW5jb2RlciwgQXV0aE1lc3NhZ2VUeXBlLkF1dGhlbnRpY2F0ZWQpO1xuICAgIHdyaXRlVmFyU3RyaW5nKGVuY29kZXIsIHNjb3BlKTtcbn07XG5jb25zdCByZWFkQXV0aE1lc3NhZ2UgPSAoZGVjb2RlciwgcGVybWlzc2lvbkRlbmllZEhhbmRsZXIsIGF1dGhlbnRpY2F0ZWRIYW5kbGVyKSA9PiB7XG4gICAgc3dpdGNoIChyZWFkVmFyVWludChkZWNvZGVyKSkge1xuICAgICAgICBjYXNlIEF1dGhNZXNzYWdlVHlwZS5QZXJtaXNzaW9uRGVuaWVkOiB7XG4gICAgICAgICAgICBwZXJtaXNzaW9uRGVuaWVkSGFuZGxlcihyZWFkVmFyU3RyaW5nKGRlY29kZXIpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgQXV0aE1lc3NhZ2VUeXBlLkF1dGhlbnRpY2F0ZWQ6IHtcbiAgICAgICAgICAgIGF1dGhlbnRpY2F0ZWRIYW5kbGVyKHJlYWRWYXJTdHJpbmcoZGVjb2RlcikpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIFRoZSBzZXJ2ZXIgaXMgdGVybWluYXRpbmcgdGhlIGNvbm5lY3Rpb24gYmVjYXVzZSBhIGRhdGEgZnJhbWUgd2FzIHJlY2VpdmVkXG4gKiB0aGF0IGlzIHRvbyBsYXJnZS5cbiAqIFNlZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0Nsb3NlRXZlbnQvY29kZVxuICovXG5jb25zdCBNZXNzYWdlVG9vQmlnID0ge1xuICAgIGNvZGU6IDEwMDksXG4gICAgcmVhc29uOiAnTWVzc2FnZSBUb28gQmlnJyxcbn07XG4vKipcbiAqIFRoZSBzZXJ2ZXIgc3VjY2Vzc2Z1bGx5IHByb2Nlc3NlZCB0aGUgcmVxdWVzdCwgYXNrcyB0aGF0IHRoZSByZXF1ZXN0ZXIgcmVzZXRcbiAqIGl0cyBkb2N1bWVudCB2aWV3LCBhbmQgaXMgbm90IHJldHVybmluZyBhbnkgY29udGVudC5cbiAqL1xuY29uc3QgUmVzZXRDb25uZWN0aW9uID0ge1xuICAgIGNvZGU6IDQyMDUsXG4gICAgcmVhc29uOiAnUmVzZXQgQ29ubmVjdGlvbicsXG59O1xuLyoqXG4gKiBTaW1pbGFyIHRvIEZvcmJpZGRlbiwgYnV0IHNwZWNpZmljYWxseSBmb3IgdXNlIHdoZW4gYXV0aGVudGljYXRpb24gaXMgcmVxdWlyZWQgYW5kIGhhc1xuICogZmFpbGVkIG9yIGhhcyBub3QgeWV0IGJlZW4gcHJvdmlkZWQuXG4gKi9cbmNvbnN0IFVuYXV0aG9yaXplZCA9IHtcbiAgICBjb2RlOiA0NDAxLFxuICAgIHJlYXNvbjogJ1VuYXV0aG9yaXplZCcsXG59O1xuLyoqXG4gKiBUaGUgcmVxdWVzdCBjb250YWluZWQgdmFsaWQgZGF0YSBhbmQgd2FzIHVuZGVyc3Rvb2QgYnkgdGhlIHNlcnZlciwgYnV0IHRoZSBzZXJ2ZXJcbiAqIGlzIHJlZnVzaW5nIGFjdGlvbi5cbiAqL1xuY29uc3QgRm9yYmlkZGVuID0ge1xuICAgIGNvZGU6IDQ0MDMsXG4gICAgcmVhc29uOiAnRm9yYmlkZGVuJyxcbn07XG4vKipcbiAqIFRoZSBzZXJ2ZXIgdGltZWQgb3V0IHdhaXRpbmcgZm9yIHRoZSByZXF1ZXN0LlxuICovXG5jb25zdCBDb25uZWN0aW9uVGltZW91dCA9IHtcbiAgICBjb2RlOiA0NDA4LFxuICAgIHJlYXNvbjogJ0Nvbm5lY3Rpb24gVGltZW91dCcsXG59O1xuXG5jb25zdCBhd2FyZW5lc3NTdGF0ZXNUb0FycmF5ID0gKHN0YXRlcykgPT4ge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHN0YXRlcy5lbnRyaWVzKCkpLm1hcCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjbGllbnRJZDoga2V5LFxuICAgICAgICAgICAgLi4udmFsdWUsXG4gICAgICAgIH07XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIFN0YXRlIG9mIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbi5cbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RlL2RvY3MvV2ViL0FQSS9XZWJTb2NrZXQvcmVhZHlTdGF0ZVxuICovXG52YXIgV3NSZWFkeVN0YXRlcztcbihmdW5jdGlvbiAoV3NSZWFkeVN0YXRlcykge1xuICAgIFdzUmVhZHlTdGF0ZXNbV3NSZWFkeVN0YXRlc1tcIkNvbm5lY3RpbmdcIl0gPSAwXSA9IFwiQ29ubmVjdGluZ1wiO1xuICAgIFdzUmVhZHlTdGF0ZXNbV3NSZWFkeVN0YXRlc1tcIk9wZW5cIl0gPSAxXSA9IFwiT3BlblwiO1xuICAgIFdzUmVhZHlTdGF0ZXNbV3NSZWFkeVN0YXRlc1tcIkNsb3NpbmdcIl0gPSAyXSA9IFwiQ2xvc2luZ1wiO1xuICAgIFdzUmVhZHlTdGF0ZXNbV3NSZWFkeVN0YXRlc1tcIkNsb3NlZFwiXSA9IDNdID0gXCJDbG9zZWRcIjtcbn0pKFdzUmVhZHlTdGF0ZXMgfHwgKFdzUmVhZHlTdGF0ZXMgPSB7fSkpO1xuXG5leHBvcnQgeyBDb25uZWN0aW9uVGltZW91dCwgRm9yYmlkZGVuLCBNZXNzYWdlVG9vQmlnLCBSZXNldENvbm5lY3Rpb24sIFVuYXV0aG9yaXplZCwgV3NSZWFkeVN0YXRlcywgYXdhcmVuZXNzU3RhdGVzVG9BcnJheSwgcmVhZEF1dGhNZXNzYWdlLCB3cml0ZUF1dGhlbnRpY2F0ZWQsIHdyaXRlQXV0aGVudGljYXRpb24sIHdyaXRlUGVybWlzc2lvbkRlbmllZCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aG9jdXNwb2N1cy1jb21tb24uZXNtLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@hocuspocus/common/dist/hocuspocus-common.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@hocuspocus/provider/dist/hocuspocus-provider.esm.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@hocuspocus/provider/dist/hocuspocus-provider.esm.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AwarenessError: () => (/* binding */ AwarenessError),\n/* harmony export */   HocuspocusProvider: () => (/* binding */ HocuspocusProvider),\n/* harmony export */   HocuspocusProviderWebsocket: () => (/* binding */ HocuspocusProviderWebsocket),\n/* harmony export */   MessageType: () => (/* binding */ MessageType),\n/* harmony export */   WebSocketStatus: () => (/* binding */ WebSocketStatus)\n/* harmony export */ });\n/* harmony import */ var _hocuspocus_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hocuspocus/common */ \"(ssr)/./node_modules/@hocuspocus/common/dist/hocuspocus-common.esm.js\");\n/* harmony import */ var yjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! yjs */ \"(ssr)/./node_modules/yjs/dist/yjs.mjs\");\n/* harmony import */ var _lifeomic_attempt__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lifeomic/attempt */ \"(ssr)/./node_modules/@lifeomic/attempt/dist/es6/src/index.js\");\n\n\n\n\n/**\n * Common Math expressions.\n *\n * @module math\n */\n\nconst floor = Math.floor;\n\n/**\n * @function\n * @param {number} a\n * @param {number} b\n * @return {number} The smaller element of a and b\n */\nconst min = (a, b) => a < b ? a : b;\n\n/**\n * @function\n * @param {number} a\n * @param {number} b\n * @return {number} The bigger element of a and b\n */\nconst max = (a, b) => a > b ? a : b;\n\n/* eslint-env browser */\n\nconst BIT7 = 64;\nconst BIT8 = 128;\nconst BITS6 = 63;\nconst BITS7 = 127;\n\n/**\n * Utility helpers for working with numbers.\n *\n * @module number\n */\n\n\nconst MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER;\n\n/**\n * Utility module to work with sets.\n *\n * @module set\n */\n\nconst create$2 = () => new Set();\n\n/**\n * Utility module to work with Arrays.\n *\n * @module array\n */\n\n\n/**\n * Transforms something array-like to an actual Array.\n *\n * @function\n * @template T\n * @param {ArrayLike<T>|Iterable<T>} arraylike\n * @return {T}\n */\nconst from = Array.from;\n\n/**\n * @param {string} str\n * @return {Uint8Array}\n */\nconst _encodeUtf8Polyfill = str => {\n  const encodedString = unescape(encodeURIComponent(str));\n  const len = encodedString.length;\n  const buf = new Uint8Array(len);\n  for (let i = 0; i < len; i++) {\n    buf[i] = /** @type {number} */ (encodedString.codePointAt(i));\n  }\n  return buf\n};\n\n/* c8 ignore next */\nconst utf8TextEncoder = /** @type {TextEncoder} */ (typeof TextEncoder !== 'undefined' ? new TextEncoder() : null);\n\n/**\n * @param {string} str\n * @return {Uint8Array}\n */\nconst _encodeUtf8Native = str => utf8TextEncoder.encode(str);\n\n/**\n * @param {string} str\n * @return {Uint8Array}\n */\n/* c8 ignore next */\nconst encodeUtf8 = utf8TextEncoder ? _encodeUtf8Native : _encodeUtf8Polyfill;\n\n/* c8 ignore next */\nlet utf8TextDecoder = typeof TextDecoder === 'undefined' ? null : new TextDecoder('utf-8', { fatal: true, ignoreBOM: true });\n\n/* c8 ignore start */\nif (utf8TextDecoder && utf8TextDecoder.decode(new Uint8Array()).length === 1) {\n  // Safari doesn't handle BOM correctly.\n  // This fixes a bug in Safari 13.0.5 where it produces a BOM the first time it is called.\n  // utf8TextDecoder.decode(new Uint8Array()).length === 1 on the first call and\n  // utf8TextDecoder.decode(new Uint8Array()).length === 1 on the second call\n  // Another issue is that from then on no BOM chars are recognized anymore\n  /* c8 ignore next */\n  utf8TextDecoder = null;\n}\n\n/**\n * Efficient schema-less binary encoding with support for variable length encoding.\n *\n * Use [lib0/encoding] with [lib0/decoding]. Every encoding function has a corresponding decoding function.\n *\n * Encodes numbers in little-endian order (least to most significant byte order)\n * and is compatible with Golang's binary encoding (https://golang.org/pkg/encoding/binary/)\n * which is also used in Protocol Buffers.\n *\n * ```js\n * // encoding step\n * const encoder = encoding.createEncoder()\n * encoding.writeVarUint(encoder, 256)\n * encoding.writeVarString(encoder, 'Hello world!')\n * const buf = encoding.toUint8Array(encoder)\n * ```\n *\n * ```js\n * // decoding step\n * const decoder = decoding.createDecoder(buf)\n * decoding.readVarUint(decoder) // => 256\n * decoding.readVarString(decoder) // => 'Hello world!'\n * decoding.hasContent(decoder) // => false - all data is read\n * ```\n *\n * @module encoding\n */\n\n\n/**\n * A BinaryEncoder handles the encoding to an Uint8Array.\n */\nclass Encoder {\n  constructor () {\n    this.cpos = 0;\n    this.cbuf = new Uint8Array(100);\n    /**\n     * @type {Array<Uint8Array>}\n     */\n    this.bufs = [];\n  }\n}\n\n/**\n * @function\n * @return {Encoder}\n */\nconst createEncoder = () => new Encoder();\n\n/**\n * The current length of the encoded data.\n *\n * @function\n * @param {Encoder} encoder\n * @return {number}\n */\nconst length$1 = encoder => {\n  let len = encoder.cpos;\n  for (let i = 0; i < encoder.bufs.length; i++) {\n    len += encoder.bufs[i].length;\n  }\n  return len\n};\n\n/**\n * Transform to Uint8Array.\n *\n * @function\n * @param {Encoder} encoder\n * @return {Uint8Array} The created ArrayBuffer.\n */\nconst toUint8Array = encoder => {\n  const uint8arr = new Uint8Array(length$1(encoder));\n  let curPos = 0;\n  for (let i = 0; i < encoder.bufs.length; i++) {\n    const d = encoder.bufs[i];\n    uint8arr.set(d, curPos);\n    curPos += d.length;\n  }\n  uint8arr.set(new Uint8Array(encoder.cbuf.buffer, 0, encoder.cpos), curPos);\n  return uint8arr\n};\n\n/**\n * Write one byte to the encoder.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The byte that is to be encoded.\n */\nconst write = (encoder, num) => {\n  const bufferLen = encoder.cbuf.length;\n  if (encoder.cpos === bufferLen) {\n    encoder.bufs.push(encoder.cbuf);\n    encoder.cbuf = new Uint8Array(bufferLen * 2);\n    encoder.cpos = 0;\n  }\n  encoder.cbuf[encoder.cpos++] = num;\n};\n\n/**\n * Write a variable length unsigned integer. Max encodable integer is 2^53.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nconst writeVarUint = (encoder, num) => {\n  while (num > BITS7) {\n    write(encoder, BIT8 | (BITS7 & num));\n    num = floor(num / 128); // shift >>> 7\n  }\n  write(encoder, BITS7 & num);\n};\n\n/**\n * A cache to store strings temporarily\n */\nconst _strBuffer = new Uint8Array(30000);\nconst _maxStrBSize = _strBuffer.length / 3;\n\n/**\n * Write a variable length string.\n *\n * @function\n * @param {Encoder} encoder\n * @param {String} str The string that is to be encoded.\n */\nconst _writeVarStringNative = (encoder, str) => {\n  if (str.length < _maxStrBSize) {\n    // We can encode the string into the existing buffer\n    /* c8 ignore next */\n    const written = utf8TextEncoder.encodeInto(str, _strBuffer).written || 0;\n    writeVarUint(encoder, written);\n    for (let i = 0; i < written; i++) {\n      write(encoder, _strBuffer[i]);\n    }\n  } else {\n    writeVarUint8Array(encoder, encodeUtf8(str));\n  }\n};\n\n/**\n * Write a variable length string.\n *\n * @function\n * @param {Encoder} encoder\n * @param {String} str The string that is to be encoded.\n */\nconst _writeVarStringPolyfill = (encoder, str) => {\n  const encodedString = unescape(encodeURIComponent(str));\n  const len = encodedString.length;\n  writeVarUint(encoder, len);\n  for (let i = 0; i < len; i++) {\n    write(encoder, /** @type {number} */ (encodedString.codePointAt(i)));\n  }\n};\n\n/**\n * Write a variable length string.\n *\n * @function\n * @param {Encoder} encoder\n * @param {String} str The string that is to be encoded.\n */\n/* c8 ignore next */\nconst writeVarString = (utf8TextEncoder && /** @type {any} */ (utf8TextEncoder).encodeInto) ? _writeVarStringNative : _writeVarStringPolyfill;\n\n/**\n * Append fixed-length Uint8Array to the encoder.\n *\n * @function\n * @param {Encoder} encoder\n * @param {Uint8Array} uint8Array\n */\nconst writeUint8Array = (encoder, uint8Array) => {\n  const bufferLen = encoder.cbuf.length;\n  const cpos = encoder.cpos;\n  const leftCopyLen = min(bufferLen - cpos, uint8Array.length);\n  const rightCopyLen = uint8Array.length - leftCopyLen;\n  encoder.cbuf.set(uint8Array.subarray(0, leftCopyLen), cpos);\n  encoder.cpos += leftCopyLen;\n  if (rightCopyLen > 0) {\n    // Still something to write, write right half..\n    // Append new buffer\n    encoder.bufs.push(encoder.cbuf);\n    // must have at least size of remaining buffer\n    encoder.cbuf = new Uint8Array(max(bufferLen * 2, rightCopyLen));\n    // copy array\n    encoder.cbuf.set(uint8Array.subarray(leftCopyLen));\n    encoder.cpos = rightCopyLen;\n  }\n};\n\n/**\n * Append an Uint8Array to Encoder.\n *\n * @function\n * @param {Encoder} encoder\n * @param {Uint8Array} uint8Array\n */\nconst writeVarUint8Array = (encoder, uint8Array) => {\n  writeVarUint(encoder, uint8Array.byteLength);\n  writeUint8Array(encoder, uint8Array);\n};\n\n/**\n * Error helpers.\n *\n * @module error\n */\n\n/**\n * @param {string} s\n * @return {Error}\n */\n/* c8 ignore next */\nconst create$1 = s => new Error(s);\n\n/**\n * Efficient schema-less binary decoding with support for variable length encoding.\n *\n * Use [lib0/decoding] with [lib0/encoding]. Every encoding function has a corresponding decoding function.\n *\n * Encodes numbers in little-endian order (least to most significant byte order)\n * and is compatible with Golang's binary encoding (https://golang.org/pkg/encoding/binary/)\n * which is also used in Protocol Buffers.\n *\n * ```js\n * // encoding step\n * const encoder = encoding.createEncoder()\n * encoding.writeVarUint(encoder, 256)\n * encoding.writeVarString(encoder, 'Hello world!')\n * const buf = encoding.toUint8Array(encoder)\n * ```\n *\n * ```js\n * // decoding step\n * const decoder = decoding.createDecoder(buf)\n * decoding.readVarUint(decoder) // => 256\n * decoding.readVarString(decoder) // => 'Hello world!'\n * decoding.hasContent(decoder) // => false - all data is read\n * ```\n *\n * @module decoding\n */\n\n\nconst errorUnexpectedEndOfArray = create$1('Unexpected end of array');\nconst errorIntegerOutOfRange = create$1('Integer out of Range');\n\n/**\n * A Decoder handles the decoding of an Uint8Array.\n */\nclass Decoder {\n  /**\n   * @param {Uint8Array} uint8Array Binary data to decode\n   */\n  constructor (uint8Array) {\n    /**\n     * Decoding target.\n     *\n     * @type {Uint8Array}\n     */\n    this.arr = uint8Array;\n    /**\n     * Current decoding position.\n     *\n     * @type {number}\n     */\n    this.pos = 0;\n  }\n}\n\n/**\n * @function\n * @param {Uint8Array} uint8Array\n * @return {Decoder}\n */\nconst createDecoder = uint8Array => new Decoder(uint8Array);\n\n/**\n * Create an Uint8Array view of the next `len` bytes and advance the position by `len`.\n *\n * Important: The Uint8Array still points to the underlying ArrayBuffer. Make sure to discard the result as soon as possible to prevent any memory leaks.\n *            Use `buffer.copyUint8Array` to copy the result into a new Uint8Array.\n *\n * @function\n * @param {Decoder} decoder The decoder instance\n * @param {number} len The length of bytes to read\n * @return {Uint8Array}\n */\nconst readUint8Array = (decoder, len) => {\n  const view = new Uint8Array(decoder.arr.buffer, decoder.pos + decoder.arr.byteOffset, len);\n  decoder.pos += len;\n  return view\n};\n\n/**\n * Read variable length Uint8Array.\n *\n * Important: The Uint8Array still points to the underlying ArrayBuffer. Make sure to discard the result as soon as possible to prevent any memory leaks.\n *            Use `buffer.copyUint8Array` to copy the result into a new Uint8Array.\n *\n * @function\n * @param {Decoder} decoder\n * @return {Uint8Array}\n */\nconst readVarUint8Array = decoder => readUint8Array(decoder, readVarUint(decoder));\n\n/**\n * Read one byte as unsigned integer.\n * @function\n * @param {Decoder} decoder The decoder instance\n * @return {number} Unsigned 8-bit integer\n */\nconst readUint8 = decoder => decoder.arr[decoder.pos++];\n\n/**\n * Read unsigned integer (32bit) with variable length.\n * 1/8th of the storage is used as encoding overhead.\n *  * numbers < 2^7 is stored in one bytlength\n *  * numbers < 2^14 is stored in two bylength\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.length\n */\nconst readVarUint = decoder => {\n  let num = 0;\n  let mult = 1;\n  const len = decoder.arr.length;\n  while (decoder.pos < len) {\n    const r = decoder.arr[decoder.pos++];\n    // num = num | ((r & binary.BITS7) << len)\n    num = num + (r & BITS7) * mult; // shift $r << (7*#iterations) and add it to num\n    mult *= 128; // next iteration, shift 7 \"more\" to the left\n    if (r < BIT8) {\n      return num\n    }\n    /* c8 ignore start */\n    if (num > MAX_SAFE_INTEGER) {\n      throw errorIntegerOutOfRange\n    }\n    /* c8 ignore stop */\n  }\n  throw errorUnexpectedEndOfArray\n};\n\n/**\n * Read signed integer (32bit) with variable length.\n * 1/8th of the storage is used as encoding overhead.\n *  * numbers < 2^7 is stored in one bytlength\n *  * numbers < 2^14 is stored in two bylength\n * @todo This should probably create the inverse ~num if number is negative - but this would be a breaking change.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.length\n */\nconst readVarInt = decoder => {\n  let r = decoder.arr[decoder.pos++];\n  let num = r & BITS6;\n  let mult = 64;\n  const sign = (r & BIT7) > 0 ? -1 : 1;\n  if ((r & BIT8) === 0) {\n    // don't continue reading\n    return sign * num\n  }\n  const len = decoder.arr.length;\n  while (decoder.pos < len) {\n    r = decoder.arr[decoder.pos++];\n    // num = num | ((r & binary.BITS7) << len)\n    num = num + (r & BITS7) * mult;\n    mult *= 128;\n    if (r < BIT8) {\n      return sign * num\n    }\n    /* c8 ignore start */\n    if (num > MAX_SAFE_INTEGER) {\n      throw errorIntegerOutOfRange\n    }\n    /* c8 ignore stop */\n  }\n  throw errorUnexpectedEndOfArray\n};\n\n/**\n * We don't test this function anymore as we use native decoding/encoding by default now.\n * Better not modify this anymore..\n *\n * Transforming utf8 to a string is pretty expensive. The code performs 10x better\n * when String.fromCodePoint is fed with all characters as arguments.\n * But most environments have a maximum number of arguments per functions.\n * For effiency reasons we apply a maximum of 10000 characters at once.\n *\n * @function\n * @param {Decoder} decoder\n * @return {String} The read String.\n */\n/* c8 ignore start */\nconst _readVarStringPolyfill = decoder => {\n  let remainingLen = readVarUint(decoder);\n  if (remainingLen === 0) {\n    return ''\n  } else {\n    let encodedString = String.fromCodePoint(readUint8(decoder)); // remember to decrease remainingLen\n    if (--remainingLen < 100) { // do not create a Uint8Array for small strings\n      while (remainingLen--) {\n        encodedString += String.fromCodePoint(readUint8(decoder));\n      }\n    } else {\n      while (remainingLen > 0) {\n        const nextLen = remainingLen < 10000 ? remainingLen : 10000;\n        // this is dangerous, we create a fresh array view from the existing buffer\n        const bytes = decoder.arr.subarray(decoder.pos, decoder.pos + nextLen);\n        decoder.pos += nextLen;\n        // Starting with ES5.1 we can supply a generic array-like object as arguments\n        encodedString += String.fromCodePoint.apply(null, /** @type {any} */ (bytes));\n        remainingLen -= nextLen;\n      }\n    }\n    return decodeURIComponent(escape(encodedString))\n  }\n};\n/* c8 ignore stop */\n\n/**\n * @function\n * @param {Decoder} decoder\n * @return {String} The read String\n */\nconst _readVarStringNative = decoder =>\n  /** @type any */ (utf8TextDecoder).decode(readVarUint8Array(decoder));\n\n/**\n * Read string of variable length\n * * varUint is used to store the length of the string\n *\n * @function\n * @param {Decoder} decoder\n * @return {String} The read String\n *\n */\n/* c8 ignore next */\nconst readVarString = utf8TextDecoder ? _readVarStringNative : _readVarStringPolyfill;\n\n/**\n * Look ahead and read varString without incrementing position\n *\n * @function\n * @param {Decoder} decoder\n * @return {string}\n */\nconst peekVarString = decoder => {\n  const pos = decoder.pos;\n  const s = readVarString(decoder);\n  decoder.pos = pos;\n  return s\n};\n\n/**\n * Utility module to work with time.\n *\n * @module time\n */\n\n\n/**\n * Return current unix time.\n *\n * @return {number}\n */\nconst getUnixTime = Date.now;\n\n/**\n * Utility module to work with key-value stores.\n *\n * @module map\n */\n\n/**\n * Creates a new Map instance.\n *\n * @function\n * @return {Map<any, any>}\n *\n * @function\n */\nconst create = () => new Map();\n\n/**\n * Get map property. Create T if property is undefined and set T on map.\n *\n * ```js\n * const listeners = map.setIfUndefined(events, 'eventName', set.create)\n * listeners.add(listener)\n * ```\n *\n * @function\n * @template {Map<any, any>} MAP\n * @template {MAP extends Map<any,infer V> ? function():V : unknown} CF\n * @param {MAP} map\n * @param {MAP extends Map<infer K,any> ? K : unknown} key\n * @param {CF} createT\n * @return {ReturnType<CF>}\n */\nconst setIfUndefined = (map, key, createT) => {\n  let set = map.get(key);\n  if (set === undefined) {\n    map.set(key, set = createT());\n  }\n  return set\n};\n\n/**\n * Observable class prototype.\n *\n * @module observable\n */\n\n\n/* c8 ignore start */\n/**\n * Handles named events.\n *\n * @deprecated\n * @template N\n */\nclass Observable {\n  constructor () {\n    /**\n     * Some desc.\n     * @type {Map<N, any>}\n     */\n    this._observers = create();\n  }\n\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  on (name, f) {\n    setIfUndefined(this._observers, name, create$2).add(f);\n  }\n\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  once (name, f) {\n    /**\n     * @param  {...any} args\n     */\n    const _f = (...args) => {\n      this.off(name, _f);\n      f(...args);\n    };\n    this.on(name, _f);\n  }\n\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  off (name, f) {\n    const observers = this._observers.get(name);\n    if (observers !== undefined) {\n      observers.delete(f);\n      if (observers.size === 0) {\n        this._observers.delete(name);\n      }\n    }\n  }\n\n  /**\n   * Emit a named event. All registered event listeners that listen to the\n   * specified name will receive the event.\n   *\n   * @todo This should catch exceptions\n   *\n   * @param {N} name The event name.\n   * @param {Array<any>} args The arguments that are applied to the event listener.\n   */\n  emit (name, args) {\n    // copy all listeners to an array first to make sure that no event is emitted to listeners that are subscribed while the event handler is called.\n    return from((this._observers.get(name) || create()).values()).forEach(f => f(...args))\n  }\n\n  destroy () {\n    this._observers = create();\n  }\n}\n/* c8 ignore end */\n\n/**\n * Utility functions for working with EcmaScript objects.\n *\n * @module object\n */\n\n\n/**\n * @param {Object<string,any>} obj\n */\nconst keys = Object.keys;\n\n/**\n * @deprecated use object.size instead\n * @param {Object<string,any>} obj\n * @return {number}\n */\nconst length = obj => keys(obj).length;\n\n/**\n * Calls `Object.prototype.hasOwnProperty`.\n *\n * @param {any} obj\n * @param {string|symbol} key\n * @return {boolean}\n */\nconst hasProperty = (obj, key) => Object.prototype.hasOwnProperty.call(obj, key);\n\n/**\n * Common functions and function call helpers.\n *\n * @module function\n */\n\n\n/**\n * @template T\n *\n * @param {T} a\n * @param {T} b\n * @return {boolean}\n */\nconst equalityStrict = (a, b) => a === b;\n\n/* c8 ignore start */\n\n/**\n * @param {any} a\n * @param {any} b\n * @return {boolean}\n */\nconst equalityDeep = (a, b) => {\n  if (a == null || b == null) {\n    return equalityStrict(a, b)\n  }\n  if (a.constructor !== b.constructor) {\n    return false\n  }\n  if (a === b) {\n    return true\n  }\n  switch (a.constructor) {\n    case ArrayBuffer:\n      a = new Uint8Array(a);\n      b = new Uint8Array(b);\n    // eslint-disable-next-line no-fallthrough\n    case Uint8Array: {\n      if (a.byteLength !== b.byteLength) {\n        return false\n      }\n      for (let i = 0; i < a.length; i++) {\n        if (a[i] !== b[i]) {\n          return false\n        }\n      }\n      break\n    }\n    case Set: {\n      if (a.size !== b.size) {\n        return false\n      }\n      for (const value of a) {\n        if (!b.has(value)) {\n          return false\n        }\n      }\n      break\n    }\n    case Map: {\n      if (a.size !== b.size) {\n        return false\n      }\n      for (const key of a.keys()) {\n        if (!b.has(key) || !equalityDeep(a.get(key), b.get(key))) {\n          return false\n        }\n      }\n      break\n    }\n    case Object:\n      if (length(a) !== length(b)) {\n        return false\n      }\n      for (const key in a) {\n        if (!hasProperty(a, key) || !equalityDeep(a[key], b[key])) {\n          return false\n        }\n      }\n      break\n    case Array:\n      if (a.length !== b.length) {\n        return false\n      }\n      for (let i = 0; i < a.length; i++) {\n        if (!equalityDeep(a[i], b[i])) {\n          return false\n        }\n      }\n      break\n    default:\n      return false\n  }\n  return true\n};\n\n/**\n * @module awareness-protocol\n */\n\n\nconst outdatedTimeout = 30000;\n\n/**\n * @typedef {Object} MetaClientState\n * @property {number} MetaClientState.clock\n * @property {number} MetaClientState.lastUpdated unix timestamp\n */\n\n/**\n * The Awareness class implements a simple shared state protocol that can be used for non-persistent data like awareness information\n * (cursor, username, status, ..). Each client can update its own local state and listen to state changes of\n * remote clients. Every client may set a state of a remote peer to `null` to mark the client as offline.\n *\n * Each client is identified by a unique client id (something we borrow from `doc.clientID`). A client can override\n * its own state by propagating a message with an increasing timestamp (`clock`). If such a message is received, it is\n * applied if the known state of that client is older than the new state (`clock < newClock`). If a client thinks that\n * a remote client is offline, it may propagate a message with\n * `{ clock: currentClientClock, state: null, client: remoteClient }`. If such a\n * message is received, and the known clock of that client equals the received clock, it will override the state with `null`.\n *\n * Before a client disconnects, it should propagate a `null` state with an updated clock.\n *\n * Awareness states must be updated every 30 seconds. Otherwise the Awareness instance will delete the client state.\n *\n * @extends {Observable<string>}\n */\nclass Awareness extends Observable {\n  /**\n   * @param {Y.Doc} doc\n   */\n  constructor (doc) {\n    super();\n    this.doc = doc;\n    /**\n     * @type {number}\n     */\n    this.clientID = doc.clientID;\n    /**\n     * Maps from client id to client state\n     * @type {Map<number, Object<string, any>>}\n     */\n    this.states = new Map();\n    /**\n     * @type {Map<number, MetaClientState>}\n     */\n    this.meta = new Map();\n    this._checkInterval = /** @type {any} */ (setInterval(() => {\n      const now = getUnixTime();\n      if (this.getLocalState() !== null && (outdatedTimeout / 2 <= now - /** @type {{lastUpdated:number}} */ (this.meta.get(this.clientID)).lastUpdated)) {\n        // renew local clock\n        this.setLocalState(this.getLocalState());\n      }\n      /**\n       * @type {Array<number>}\n       */\n      const remove = [];\n      this.meta.forEach((meta, clientid) => {\n        if (clientid !== this.clientID && outdatedTimeout <= now - meta.lastUpdated && this.states.has(clientid)) {\n          remove.push(clientid);\n        }\n      });\n      if (remove.length > 0) {\n        removeAwarenessStates(this, remove, 'timeout');\n      }\n    }, floor(outdatedTimeout / 10)));\n    doc.on('destroy', () => {\n      this.destroy();\n    });\n    this.setLocalState({});\n  }\n\n  destroy () {\n    this.emit('destroy', [this]);\n    this.setLocalState(null);\n    super.destroy();\n    clearInterval(this._checkInterval);\n  }\n\n  /**\n   * @return {Object<string,any>|null}\n   */\n  getLocalState () {\n    return this.states.get(this.clientID) || null\n  }\n\n  /**\n   * @param {Object<string,any>|null} state\n   */\n  setLocalState (state) {\n    const clientID = this.clientID;\n    const currLocalMeta = this.meta.get(clientID);\n    const clock = currLocalMeta === undefined ? 0 : currLocalMeta.clock + 1;\n    const prevState = this.states.get(clientID);\n    if (state === null) {\n      this.states.delete(clientID);\n    } else {\n      this.states.set(clientID, state);\n    }\n    this.meta.set(clientID, {\n      clock,\n      lastUpdated: getUnixTime()\n    });\n    const added = [];\n    const updated = [];\n    const filteredUpdated = [];\n    const removed = [];\n    if (state === null) {\n      removed.push(clientID);\n    } else if (prevState == null) {\n      if (state != null) {\n        added.push(clientID);\n      }\n    } else {\n      updated.push(clientID);\n      if (!equalityDeep(prevState, state)) {\n        filteredUpdated.push(clientID);\n      }\n    }\n    if (added.length > 0 || filteredUpdated.length > 0 || removed.length > 0) {\n      this.emit('change', [{ added, updated: filteredUpdated, removed }, 'local']);\n    }\n    this.emit('update', [{ added, updated, removed }, 'local']);\n  }\n\n  /**\n   * @param {string} field\n   * @param {any} value\n   */\n  setLocalStateField (field, value) {\n    const state = this.getLocalState();\n    if (state !== null) {\n      this.setLocalState({\n        ...state,\n        [field]: value\n      });\n    }\n  }\n\n  /**\n   * @return {Map<number,Object<string,any>>}\n   */\n  getStates () {\n    return this.states\n  }\n}\n\n/**\n * Mark (remote) clients as inactive and remove them from the list of active peers.\n * This change will be propagated to remote clients.\n *\n * @param {Awareness} awareness\n * @param {Array<number>} clients\n * @param {any} origin\n */\nconst removeAwarenessStates = (awareness, clients, origin) => {\n  const removed = [];\n  for (let i = 0; i < clients.length; i++) {\n    const clientID = clients[i];\n    if (awareness.states.has(clientID)) {\n      awareness.states.delete(clientID);\n      if (clientID === awareness.clientID) {\n        const curMeta = /** @type {MetaClientState} */ (awareness.meta.get(clientID));\n        awareness.meta.set(clientID, {\n          clock: curMeta.clock + 1,\n          lastUpdated: getUnixTime()\n        });\n      }\n      removed.push(clientID);\n    }\n  }\n  if (removed.length > 0) {\n    awareness.emit('change', [{ added: [], updated: [], removed }, origin]);\n    awareness.emit('update', [{ added: [], updated: [], removed }, origin]);\n  }\n};\n\n/**\n * @param {Awareness} awareness\n * @param {Array<number>} clients\n * @return {Uint8Array}\n */\nconst encodeAwarenessUpdate = (awareness, clients, states = awareness.states) => {\n  const len = clients.length;\n  const encoder = createEncoder();\n  writeVarUint(encoder, len);\n  for (let i = 0; i < len; i++) {\n    const clientID = clients[i];\n    const state = states.get(clientID) || null;\n    const clock = /** @type {MetaClientState} */ (awareness.meta.get(clientID)).clock;\n    writeVarUint(encoder, clientID);\n    writeVarUint(encoder, clock);\n    writeVarString(encoder, JSON.stringify(state));\n  }\n  return toUint8Array(encoder)\n};\n\n/**\n * @param {Awareness} awareness\n * @param {Uint8Array} update\n * @param {any} origin This will be added to the emitted change event\n */\nconst applyAwarenessUpdate = (awareness, update, origin) => {\n  const decoder = createDecoder(update);\n  const timestamp = getUnixTime();\n  const added = [];\n  const updated = [];\n  const filteredUpdated = [];\n  const removed = [];\n  const len = readVarUint(decoder);\n  for (let i = 0; i < len; i++) {\n    const clientID = readVarUint(decoder);\n    let clock = readVarUint(decoder);\n    const state = JSON.parse(readVarString(decoder));\n    const clientMeta = awareness.meta.get(clientID);\n    const prevState = awareness.states.get(clientID);\n    const currClock = clientMeta === undefined ? 0 : clientMeta.clock;\n    if (currClock < clock || (currClock === clock && state === null && awareness.states.has(clientID))) {\n      if (state === null) {\n        // never let a remote client remove this local state\n        if (clientID === awareness.clientID && awareness.getLocalState() != null) {\n          // remote client removed the local state. Do not remote state. Broadcast a message indicating\n          // that this client still exists by increasing the clock\n          clock++;\n        } else {\n          awareness.states.delete(clientID);\n        }\n      } else {\n        awareness.states.set(clientID, state);\n      }\n      awareness.meta.set(clientID, {\n        clock,\n        lastUpdated: timestamp\n      });\n      if (clientMeta === undefined && state !== null) {\n        added.push(clientID);\n      } else if (clientMeta !== undefined && state === null) {\n        removed.push(clientID);\n      } else if (state !== null) {\n        if (!equalityDeep(state, prevState)) {\n          filteredUpdated.push(clientID);\n        }\n        updated.push(clientID);\n      }\n    }\n  }\n  if (added.length > 0 || filteredUpdated.length > 0 || removed.length > 0) {\n    awareness.emit('change', [{\n      added, updated: filteredUpdated, removed\n    }, origin]);\n  }\n  if (added.length > 0 || updated.length > 0 || removed.length > 0) {\n    awareness.emit('update', [{\n      added, updated, removed\n    }, origin]);\n  }\n};\n\nclass EventEmitter {\n    constructor() {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type\n        this.callbacks = {};\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type\n    on(event, fn) {\n        if (!this.callbacks[event]) {\n            this.callbacks[event] = [];\n        }\n        this.callbacks[event].push(fn);\n        return this;\n    }\n    emit(event, ...args) {\n        const callbacks = this.callbacks[event];\n        if (callbacks) {\n            callbacks.forEach(callback => callback.apply(this, args));\n        }\n        return this;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type\n    off(event, fn) {\n        const callbacks = this.callbacks[event];\n        if (callbacks) {\n            if (fn) {\n                this.callbacks[event] = callbacks.filter(callback => callback !== fn);\n            }\n            else {\n                delete this.callbacks[event];\n            }\n        }\n        return this;\n    }\n    removeAllListeners() {\n        this.callbacks = {};\n    }\n}\n\nclass IncomingMessage {\n    constructor(data) {\n        this.data = data;\n        this.encoder = createEncoder();\n        this.decoder = createDecoder(new Uint8Array(this.data));\n    }\n    peekVarString() {\n        return peekVarString(this.decoder);\n    }\n    readVarUint() {\n        return readVarUint(this.decoder);\n    }\n    readVarString() {\n        return readVarString(this.decoder);\n    }\n    readVarUint8Array() {\n        return readVarUint8Array(this.decoder);\n    }\n    writeVarUint(type) {\n        return writeVarUint(this.encoder, type);\n    }\n    writeVarString(string) {\n        return writeVarString(this.encoder, string);\n    }\n    writeVarUint8Array(data) {\n        return writeVarUint8Array(this.encoder, data);\n    }\n    length() {\n        return length$1(this.encoder);\n    }\n}\n\nvar MessageType;\n(function (MessageType) {\n    MessageType[MessageType[\"Sync\"] = 0] = \"Sync\";\n    MessageType[MessageType[\"Awareness\"] = 1] = \"Awareness\";\n    MessageType[MessageType[\"Auth\"] = 2] = \"Auth\";\n    MessageType[MessageType[\"QueryAwareness\"] = 3] = \"QueryAwareness\";\n    MessageType[MessageType[\"Stateless\"] = 5] = \"Stateless\";\n    MessageType[MessageType[\"CLOSE\"] = 7] = \"CLOSE\";\n    MessageType[MessageType[\"SyncStatus\"] = 8] = \"SyncStatus\";\n})(MessageType || (MessageType = {}));\nvar WebSocketStatus;\n(function (WebSocketStatus) {\n    WebSocketStatus[\"Connecting\"] = \"connecting\";\n    WebSocketStatus[\"Connected\"] = \"connected\";\n    WebSocketStatus[\"Disconnected\"] = \"disconnected\";\n})(WebSocketStatus || (WebSocketStatus = {}));\n\nclass OutgoingMessage {\n    constructor() {\n        this.encoder = createEncoder();\n    }\n    get(args) {\n        return args.encoder;\n    }\n    toUint8Array() {\n        return toUint8Array(this.encoder);\n    }\n}\n\nclass CloseMessage extends OutgoingMessage {\n    constructor() {\n        super(...arguments);\n        this.type = MessageType.CLOSE;\n        this.description = 'Ask the server to close the connection';\n    }\n    get(args) {\n        writeVarString(this.encoder, args.documentName);\n        writeVarUint(this.encoder, this.type);\n        return this.encoder;\n    }\n}\n\nclass HocuspocusProviderWebsocket extends EventEmitter {\n    constructor(configuration) {\n        super();\n        this.messageQueue = [];\n        this.configuration = {\n            url: \"\",\n            // @ts-ignore\n            document: undefined,\n            WebSocketPolyfill: undefined,\n            // TODO: this should depend on awareness.outdatedTime\n            messageReconnectTimeout: 30000,\n            // 1 second\n            delay: 1000,\n            // instant\n            initialDelay: 0,\n            // double the delay each time\n            factor: 2,\n            // unlimited retries\n            maxAttempts: 0,\n            // wait at least 1 second\n            minDelay: 1000,\n            // at least every 30 seconds\n            maxDelay: 30000,\n            // randomize\n            jitter: true,\n            // retry forever\n            timeout: 0,\n            onOpen: () => null,\n            onConnect: () => null,\n            onMessage: () => null,\n            onOutgoingMessage: () => null,\n            onStatus: () => null,\n            onDisconnect: () => null,\n            onClose: () => null,\n            onDestroy: () => null,\n            onAwarenessUpdate: () => null,\n            onAwarenessChange: () => null,\n            providerMap: new Map(),\n        };\n        this.webSocket = null;\n        this.webSocketHandlers = {};\n        this.shouldConnect = true;\n        this.status = WebSocketStatus.Disconnected;\n        this.lastMessageReceived = 0;\n        this.identifier = 0;\n        this.intervals = {\n            connectionChecker: null,\n        };\n        this.connectionAttempt = null;\n        this.receivedOnOpenPayload = undefined;\n        this.closeTries = 0;\n        this.setConfiguration(configuration);\n        this.configuration.WebSocketPolyfill = configuration.WebSocketPolyfill\n            ? configuration.WebSocketPolyfill\n            : WebSocket;\n        this.on(\"open\", this.configuration.onOpen);\n        this.on(\"open\", this.onOpen.bind(this));\n        this.on(\"connect\", this.configuration.onConnect);\n        this.on(\"message\", this.configuration.onMessage);\n        this.on(\"outgoingMessage\", this.configuration.onOutgoingMessage);\n        this.on(\"status\", this.configuration.onStatus);\n        this.on(\"disconnect\", this.configuration.onDisconnect);\n        this.on(\"close\", this.configuration.onClose);\n        this.on(\"destroy\", this.configuration.onDestroy);\n        this.on(\"awarenessUpdate\", this.configuration.onAwarenessUpdate);\n        this.on(\"awarenessChange\", this.configuration.onAwarenessChange);\n        this.on(\"close\", this.onClose.bind(this));\n        this.on(\"message\", this.onMessage.bind(this));\n        this.intervals.connectionChecker = setInterval(this.checkConnection.bind(this), this.configuration.messageReconnectTimeout / 10);\n        if (!this.shouldConnect) {\n            return;\n        }\n        this.connect();\n    }\n    async onOpen(event) {\n        this.cancelWebsocketRetry = undefined;\n        this.receivedOnOpenPayload = event;\n    }\n    attach(provider) {\n        this.configuration.providerMap.set(provider.configuration.name, provider);\n        if (this.status === WebSocketStatus.Disconnected && this.shouldConnect) {\n            this.connect();\n        }\n        if (this.receivedOnOpenPayload &&\n            this.status === WebSocketStatus.Connected) {\n            provider.onOpen(this.receivedOnOpenPayload);\n        }\n    }\n    detach(provider) {\n        if (this.configuration.providerMap.has(provider.configuration.name)) {\n            provider.send(CloseMessage, {\n                documentName: provider.configuration.name,\n            });\n            this.configuration.providerMap.delete(provider.configuration.name);\n        }\n    }\n    setConfiguration(configuration = {}) {\n        this.configuration = { ...this.configuration, ...configuration };\n    }\n    async connect() {\n        if (this.status === WebSocketStatus.Connected) {\n            return;\n        }\n        // Always cancel any previously initiated connection retryer instances\n        if (this.cancelWebsocketRetry) {\n            this.cancelWebsocketRetry();\n            this.cancelWebsocketRetry = undefined;\n        }\n        this.receivedOnOpenPayload = undefined;\n        this.shouldConnect = true;\n        const abortableRetry = () => {\n            let cancelAttempt = false;\n            const retryPromise = (0,_lifeomic_attempt__WEBPACK_IMPORTED_MODULE_1__.retry)(this.createWebSocketConnection.bind(this), {\n                delay: this.configuration.delay,\n                initialDelay: this.configuration.initialDelay,\n                factor: this.configuration.factor,\n                maxAttempts: this.configuration.maxAttempts,\n                minDelay: this.configuration.minDelay,\n                maxDelay: this.configuration.maxDelay,\n                jitter: this.configuration.jitter,\n                timeout: this.configuration.timeout,\n                beforeAttempt: (context) => {\n                    if (!this.shouldConnect || cancelAttempt) {\n                        context.abort();\n                    }\n                },\n            }).catch((error) => {\n                // If we aborted the connection attempt then don’t throw an error\n                // ref: https://github.com/lifeomic/attempt/blob/master/src/index.ts#L136\n                if (error && error.code !== \"ATTEMPT_ABORTED\") {\n                    throw error;\n                }\n            });\n            return {\n                retryPromise,\n                cancelFunc: () => {\n                    cancelAttempt = true;\n                },\n            };\n        };\n        const { retryPromise, cancelFunc } = abortableRetry();\n        this.cancelWebsocketRetry = cancelFunc;\n        return retryPromise;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type\n    attachWebSocketListeners(ws, reject) {\n        const { identifier } = ws;\n        const onMessageHandler = (payload) => this.emit(\"message\", payload);\n        const onCloseHandler = (payload) => this.emit(\"close\", { event: payload });\n        const onOpenHandler = (payload) => this.emit(\"open\", payload);\n        const onErrorHandler = (err) => {\n            reject(err);\n        };\n        this.webSocketHandlers[identifier] = {\n            message: onMessageHandler,\n            close: onCloseHandler,\n            open: onOpenHandler,\n            error: onErrorHandler,\n        };\n        const handlers = this.webSocketHandlers[ws.identifier];\n        Object.keys(handlers).forEach((name) => {\n            ws.addEventListener(name, handlers[name]);\n        });\n    }\n    cleanupWebSocket() {\n        if (!this.webSocket) {\n            return;\n        }\n        const { identifier } = this.webSocket;\n        const handlers = this.webSocketHandlers[identifier];\n        Object.keys(handlers).forEach((name) => {\n            var _a;\n            (_a = this.webSocket) === null || _a === void 0 ? void 0 : _a.removeEventListener(name, handlers[name]);\n            delete this.webSocketHandlers[identifier];\n        });\n        this.webSocket.close();\n        this.webSocket = null;\n    }\n    createWebSocketConnection() {\n        return new Promise((resolve, reject) => {\n            if (this.webSocket) {\n                this.messageQueue = [];\n                this.cleanupWebSocket();\n            }\n            this.lastMessageReceived = 0;\n            this.identifier += 1;\n            // Init the WebSocket connection\n            const ws = new this.configuration.WebSocketPolyfill(this.url);\n            ws.binaryType = \"arraybuffer\";\n            ws.identifier = this.identifier;\n            this.attachWebSocketListeners(ws, reject);\n            this.webSocket = ws;\n            // Reset the status\n            this.status = WebSocketStatus.Connecting;\n            this.emit(\"status\", { status: WebSocketStatus.Connecting });\n            // Store resolve/reject for later use\n            this.connectionAttempt = {\n                resolve,\n                reject,\n            };\n        });\n    }\n    onMessage(event) {\n        var _a;\n        this.resolveConnectionAttempt();\n        this.lastMessageReceived = getUnixTime();\n        const message = new IncomingMessage(event.data);\n        const documentName = message.peekVarString();\n        (_a = this.configuration.providerMap.get(documentName)) === null || _a === void 0 ? void 0 : _a.onMessage(event);\n    }\n    resolveConnectionAttempt() {\n        if (this.connectionAttempt) {\n            this.connectionAttempt.resolve();\n            this.connectionAttempt = null;\n            this.status = WebSocketStatus.Connected;\n            this.emit(\"status\", { status: WebSocketStatus.Connected });\n            this.emit(\"connect\");\n            this.messageQueue.forEach((message) => this.send(message));\n            this.messageQueue = [];\n        }\n    }\n    stopConnectionAttempt() {\n        this.connectionAttempt = null;\n    }\n    rejectConnectionAttempt() {\n        var _a;\n        (_a = this.connectionAttempt) === null || _a === void 0 ? void 0 : _a.reject();\n        this.connectionAttempt = null;\n    }\n    checkConnection() {\n        var _a;\n        // Don’t check the connection when it’s not even established\n        if (this.status !== WebSocketStatus.Connected) {\n            return;\n        }\n        // Don’t close the connection while waiting for the first message\n        if (!this.lastMessageReceived) {\n            return;\n        }\n        // Don’t close the connection when a message was received recently\n        if (this.configuration.messageReconnectTimeout >=\n            getUnixTime() - this.lastMessageReceived) {\n            return;\n        }\n        // No message received in a long time, not even your own\n        // Awareness updates, which are updated every 15 seconds\n        // if awareness is enabled.\n        this.closeTries += 1;\n        // https://bugs.webkit.org/show_bug.cgi?id=247943\n        if (this.closeTries > 2) {\n            this.onClose({\n                event: {\n                    code: 4408,\n                    reason: \"forced\",\n                },\n            });\n            this.closeTries = 0;\n        }\n        else {\n            (_a = this.webSocket) === null || _a === void 0 ? void 0 : _a.close();\n            this.messageQueue = [];\n        }\n    }\n    // Ensure that the URL never ends with /\n    get serverUrl() {\n        while (this.configuration.url[this.configuration.url.length - 1] === \"/\") {\n            return this.configuration.url.slice(0, this.configuration.url.length - 1);\n        }\n        return this.configuration.url;\n    }\n    get url() {\n        return this.serverUrl;\n    }\n    disconnect() {\n        this.shouldConnect = false;\n        if (this.webSocket === null) {\n            return;\n        }\n        try {\n            this.webSocket.close();\n            this.messageQueue = [];\n        }\n        catch (e) {\n            console.error(e);\n        }\n    }\n    send(message) {\n        var _a;\n        if (((_a = this.webSocket) === null || _a === void 0 ? void 0 : _a.readyState) === _hocuspocus_common__WEBPACK_IMPORTED_MODULE_0__.WsReadyStates.Open) {\n            this.webSocket.send(message);\n        }\n        else {\n            this.messageQueue.push(message);\n        }\n    }\n    onClose({ event }) {\n        this.closeTries = 0;\n        this.cleanupWebSocket();\n        if (this.connectionAttempt) {\n            // That connection attempt failed.\n            this.rejectConnectionAttempt();\n        }\n        // Let’s update the connection status.\n        this.status = WebSocketStatus.Disconnected;\n        this.emit(\"status\", { status: WebSocketStatus.Disconnected });\n        this.emit(\"disconnect\", { event });\n        // trigger connect if no retry is running and we want to have a connection\n        if (!this.cancelWebsocketRetry && this.shouldConnect) {\n            setTimeout(() => {\n                this.connect();\n            }, this.configuration.delay);\n        }\n    }\n    destroy() {\n        this.emit(\"destroy\");\n        clearInterval(this.intervals.connectionChecker);\n        // If there is still a connection attempt outstanding then we should stop\n        // it before calling disconnect, otherwise it will be rejected in the onClose\n        // handler and trigger a retry\n        this.stopConnectionAttempt();\n        this.disconnect();\n        this.removeAllListeners();\n        this.cleanupWebSocket();\n    }\n}\n\n/**\n * @module sync-protocol\n */\n\n\n/**\n * @typedef {Map<number, number>} StateMap\n */\n\n/**\n * Core Yjs defines two message types:\n * • YjsSyncStep1: Includes the State Set of the sending client. When received, the client should reply with YjsSyncStep2.\n * • YjsSyncStep2: Includes all missing structs and the complete delete set. When received, the client is assured that it\n *   received all information from the remote client.\n *\n * In a peer-to-peer network, you may want to introduce a SyncDone message type. Both parties should initiate the connection\n * with SyncStep1. When a client received SyncStep2, it should reply with SyncDone. When the local client received both\n * SyncStep2 and SyncDone, it is assured that it is synced to the remote client.\n *\n * In a client-server model, you want to handle this differently: The client should initiate the connection with SyncStep1.\n * When the server receives SyncStep1, it should reply with SyncStep2 immediately followed by SyncStep1. The client replies\n * with SyncStep2 when it receives SyncStep1. Optionally the server may send a SyncDone after it received SyncStep2, so the\n * client knows that the sync is finished.  There are two reasons for this more elaborated sync model: 1. This protocol can\n * easily be implemented on top of http and websockets. 2. The server should only reply to requests, and not initiate them.\n * Therefore it is necessary that the client initiates the sync.\n *\n * Construction of a message:\n * [messageType : varUint, message definition..]\n *\n * Note: A message does not include information about the room name. This must to be handled by the upper layer protocol!\n *\n * stringify[messageType] stringifies a message definition (messageType is already read from the bufffer)\n */\n\nconst messageYjsSyncStep1 = 0;\nconst messageYjsSyncStep2 = 1;\nconst messageYjsUpdate = 2;\n\n/**\n * Create a sync step 1 message based on the state of the current shared document.\n *\n * @param {encoding.Encoder} encoder\n * @param {Y.Doc} doc\n */\nconst writeSyncStep1 = (encoder, doc) => {\n  writeVarUint(encoder, messageYjsSyncStep1);\n  const sv = yjs__WEBPACK_IMPORTED_MODULE_2__.encodeStateVector(doc);\n  writeVarUint8Array(encoder, sv);\n};\n\n/**\n * @param {encoding.Encoder} encoder\n * @param {Y.Doc} doc\n * @param {Uint8Array} [encodedStateVector]\n */\nconst writeSyncStep2 = (encoder, doc, encodedStateVector) => {\n  writeVarUint(encoder, messageYjsSyncStep2);\n  writeVarUint8Array(encoder, yjs__WEBPACK_IMPORTED_MODULE_2__.encodeStateAsUpdate(doc, encodedStateVector));\n};\n\n/**\n * Read SyncStep1 message and reply with SyncStep2.\n *\n * @param {decoding.Decoder} decoder The reply to the received message\n * @param {encoding.Encoder} encoder The received message\n * @param {Y.Doc} doc\n */\nconst readSyncStep1 = (decoder, encoder, doc) =>\n  writeSyncStep2(encoder, doc, readVarUint8Array(decoder));\n\n/**\n * Read and apply Structs and then DeleteStore to a y instance.\n *\n * @param {decoding.Decoder} decoder\n * @param {Y.Doc} doc\n * @param {any} transactionOrigin\n */\nconst readSyncStep2 = (decoder, doc, transactionOrigin) => {\n  try {\n    yjs__WEBPACK_IMPORTED_MODULE_2__.applyUpdate(doc, readVarUint8Array(decoder), transactionOrigin);\n  } catch (error) {\n    // This catches errors that are thrown by event handlers\n    console.error('Caught error while handling a Yjs update', error);\n  }\n};\n\n/**\n * @param {encoding.Encoder} encoder\n * @param {Uint8Array} update\n */\nconst writeUpdate = (encoder, update) => {\n  writeVarUint(encoder, messageYjsUpdate);\n  writeVarUint8Array(encoder, update);\n};\n\n/**\n * Read and apply Structs and then DeleteStore to a y instance.\n *\n * @param {decoding.Decoder} decoder\n * @param {Y.Doc} doc\n * @param {any} transactionOrigin\n */\nconst readUpdate = readSyncStep2;\n\n/**\n * @param {decoding.Decoder} decoder A message received from another client\n * @param {encoding.Encoder} encoder The reply message. Does not need to be sent if empty.\n * @param {Y.Doc} doc\n * @param {any} transactionOrigin\n */\nconst readSyncMessage = (decoder, encoder, doc, transactionOrigin) => {\n  const messageType = readVarUint(decoder);\n  switch (messageType) {\n    case messageYjsSyncStep1:\n      readSyncStep1(decoder, encoder, doc);\n      break\n    case messageYjsSyncStep2:\n      readSyncStep2(decoder, doc, transactionOrigin);\n      break\n    case messageYjsUpdate:\n      readUpdate(decoder, doc, transactionOrigin);\n      break\n    default:\n      throw new Error('Unknown message type')\n  }\n  return messageType\n};\n\nclass MessageReceiver {\n    constructor(message) {\n        this.message = message;\n    }\n    apply(provider, emitSynced) {\n        const { message } = this;\n        const type = message.readVarUint();\n        const emptyMessageLength = message.length();\n        switch (type) {\n            case MessageType.Sync:\n                this.applySyncMessage(provider, emitSynced);\n                break;\n            case MessageType.Awareness:\n                this.applyAwarenessMessage(provider);\n                break;\n            case MessageType.Auth:\n                this.applyAuthMessage(provider);\n                break;\n            case MessageType.QueryAwareness:\n                this.applyQueryAwarenessMessage(provider);\n                break;\n            case MessageType.Stateless:\n                provider.receiveStateless(readVarString(message.decoder));\n                break;\n            case MessageType.SyncStatus:\n                this.applySyncStatusMessage(provider, readVarInt(message.decoder) === 1);\n                break;\n            case MessageType.CLOSE:\n                // eslint-disable-next-line no-case-declarations\n                const event = {\n                    code: 1000,\n                    reason: readVarString(message.decoder),\n                    // @ts-ignore\n                    target: provider.configuration.websocketProvider.webSocket,\n                    type: 'close',\n                };\n                provider.onClose();\n                provider.configuration.onClose({ event });\n                provider.forwardClose(event);\n                break;\n            default:\n                throw new Error(`Can’t apply message of unknown type: ${type}`);\n        }\n        // Reply\n        if (message.length() > emptyMessageLength + 1) { // length of documentName (considered in emptyMessageLength plus length of yjs sync type, set in applySyncMessage)\n            // @ts-ignore\n            provider.send(OutgoingMessage, { encoder: message.encoder });\n        }\n    }\n    applySyncMessage(provider, emitSynced) {\n        const { message } = this;\n        message.writeVarUint(MessageType.Sync);\n        // Apply update\n        const syncMessageType = readSyncMessage(message.decoder, message.encoder, provider.document, provider);\n        // Synced once we receive Step2\n        if (emitSynced && syncMessageType === messageYjsSyncStep2) {\n            provider.synced = true;\n        }\n    }\n    applySyncStatusMessage(provider, applied) {\n        if (applied) {\n            provider.decrementUnsyncedChanges();\n        }\n    }\n    applyAwarenessMessage(provider) {\n        if (!provider.awareness)\n            return;\n        const { message } = this;\n        applyAwarenessUpdate(provider.awareness, message.readVarUint8Array(), provider);\n    }\n    applyAuthMessage(provider) {\n        const { message } = this;\n        (0,_hocuspocus_common__WEBPACK_IMPORTED_MODULE_0__.readAuthMessage)(message.decoder, provider.permissionDeniedHandler.bind(provider), provider.authenticatedHandler.bind(provider));\n    }\n    applyQueryAwarenessMessage(provider) {\n        if (!provider.awareness)\n            return;\n        const { message } = this;\n        message.writeVarUint(MessageType.Awareness);\n        message.writeVarUint8Array(encodeAwarenessUpdate(provider.awareness, Array.from(provider.awareness.getStates().keys())));\n    }\n}\n\nclass MessageSender {\n    constructor(Message, args = {}) {\n        this.message = new Message();\n        this.encoder = this.message.get(args);\n    }\n    create() {\n        return toUint8Array(this.encoder);\n    }\n    send(webSocket) {\n        webSocket === null || webSocket === void 0 ? void 0 : webSocket.send(this.create());\n    }\n}\n\nclass AuthenticationMessage extends OutgoingMessage {\n    constructor() {\n        super(...arguments);\n        this.type = MessageType.Auth;\n        this.description = 'Authentication';\n    }\n    get(args) {\n        if (typeof args.token === 'undefined') {\n            throw new Error('The authentication message requires `token` as an argument.');\n        }\n        writeVarString(this.encoder, args.documentName);\n        writeVarUint(this.encoder, this.type);\n        (0,_hocuspocus_common__WEBPACK_IMPORTED_MODULE_0__.writeAuthentication)(this.encoder, args.token);\n        return this.encoder;\n    }\n}\n\nclass AwarenessMessage extends OutgoingMessage {\n    constructor() {\n        super(...arguments);\n        this.type = MessageType.Awareness;\n        this.description = 'Awareness states update';\n    }\n    get(args) {\n        if (typeof args.awareness === 'undefined') {\n            throw new Error('The awareness message requires awareness as an argument');\n        }\n        if (typeof args.clients === 'undefined') {\n            throw new Error('The awareness message requires clients as an argument');\n        }\n        writeVarString(this.encoder, args.documentName);\n        writeVarUint(this.encoder, this.type);\n        let awarenessUpdate;\n        if (args.states === undefined) {\n            awarenessUpdate = encodeAwarenessUpdate(args.awareness, args.clients);\n        }\n        else {\n            awarenessUpdate = encodeAwarenessUpdate(args.awareness, args.clients, args.states);\n        }\n        writeVarUint8Array(this.encoder, awarenessUpdate);\n        return this.encoder;\n    }\n}\n\nclass StatelessMessage extends OutgoingMessage {\n    constructor() {\n        super(...arguments);\n        this.type = MessageType.Stateless;\n        this.description = 'A stateless message';\n    }\n    get(args) {\n        var _a;\n        writeVarString(this.encoder, args.documentName);\n        writeVarUint(this.encoder, this.type);\n        writeVarString(this.encoder, (_a = args.payload) !== null && _a !== void 0 ? _a : '');\n        return this.encoder;\n    }\n}\n\nclass SyncStepOneMessage extends OutgoingMessage {\n    constructor() {\n        super(...arguments);\n        this.type = MessageType.Sync;\n        this.description = 'First sync step';\n    }\n    get(args) {\n        if (typeof args.document === 'undefined') {\n            throw new Error('The sync step one message requires document as an argument');\n        }\n        writeVarString(this.encoder, args.documentName);\n        writeVarUint(this.encoder, this.type);\n        writeSyncStep1(this.encoder, args.document);\n        return this.encoder;\n    }\n}\n\nclass UpdateMessage extends OutgoingMessage {\n    constructor() {\n        super(...arguments);\n        this.type = MessageType.Sync;\n        this.description = 'A document update';\n    }\n    get(args) {\n        writeVarString(this.encoder, args.documentName);\n        writeVarUint(this.encoder, this.type);\n        writeUpdate(this.encoder, args.update);\n        return this.encoder;\n    }\n}\n\nclass AwarenessError extends Error {\n    constructor() {\n        super(...arguments);\n        this.code = 1001;\n    }\n}\nclass HocuspocusProvider extends EventEmitter {\n    constructor(configuration) {\n        var _a, _b, _c;\n        super();\n        this.configuration = {\n            name: '',\n            // @ts-ignore\n            document: undefined,\n            // @ts-ignore\n            awareness: undefined,\n            token: null,\n            forceSyncInterval: false,\n            onAuthenticated: () => null,\n            onAuthenticationFailed: () => null,\n            onOpen: () => null,\n            onConnect: () => null,\n            onMessage: () => null,\n            onOutgoingMessage: () => null,\n            onSynced: () => null,\n            onDisconnect: () => null,\n            onClose: () => null,\n            onDestroy: () => null,\n            onAwarenessUpdate: () => null,\n            onAwarenessChange: () => null,\n            onStateless: () => null,\n            onUnsyncedChanges: () => null,\n        };\n        this.isSynced = false;\n        this.unsyncedChanges = 0;\n        this.isAuthenticated = false;\n        this.authorizedScope = undefined;\n        // @internal\n        this.manageSocket = false;\n        this._isAttached = false;\n        this.intervals = {\n            forceSync: null,\n        };\n        this.boundDocumentUpdateHandler = this.documentUpdateHandler.bind(this);\n        this.boundAwarenessUpdateHandler = this.awarenessUpdateHandler.bind(this);\n        this.boundPageHide = this.pageHide.bind(this);\n        this.boundOnOpen = this.onOpen.bind(this);\n        this.boundOnClose = this.onClose.bind(this);\n        this.forwardConnect = (e) => this.emit('connect', e);\n        this.forwardClose = (e) => this.emit('close', e);\n        this.forwardDisconnect = (e) => this.emit('disconnect', e);\n        this.forwardDestroy = (e) => this.emit('destroy', e);\n        this.setConfiguration(configuration);\n        this.configuration.document = configuration.document ? configuration.document : new yjs__WEBPACK_IMPORTED_MODULE_2__.Doc();\n        this.configuration.awareness = configuration.awareness !== undefined ? configuration.awareness : new Awareness(this.document);\n        this.on('open', this.configuration.onOpen);\n        this.on('message', this.configuration.onMessage);\n        this.on('outgoingMessage', this.configuration.onOutgoingMessage);\n        this.on('synced', this.configuration.onSynced);\n        this.on('destroy', this.configuration.onDestroy);\n        this.on('awarenessUpdate', this.configuration.onAwarenessUpdate);\n        this.on('awarenessChange', this.configuration.onAwarenessChange);\n        this.on('stateless', this.configuration.onStateless);\n        this.on('unsyncedChanges', this.configuration.onUnsyncedChanges);\n        this.on('authenticated', this.configuration.onAuthenticated);\n        this.on('authenticationFailed', this.configuration.onAuthenticationFailed);\n        (_a = this.awareness) === null || _a === void 0 ? void 0 : _a.on('update', () => {\n            this.emit('awarenessUpdate', { states: (0,_hocuspocus_common__WEBPACK_IMPORTED_MODULE_0__.awarenessStatesToArray)(this.awareness.getStates()) });\n        });\n        (_b = this.awareness) === null || _b === void 0 ? void 0 : _b.on('change', () => {\n            this.emit('awarenessChange', { states: (0,_hocuspocus_common__WEBPACK_IMPORTED_MODULE_0__.awarenessStatesToArray)(this.awareness.getStates()) });\n        });\n        this.document.on('update', this.boundDocumentUpdateHandler);\n        (_c = this.awareness) === null || _c === void 0 ? void 0 : _c.on('update', this.boundAwarenessUpdateHandler);\n        this.registerEventListeners();\n        if (this.configuration.forceSyncInterval\n            && typeof this.configuration.forceSyncInterval === 'number') {\n            this.intervals.forceSync = setInterval(this.forceSync.bind(this), this.configuration.forceSyncInterval);\n        }\n        if (this.manageSocket) {\n            this.attach();\n        }\n    }\n    setConfiguration(configuration = {}) {\n        if (!configuration.websocketProvider) {\n            const websocketProviderConfig = configuration;\n            this.manageSocket = true;\n            this.configuration.websocketProvider = new HocuspocusProviderWebsocket({\n                url: websocketProviderConfig.url,\n            });\n        }\n        this.configuration = { ...this.configuration, ...configuration };\n    }\n    get document() {\n        return this.configuration.document;\n    }\n    get isAttached() {\n        return this._isAttached;\n    }\n    get awareness() {\n        return this.configuration.awareness;\n    }\n    get hasUnsyncedChanges() {\n        return this.unsyncedChanges > 0;\n    }\n    resetUnsyncedChanges() {\n        this.unsyncedChanges = 1;\n        this.emit('unsyncedChanges', { number: this.unsyncedChanges });\n    }\n    incrementUnsyncedChanges() {\n        this.unsyncedChanges += 1;\n        this.emit('unsyncedChanges', { number: this.unsyncedChanges });\n    }\n    decrementUnsyncedChanges() {\n        if (this.unsyncedChanges > 0) {\n            this.unsyncedChanges -= 1;\n        }\n        if (this.unsyncedChanges === 0) {\n            this.synced = true;\n        }\n        this.emit('unsyncedChanges', { number: this.unsyncedChanges });\n    }\n    forceSync() {\n        this.resetUnsyncedChanges();\n        this.send(SyncStepOneMessage, { document: this.document, documentName: this.configuration.name });\n    }\n    pageHide() {\n        if (this.awareness) {\n            removeAwarenessStates(this.awareness, [this.document.clientID], 'page hide');\n        }\n    }\n    registerEventListeners() {\n        if (typeof window === 'undefined' || !('addEventListener' in window)) {\n            return;\n        }\n        window.addEventListener('pagehide', this.boundPageHide);\n    }\n    sendStateless(payload) {\n        this.send(StatelessMessage, { documentName: this.configuration.name, payload });\n    }\n    documentUpdateHandler(update, origin) {\n        if (origin === this) {\n            return;\n        }\n        this.incrementUnsyncedChanges();\n        this.send(UpdateMessage, { update, documentName: this.configuration.name });\n    }\n    awarenessUpdateHandler({ added, updated, removed }, origin) {\n        const changedClients = added.concat(updated).concat(removed);\n        this.send(AwarenessMessage, {\n            awareness: this.awareness,\n            clients: changedClients,\n            documentName: this.configuration.name,\n        });\n    }\n    /**\n     * Indicates whether a first handshake with the server has been established\n     *\n     * Note: this does not mean all updates from the client have been persisted to the backend. For this,\n     * use `hasUnsyncedChanges`.\n     */\n    get synced() {\n        return this.isSynced;\n    }\n    set synced(state) {\n        if (this.isSynced === state) {\n            return;\n        }\n        this.isSynced = state;\n        if (state) {\n            this.emit('synced', { state });\n        }\n    }\n    receiveStateless(payload) {\n        this.emit('stateless', { payload });\n    }\n    // not needed, but provides backward compatibility with e.g. lexical/yjs\n    async connect() {\n        if (this.manageSocket) {\n            return this.configuration.websocketProvider.connect();\n        }\n        console.warn('HocuspocusProvider::connect() is deprecated and does not do anything. Please connect/disconnect on the websocketProvider, or attach/deattach providers.');\n    }\n    disconnect() {\n        if (this.manageSocket) {\n            return this.configuration.websocketProvider.disconnect();\n        }\n        console.warn('HocuspocusProvider::disconnect() is deprecated and does not do anything. Please connect/disconnect on the websocketProvider, or attach/deattach providers.');\n    }\n    async onOpen(event) {\n        this.isAuthenticated = false;\n        this.emit('open', { event });\n        let token;\n        try {\n            token = await this.getToken();\n        }\n        catch (error) {\n            this.permissionDeniedHandler(`Failed to get token: ${error}`);\n            return;\n        }\n        this.send(AuthenticationMessage, {\n            token: token !== null && token !== void 0 ? token : '',\n            documentName: this.configuration.name,\n        });\n        this.startSync();\n    }\n    async getToken() {\n        if (typeof this.configuration.token === 'function') {\n            const token = await this.configuration.token();\n            return token;\n        }\n        return this.configuration.token;\n    }\n    startSync() {\n        this.resetUnsyncedChanges();\n        this.send(SyncStepOneMessage, { document: this.document, documentName: this.configuration.name });\n        if (this.awareness && this.awareness.getLocalState() !== null) {\n            this.send(AwarenessMessage, {\n                awareness: this.awareness,\n                clients: [this.document.clientID],\n                documentName: this.configuration.name,\n            });\n        }\n    }\n    send(message, args) {\n        if (!this._isAttached)\n            return;\n        const messageSender = new MessageSender(message, args);\n        this.emit('outgoingMessage', { message: messageSender.message });\n        messageSender.send(this.configuration.websocketProvider);\n    }\n    onMessage(event) {\n        const message = new IncomingMessage(event.data);\n        const documentName = message.readVarString();\n        message.writeVarString(documentName);\n        this.emit('message', { event, message: new IncomingMessage(event.data) });\n        new MessageReceiver(message).apply(this, true);\n    }\n    onClose() {\n        this.isAuthenticated = false;\n        this.synced = false;\n        // update awareness (all users except local left)\n        if (this.awareness) {\n            removeAwarenessStates(this.awareness, Array.from(this.awareness.getStates().keys()).filter(client => client !== this.document.clientID), this);\n        }\n    }\n    destroy() {\n        this.emit('destroy');\n        if (this.intervals.forceSync) {\n            clearInterval(this.intervals.forceSync);\n        }\n        if (this.awareness) {\n            removeAwarenessStates(this.awareness, [this.document.clientID], 'provider destroy');\n            this.awareness.off('update', this.boundAwarenessUpdateHandler);\n            this.awareness.destroy();\n        }\n        this.document.off('update', this.boundDocumentUpdateHandler);\n        this.removeAllListeners();\n        this.detach();\n        if (this.manageSocket) {\n            this.configuration.websocketProvider.destroy();\n        }\n        if (typeof window === 'undefined' || !('removeEventListener' in window)) {\n            return;\n        }\n        window.removeEventListener('pagehide', this.boundPageHide);\n    }\n    detach() {\n        this.configuration.websocketProvider.off('connect', this.configuration.onConnect);\n        this.configuration.websocketProvider.off('connect', this.forwardConnect);\n        this.configuration.websocketProvider.off('open', this.boundOnOpen);\n        this.configuration.websocketProvider.off('close', this.boundOnClose);\n        this.configuration.websocketProvider.off('close', this.configuration.onClose);\n        this.configuration.websocketProvider.off('close', this.forwardClose);\n        this.configuration.websocketProvider.off('disconnect', this.configuration.onDisconnect);\n        this.configuration.websocketProvider.off('disconnect', this.forwardDisconnect);\n        this.configuration.websocketProvider.off('destroy', this.configuration.onDestroy);\n        this.configuration.websocketProvider.off('destroy', this.forwardDestroy);\n        this.configuration.websocketProvider.detach(this);\n        this._isAttached = false;\n    }\n    attach() {\n        if (this._isAttached)\n            return;\n        this.configuration.websocketProvider.on('connect', this.configuration.onConnect);\n        this.configuration.websocketProvider.on('connect', this.forwardConnect);\n        this.configuration.websocketProvider.on('open', this.boundOnOpen);\n        this.configuration.websocketProvider.on('close', this.boundOnClose);\n        this.configuration.websocketProvider.on('close', this.configuration.onClose);\n        this.configuration.websocketProvider.on('close', this.forwardClose);\n        this.configuration.websocketProvider.on('disconnect', this.configuration.onDisconnect);\n        this.configuration.websocketProvider.on('disconnect', this.forwardDisconnect);\n        this.configuration.websocketProvider.on('destroy', this.configuration.onDestroy);\n        this.configuration.websocketProvider.on('destroy', this.forwardDestroy);\n        this.configuration.websocketProvider.attach(this);\n        this._isAttached = true;\n    }\n    permissionDeniedHandler(reason) {\n        this.emit('authenticationFailed', { reason });\n        this.isAuthenticated = false;\n    }\n    authenticatedHandler(scope) {\n        this.isAuthenticated = true;\n        this.authorizedScope = scope;\n        this.emit('authenticated', { scope });\n    }\n    setAwarenessField(key, value) {\n        if (!this.awareness) {\n            throw new AwarenessError(`Cannot set awareness field \"${key}\" to ${JSON.stringify(value)}. You have disabled Awareness for this provider by explicitly passing awareness: null in the provider configuration.`);\n        }\n        this.awareness.setLocalStateField(key, value);\n    }\n}\n\n\n//# sourceMappingURL=hocuspocus-provider.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGhvY3VzcG9jdXMvcHJvdmlkZXIvZGlzdC9ob2N1c3BvY3VzLXByb3ZpZGVyLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFpSDtBQUN4RjtBQUNpQjs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDBCQUEwQjtBQUNyQyxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQyxhQUFhOztBQUVoRDtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkZBQTZGLDhCQUE4Qjs7QUFFM0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0EsdUNBQXVDLGdDQUFnQztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsaURBQWlEO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLElBQUksT0FBTyxzQkFBc0I7QUFDckc7QUFDQTtBQUNBO0FBQ0E7O0FBRXlHO0FBQ3pHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGxpdmVibG9ja3MtZXhhbXBsZXMvbmV4dGpzLXlqcy1ibG9ja25vdGUtYWR2YW5jZWQvLi9ub2RlX21vZHVsZXMvQGhvY3VzcG9jdXMvcHJvdmlkZXIvZGlzdC9ob2N1c3BvY3VzLXByb3ZpZGVyLmVzbS5qcz9hNjBkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFdzUmVhZHlTdGF0ZXMsIHJlYWRBdXRoTWVzc2FnZSwgd3JpdGVBdXRoZW50aWNhdGlvbiwgYXdhcmVuZXNzU3RhdGVzVG9BcnJheSB9IGZyb20gJ0Bob2N1c3BvY3VzL2NvbW1vbic7XG5pbXBvcnQgKiBhcyBZIGZyb20gJ3lqcyc7XG5pbXBvcnQgeyByZXRyeSB9IGZyb20gJ0BsaWZlb21pYy9hdHRlbXB0JztcblxuLyoqXG4gKiBDb21tb24gTWF0aCBleHByZXNzaW9ucy5cbiAqXG4gKiBAbW9kdWxlIG1hdGhcbiAqL1xuXG5jb25zdCBmbG9vciA9IE1hdGguZmxvb3I7XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gYVxuICogQHBhcmFtIHtudW1iZXJ9IGJcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIHNtYWxsZXIgZWxlbWVudCBvZiBhIGFuZCBiXG4gKi9cbmNvbnN0IG1pbiA9IChhLCBiKSA9PiBhIDwgYiA/IGEgOiBiO1xuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IGFcbiAqIEBwYXJhbSB7bnVtYmVyfSBiXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBiaWdnZXIgZWxlbWVudCBvZiBhIGFuZCBiXG4gKi9cbmNvbnN0IG1heCA9IChhLCBiKSA9PiBhID4gYiA/IGEgOiBiO1xuXG4vKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuY29uc3QgQklUNyA9IDY0O1xuY29uc3QgQklUOCA9IDEyODtcbmNvbnN0IEJJVFM2ID0gNjM7XG5jb25zdCBCSVRTNyA9IDEyNztcblxuLyoqXG4gKiBVdGlsaXR5IGhlbHBlcnMgZm9yIHdvcmtpbmcgd2l0aCBudW1iZXJzLlxuICpcbiAqIEBtb2R1bGUgbnVtYmVyXG4gKi9cblxuXG5jb25zdCBNQVhfU0FGRV9JTlRFR0VSID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG5cbi8qKlxuICogVXRpbGl0eSBtb2R1bGUgdG8gd29yayB3aXRoIHNldHMuXG4gKlxuICogQG1vZHVsZSBzZXRcbiAqL1xuXG5jb25zdCBjcmVhdGUkMiA9ICgpID0+IG5ldyBTZXQoKTtcblxuLyoqXG4gKiBVdGlsaXR5IG1vZHVsZSB0byB3b3JrIHdpdGggQXJyYXlzLlxuICpcbiAqIEBtb2R1bGUgYXJyYXlcbiAqL1xuXG5cbi8qKlxuICogVHJhbnNmb3JtcyBzb21ldGhpbmcgYXJyYXktbGlrZSB0byBhbiBhY3R1YWwgQXJyYXkuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtBcnJheUxpa2U8VD58SXRlcmFibGU8VD59IGFycmF5bGlrZVxuICogQHJldHVybiB7VH1cbiAqL1xuY29uc3QgZnJvbSA9IEFycmF5LmZyb207XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHJldHVybiB7VWludDhBcnJheX1cbiAqL1xuY29uc3QgX2VuY29kZVV0ZjhQb2x5ZmlsbCA9IHN0ciA9PiB7XG4gIGNvbnN0IGVuY29kZWRTdHJpbmcgPSB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoc3RyKSk7XG4gIGNvbnN0IGxlbiA9IGVuY29kZWRTdHJpbmcubGVuZ3RoO1xuICBjb25zdCBidWYgPSBuZXcgVWludDhBcnJheShsZW4pO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgYnVmW2ldID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChlbmNvZGVkU3RyaW5nLmNvZGVQb2ludEF0KGkpKTtcbiAgfVxuICByZXR1cm4gYnVmXG59O1xuXG4vKiBjOCBpZ25vcmUgbmV4dCAqL1xuY29uc3QgdXRmOFRleHRFbmNvZGVyID0gLyoqIEB0eXBlIHtUZXh0RW5jb2Rlcn0gKi8gKHR5cGVvZiBUZXh0RW5jb2RlciAhPT0gJ3VuZGVmaW5lZCcgPyBuZXcgVGV4dEVuY29kZXIoKSA6IG51bGwpO1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKi9cbmNvbnN0IF9lbmNvZGVVdGY4TmF0aXZlID0gc3RyID0+IHV0ZjhUZXh0RW5jb2Rlci5lbmNvZGUoc3RyKTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICovXG4vKiBjOCBpZ25vcmUgbmV4dCAqL1xuY29uc3QgZW5jb2RlVXRmOCA9IHV0ZjhUZXh0RW5jb2RlciA/IF9lbmNvZGVVdGY4TmF0aXZlIDogX2VuY29kZVV0ZjhQb2x5ZmlsbDtcblxuLyogYzggaWdub3JlIG5leHQgKi9cbmxldCB1dGY4VGV4dERlY29kZXIgPSB0eXBlb2YgVGV4dERlY29kZXIgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IG5ldyBUZXh0RGVjb2RlcigndXRmLTgnLCB7IGZhdGFsOiB0cnVlLCBpZ25vcmVCT006IHRydWUgfSk7XG5cbi8qIGM4IGlnbm9yZSBzdGFydCAqL1xuaWYgKHV0ZjhUZXh0RGVjb2RlciAmJiB1dGY4VGV4dERlY29kZXIuZGVjb2RlKG5ldyBVaW50OEFycmF5KCkpLmxlbmd0aCA9PT0gMSkge1xuICAvLyBTYWZhcmkgZG9lc24ndCBoYW5kbGUgQk9NIGNvcnJlY3RseS5cbiAgLy8gVGhpcyBmaXhlcyBhIGJ1ZyBpbiBTYWZhcmkgMTMuMC41IHdoZXJlIGl0IHByb2R1Y2VzIGEgQk9NIHRoZSBmaXJzdCB0aW1lIGl0IGlzIGNhbGxlZC5cbiAgLy8gdXRmOFRleHREZWNvZGVyLmRlY29kZShuZXcgVWludDhBcnJheSgpKS5sZW5ndGggPT09IDEgb24gdGhlIGZpcnN0IGNhbGwgYW5kXG4gIC8vIHV0ZjhUZXh0RGVjb2Rlci5kZWNvZGUobmV3IFVpbnQ4QXJyYXkoKSkubGVuZ3RoID09PSAxIG9uIHRoZSBzZWNvbmQgY2FsbFxuICAvLyBBbm90aGVyIGlzc3VlIGlzIHRoYXQgZnJvbSB0aGVuIG9uIG5vIEJPTSBjaGFycyBhcmUgcmVjb2duaXplZCBhbnltb3JlXG4gIC8qIGM4IGlnbm9yZSBuZXh0ICovXG4gIHV0ZjhUZXh0RGVjb2RlciA9IG51bGw7XG59XG5cbi8qKlxuICogRWZmaWNpZW50IHNjaGVtYS1sZXNzIGJpbmFyeSBlbmNvZGluZyB3aXRoIHN1cHBvcnQgZm9yIHZhcmlhYmxlIGxlbmd0aCBlbmNvZGluZy5cbiAqXG4gKiBVc2UgW2xpYjAvZW5jb2RpbmddIHdpdGggW2xpYjAvZGVjb2RpbmddLiBFdmVyeSBlbmNvZGluZyBmdW5jdGlvbiBoYXMgYSBjb3JyZXNwb25kaW5nIGRlY29kaW5nIGZ1bmN0aW9uLlxuICpcbiAqIEVuY29kZXMgbnVtYmVycyBpbiBsaXR0bGUtZW5kaWFuIG9yZGVyIChsZWFzdCB0byBtb3N0IHNpZ25pZmljYW50IGJ5dGUgb3JkZXIpXG4gKiBhbmQgaXMgY29tcGF0aWJsZSB3aXRoIEdvbGFuZydzIGJpbmFyeSBlbmNvZGluZyAoaHR0cHM6Ly9nb2xhbmcub3JnL3BrZy9lbmNvZGluZy9iaW5hcnkvKVxuICogd2hpY2ggaXMgYWxzbyB1c2VkIGluIFByb3RvY29sIEJ1ZmZlcnMuXG4gKlxuICogYGBganNcbiAqIC8vIGVuY29kaW5nIHN0ZXBcbiAqIGNvbnN0IGVuY29kZXIgPSBlbmNvZGluZy5jcmVhdGVFbmNvZGVyKClcbiAqIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLCAyNTYpXG4gKiBlbmNvZGluZy53cml0ZVZhclN0cmluZyhlbmNvZGVyLCAnSGVsbG8gd29ybGQhJylcbiAqIGNvbnN0IGJ1ZiA9IGVuY29kaW5nLnRvVWludDhBcnJheShlbmNvZGVyKVxuICogYGBgXG4gKlxuICogYGBganNcbiAqIC8vIGRlY29kaW5nIHN0ZXBcbiAqIGNvbnN0IGRlY29kZXIgPSBkZWNvZGluZy5jcmVhdGVEZWNvZGVyKGJ1ZilcbiAqIGRlY29kaW5nLnJlYWRWYXJVaW50KGRlY29kZXIpIC8vID0+IDI1NlxuICogZGVjb2RpbmcucmVhZFZhclN0cmluZyhkZWNvZGVyKSAvLyA9PiAnSGVsbG8gd29ybGQhJ1xuICogZGVjb2RpbmcuaGFzQ29udGVudChkZWNvZGVyKSAvLyA9PiBmYWxzZSAtIGFsbCBkYXRhIGlzIHJlYWRcbiAqIGBgYFxuICpcbiAqIEBtb2R1bGUgZW5jb2RpbmdcbiAqL1xuXG5cbi8qKlxuICogQSBCaW5hcnlFbmNvZGVyIGhhbmRsZXMgdGhlIGVuY29kaW5nIHRvIGFuIFVpbnQ4QXJyYXkuXG4gKi9cbmNsYXNzIEVuY29kZXIge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgdGhpcy5jcG9zID0gMDtcbiAgICB0aGlzLmNidWYgPSBuZXcgVWludDhBcnJheSgxMDApO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheTxVaW50OEFycmF5Pn1cbiAgICAgKi9cbiAgICB0aGlzLmJ1ZnMgPSBbXTtcbiAgfVxufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQHJldHVybiB7RW5jb2Rlcn1cbiAqL1xuY29uc3QgY3JlYXRlRW5jb2RlciA9ICgpID0+IG5ldyBFbmNvZGVyKCk7XG5cbi8qKlxuICogVGhlIGN1cnJlbnQgbGVuZ3RoIG9mIHRoZSBlbmNvZGVkIGRhdGEuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuY29uc3QgbGVuZ3RoJDEgPSBlbmNvZGVyID0+IHtcbiAgbGV0IGxlbiA9IGVuY29kZXIuY3BvcztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbmNvZGVyLmJ1ZnMubGVuZ3RoOyBpKyspIHtcbiAgICBsZW4gKz0gZW5jb2Rlci5idWZzW2ldLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gbGVuXG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybSB0byBVaW50OEFycmF5LlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyXG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fSBUaGUgY3JlYXRlZCBBcnJheUJ1ZmZlci5cbiAqL1xuY29uc3QgdG9VaW50OEFycmF5ID0gZW5jb2RlciA9PiB7XG4gIGNvbnN0IHVpbnQ4YXJyID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoJDEoZW5jb2RlcikpO1xuICBsZXQgY3VyUG9zID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbmNvZGVyLmJ1ZnMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBkID0gZW5jb2Rlci5idWZzW2ldO1xuICAgIHVpbnQ4YXJyLnNldChkLCBjdXJQb3MpO1xuICAgIGN1clBvcyArPSBkLmxlbmd0aDtcbiAgfVxuICB1aW50OGFyci5zZXQobmV3IFVpbnQ4QXJyYXkoZW5jb2Rlci5jYnVmLmJ1ZmZlciwgMCwgZW5jb2Rlci5jcG9zKSwgY3VyUG9zKTtcbiAgcmV0dXJuIHVpbnQ4YXJyXG59O1xuXG4vKipcbiAqIFdyaXRlIG9uZSBieXRlIHRvIHRoZSBlbmNvZGVyLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtIFRoZSBieXRlIHRoYXQgaXMgdG8gYmUgZW5jb2RlZC5cbiAqL1xuY29uc3Qgd3JpdGUgPSAoZW5jb2RlciwgbnVtKSA9PiB7XG4gIGNvbnN0IGJ1ZmZlckxlbiA9IGVuY29kZXIuY2J1Zi5sZW5ndGg7XG4gIGlmIChlbmNvZGVyLmNwb3MgPT09IGJ1ZmZlckxlbikge1xuICAgIGVuY29kZXIuYnVmcy5wdXNoKGVuY29kZXIuY2J1Zik7XG4gICAgZW5jb2Rlci5jYnVmID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyTGVuICogMik7XG4gICAgZW5jb2Rlci5jcG9zID0gMDtcbiAgfVxuICBlbmNvZGVyLmNidWZbZW5jb2Rlci5jcG9zKytdID0gbnVtO1xufTtcblxuLyoqXG4gKiBXcml0ZSBhIHZhcmlhYmxlIGxlbmd0aCB1bnNpZ25lZCBpbnRlZ2VyLiBNYXggZW5jb2RhYmxlIGludGVnZXIgaXMgMl41My5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtudW1iZXJ9IG51bSBUaGUgbnVtYmVyIHRoYXQgaXMgdG8gYmUgZW5jb2RlZC5cbiAqL1xuY29uc3Qgd3JpdGVWYXJVaW50ID0gKGVuY29kZXIsIG51bSkgPT4ge1xuICB3aGlsZSAobnVtID4gQklUUzcpIHtcbiAgICB3cml0ZShlbmNvZGVyLCBCSVQ4IHwgKEJJVFM3ICYgbnVtKSk7XG4gICAgbnVtID0gZmxvb3IobnVtIC8gMTI4KTsgLy8gc2hpZnQgPj4+IDdcbiAgfVxuICB3cml0ZShlbmNvZGVyLCBCSVRTNyAmIG51bSk7XG59O1xuXG4vKipcbiAqIEEgY2FjaGUgdG8gc3RvcmUgc3RyaW5ncyB0ZW1wb3JhcmlseVxuICovXG5jb25zdCBfc3RyQnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoMzAwMDApO1xuY29uc3QgX21heFN0ckJTaXplID0gX3N0ckJ1ZmZlci5sZW5ndGggLyAzO1xuXG4vKipcbiAqIFdyaXRlIGEgdmFyaWFibGUgbGVuZ3RoIHN0cmluZy5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgc3RyaW5nIHRoYXQgaXMgdG8gYmUgZW5jb2RlZC5cbiAqL1xuY29uc3QgX3dyaXRlVmFyU3RyaW5nTmF0aXZlID0gKGVuY29kZXIsIHN0cikgPT4ge1xuICBpZiAoc3RyLmxlbmd0aCA8IF9tYXhTdHJCU2l6ZSkge1xuICAgIC8vIFdlIGNhbiBlbmNvZGUgdGhlIHN0cmluZyBpbnRvIHRoZSBleGlzdGluZyBidWZmZXJcbiAgICAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuICAgIGNvbnN0IHdyaXR0ZW4gPSB1dGY4VGV4dEVuY29kZXIuZW5jb2RlSW50byhzdHIsIF9zdHJCdWZmZXIpLndyaXR0ZW4gfHwgMDtcbiAgICB3cml0ZVZhclVpbnQoZW5jb2Rlciwgd3JpdHRlbik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3cml0dGVuOyBpKyspIHtcbiAgICAgIHdyaXRlKGVuY29kZXIsIF9zdHJCdWZmZXJbaV0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB3cml0ZVZhclVpbnQ4QXJyYXkoZW5jb2RlciwgZW5jb2RlVXRmOChzdHIpKTtcbiAgfVxufTtcblxuLyoqXG4gKiBXcml0ZSBhIHZhcmlhYmxlIGxlbmd0aCBzdHJpbmcuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHN0cmluZyB0aGF0IGlzIHRvIGJlIGVuY29kZWQuXG4gKi9cbmNvbnN0IF93cml0ZVZhclN0cmluZ1BvbHlmaWxsID0gKGVuY29kZXIsIHN0cikgPT4ge1xuICBjb25zdCBlbmNvZGVkU3RyaW5nID0gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHN0cikpO1xuICBjb25zdCBsZW4gPSBlbmNvZGVkU3RyaW5nLmxlbmd0aDtcbiAgd3JpdGVWYXJVaW50KGVuY29kZXIsIGxlbik7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICB3cml0ZShlbmNvZGVyLCAvKiogQHR5cGUge251bWJlcn0gKi8gKGVuY29kZWRTdHJpbmcuY29kZVBvaW50QXQoaSkpKTtcbiAgfVxufTtcblxuLyoqXG4gKiBXcml0ZSBhIHZhcmlhYmxlIGxlbmd0aCBzdHJpbmcuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHN0cmluZyB0aGF0IGlzIHRvIGJlIGVuY29kZWQuXG4gKi9cbi8qIGM4IGlnbm9yZSBuZXh0ICovXG5jb25zdCB3cml0ZVZhclN0cmluZyA9ICh1dGY4VGV4dEVuY29kZXIgJiYgLyoqIEB0eXBlIHthbnl9ICovICh1dGY4VGV4dEVuY29kZXIpLmVuY29kZUludG8pID8gX3dyaXRlVmFyU3RyaW5nTmF0aXZlIDogX3dyaXRlVmFyU3RyaW5nUG9seWZpbGw7XG5cbi8qKlxuICogQXBwZW5kIGZpeGVkLWxlbmd0aCBVaW50OEFycmF5IHRvIHRoZSBlbmNvZGVyLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVpbnQ4QXJyYXlcbiAqL1xuY29uc3Qgd3JpdGVVaW50OEFycmF5ID0gKGVuY29kZXIsIHVpbnQ4QXJyYXkpID0+IHtcbiAgY29uc3QgYnVmZmVyTGVuID0gZW5jb2Rlci5jYnVmLmxlbmd0aDtcbiAgY29uc3QgY3BvcyA9IGVuY29kZXIuY3BvcztcbiAgY29uc3QgbGVmdENvcHlMZW4gPSBtaW4oYnVmZmVyTGVuIC0gY3BvcywgdWludDhBcnJheS5sZW5ndGgpO1xuICBjb25zdCByaWdodENvcHlMZW4gPSB1aW50OEFycmF5Lmxlbmd0aCAtIGxlZnRDb3B5TGVuO1xuICBlbmNvZGVyLmNidWYuc2V0KHVpbnQ4QXJyYXkuc3ViYXJyYXkoMCwgbGVmdENvcHlMZW4pLCBjcG9zKTtcbiAgZW5jb2Rlci5jcG9zICs9IGxlZnRDb3B5TGVuO1xuICBpZiAocmlnaHRDb3B5TGVuID4gMCkge1xuICAgIC8vIFN0aWxsIHNvbWV0aGluZyB0byB3cml0ZSwgd3JpdGUgcmlnaHQgaGFsZi4uXG4gICAgLy8gQXBwZW5kIG5ldyBidWZmZXJcbiAgICBlbmNvZGVyLmJ1ZnMucHVzaChlbmNvZGVyLmNidWYpO1xuICAgIC8vIG11c3QgaGF2ZSBhdCBsZWFzdCBzaXplIG9mIHJlbWFpbmluZyBidWZmZXJcbiAgICBlbmNvZGVyLmNidWYgPSBuZXcgVWludDhBcnJheShtYXgoYnVmZmVyTGVuICogMiwgcmlnaHRDb3B5TGVuKSk7XG4gICAgLy8gY29weSBhcnJheVxuICAgIGVuY29kZXIuY2J1Zi5zZXQodWludDhBcnJheS5zdWJhcnJheShsZWZ0Q29weUxlbikpO1xuICAgIGVuY29kZXIuY3BvcyA9IHJpZ2h0Q29weUxlbjtcbiAgfVxufTtcblxuLyoqXG4gKiBBcHBlbmQgYW4gVWludDhBcnJheSB0byBFbmNvZGVyLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVpbnQ4QXJyYXlcbiAqL1xuY29uc3Qgd3JpdGVWYXJVaW50OEFycmF5ID0gKGVuY29kZXIsIHVpbnQ4QXJyYXkpID0+IHtcbiAgd3JpdGVWYXJVaW50KGVuY29kZXIsIHVpbnQ4QXJyYXkuYnl0ZUxlbmd0aCk7XG4gIHdyaXRlVWludDhBcnJheShlbmNvZGVyLCB1aW50OEFycmF5KTtcbn07XG5cbi8qKlxuICogRXJyb3IgaGVscGVycy5cbiAqXG4gKiBAbW9kdWxlIGVycm9yXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc1xuICogQHJldHVybiB7RXJyb3J9XG4gKi9cbi8qIGM4IGlnbm9yZSBuZXh0ICovXG5jb25zdCBjcmVhdGUkMSA9IHMgPT4gbmV3IEVycm9yKHMpO1xuXG4vKipcbiAqIEVmZmljaWVudCBzY2hlbWEtbGVzcyBiaW5hcnkgZGVjb2Rpbmcgd2l0aCBzdXBwb3J0IGZvciB2YXJpYWJsZSBsZW5ndGggZW5jb2RpbmcuXG4gKlxuICogVXNlIFtsaWIwL2RlY29kaW5nXSB3aXRoIFtsaWIwL2VuY29kaW5nXS4gRXZlcnkgZW5jb2RpbmcgZnVuY3Rpb24gaGFzIGEgY29ycmVzcG9uZGluZyBkZWNvZGluZyBmdW5jdGlvbi5cbiAqXG4gKiBFbmNvZGVzIG51bWJlcnMgaW4gbGl0dGxlLWVuZGlhbiBvcmRlciAobGVhc3QgdG8gbW9zdCBzaWduaWZpY2FudCBieXRlIG9yZGVyKVxuICogYW5kIGlzIGNvbXBhdGlibGUgd2l0aCBHb2xhbmcncyBiaW5hcnkgZW5jb2RpbmcgKGh0dHBzOi8vZ29sYW5nLm9yZy9wa2cvZW5jb2RpbmcvYmluYXJ5LylcbiAqIHdoaWNoIGlzIGFsc28gdXNlZCBpbiBQcm90b2NvbCBCdWZmZXJzLlxuICpcbiAqIGBgYGpzXG4gKiAvLyBlbmNvZGluZyBzdGVwXG4gKiBjb25zdCBlbmNvZGVyID0gZW5jb2RpbmcuY3JlYXRlRW5jb2RlcigpXG4gKiBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgMjU2KVxuICogZW5jb2Rpbmcud3JpdGVWYXJTdHJpbmcoZW5jb2RlciwgJ0hlbGxvIHdvcmxkIScpXG4gKiBjb25zdCBidWYgPSBlbmNvZGluZy50b1VpbnQ4QXJyYXkoZW5jb2RlcilcbiAqIGBgYFxuICpcbiAqIGBgYGpzXG4gKiAvLyBkZWNvZGluZyBzdGVwXG4gKiBjb25zdCBkZWNvZGVyID0gZGVjb2RpbmcuY3JlYXRlRGVjb2RlcihidWYpXG4gKiBkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyKSAvLyA9PiAyNTZcbiAqIGRlY29kaW5nLnJlYWRWYXJTdHJpbmcoZGVjb2RlcikgLy8gPT4gJ0hlbGxvIHdvcmxkISdcbiAqIGRlY29kaW5nLmhhc0NvbnRlbnQoZGVjb2RlcikgLy8gPT4gZmFsc2UgLSBhbGwgZGF0YSBpcyByZWFkXG4gKiBgYGBcbiAqXG4gKiBAbW9kdWxlIGRlY29kaW5nXG4gKi9cblxuXG5jb25zdCBlcnJvclVuZXhwZWN0ZWRFbmRPZkFycmF5ID0gY3JlYXRlJDEoJ1VuZXhwZWN0ZWQgZW5kIG9mIGFycmF5Jyk7XG5jb25zdCBlcnJvckludGVnZXJPdXRPZlJhbmdlID0gY3JlYXRlJDEoJ0ludGVnZXIgb3V0IG9mIFJhbmdlJyk7XG5cbi8qKlxuICogQSBEZWNvZGVyIGhhbmRsZXMgdGhlIGRlY29kaW5nIG9mIGFuIFVpbnQ4QXJyYXkuXG4gKi9cbmNsYXNzIERlY29kZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtVaW50OEFycmF5fSB1aW50OEFycmF5IEJpbmFyeSBkYXRhIHRvIGRlY29kZVxuICAgKi9cbiAgY29uc3RydWN0b3IgKHVpbnQ4QXJyYXkpIHtcbiAgICAvKipcbiAgICAgKiBEZWNvZGluZyB0YXJnZXQuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7VWludDhBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmFyciA9IHVpbnQ4QXJyYXk7XG4gICAgLyoqXG4gICAgICogQ3VycmVudCBkZWNvZGluZyBwb3NpdGlvbi5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5wb3MgPSAwO1xuICB9XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVpbnQ4QXJyYXlcbiAqIEByZXR1cm4ge0RlY29kZXJ9XG4gKi9cbmNvbnN0IGNyZWF0ZURlY29kZXIgPSB1aW50OEFycmF5ID0+IG5ldyBEZWNvZGVyKHVpbnQ4QXJyYXkpO1xuXG4vKipcbiAqIENyZWF0ZSBhbiBVaW50OEFycmF5IHZpZXcgb2YgdGhlIG5leHQgYGxlbmAgYnl0ZXMgYW5kIGFkdmFuY2UgdGhlIHBvc2l0aW9uIGJ5IGBsZW5gLlxuICpcbiAqIEltcG9ydGFudDogVGhlIFVpbnQ4QXJyYXkgc3RpbGwgcG9pbnRzIHRvIHRoZSB1bmRlcmx5aW5nIEFycmF5QnVmZmVyLiBNYWtlIHN1cmUgdG8gZGlzY2FyZCB0aGUgcmVzdWx0IGFzIHNvb24gYXMgcG9zc2libGUgdG8gcHJldmVudCBhbnkgbWVtb3J5IGxlYWtzLlxuICogICAgICAgICAgICBVc2UgYGJ1ZmZlci5jb3B5VWludDhBcnJheWAgdG8gY29weSB0aGUgcmVzdWx0IGludG8gYSBuZXcgVWludDhBcnJheS5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlciBUaGUgZGVjb2RlciBpbnN0YW5jZVxuICogQHBhcmFtIHtudW1iZXJ9IGxlbiBUaGUgbGVuZ3RoIG9mIGJ5dGVzIHRvIHJlYWRcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKi9cbmNvbnN0IHJlYWRVaW50OEFycmF5ID0gKGRlY29kZXIsIGxlbikgPT4ge1xuICBjb25zdCB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoZGVjb2Rlci5hcnIuYnVmZmVyLCBkZWNvZGVyLnBvcyArIGRlY29kZXIuYXJyLmJ5dGVPZmZzZXQsIGxlbik7XG4gIGRlY29kZXIucG9zICs9IGxlbjtcbiAgcmV0dXJuIHZpZXdcbn07XG5cbi8qKlxuICogUmVhZCB2YXJpYWJsZSBsZW5ndGggVWludDhBcnJheS5cbiAqXG4gKiBJbXBvcnRhbnQ6IFRoZSBVaW50OEFycmF5IHN0aWxsIHBvaW50cyB0byB0aGUgdW5kZXJseWluZyBBcnJheUJ1ZmZlci4gTWFrZSBzdXJlIHRvIGRpc2NhcmQgdGhlIHJlc3VsdCBhcyBzb29uIGFzIHBvc3NpYmxlIHRvIHByZXZlbnQgYW55IG1lbW9yeSBsZWFrcy5cbiAqICAgICAgICAgICAgVXNlIGBidWZmZXIuY29weVVpbnQ4QXJyYXlgIHRvIGNvcHkgdGhlIHJlc3VsdCBpbnRvIGEgbmV3IFVpbnQ4QXJyYXkuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKi9cbmNvbnN0IHJlYWRWYXJVaW50OEFycmF5ID0gZGVjb2RlciA9PiByZWFkVWludDhBcnJheShkZWNvZGVyLCByZWFkVmFyVWludChkZWNvZGVyKSk7XG5cbi8qKlxuICogUmVhZCBvbmUgYnl0ZSBhcyB1bnNpZ25lZCBpbnRlZ2VyLlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXIgVGhlIGRlY29kZXIgaW5zdGFuY2VcbiAqIEByZXR1cm4ge251bWJlcn0gVW5zaWduZWQgOC1iaXQgaW50ZWdlclxuICovXG5jb25zdCByZWFkVWludDggPSBkZWNvZGVyID0+IGRlY29kZXIuYXJyW2RlY29kZXIucG9zKytdO1xuXG4vKipcbiAqIFJlYWQgdW5zaWduZWQgaW50ZWdlciAoMzJiaXQpIHdpdGggdmFyaWFibGUgbGVuZ3RoLlxuICogMS84dGggb2YgdGhlIHN0b3JhZ2UgaXMgdXNlZCBhcyBlbmNvZGluZyBvdmVyaGVhZC5cbiAqICAqIG51bWJlcnMgPCAyXjcgaXMgc3RvcmVkIGluIG9uZSBieXRsZW5ndGhcbiAqICAqIG51bWJlcnMgPCAyXjE0IGlzIHN0b3JlZCBpbiB0d28gYnlsZW5ndGhcbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlclxuICogQHJldHVybiB7bnVtYmVyfSBBbiB1bnNpZ25lZCBpbnRlZ2VyLmxlbmd0aFxuICovXG5jb25zdCByZWFkVmFyVWludCA9IGRlY29kZXIgPT4ge1xuICBsZXQgbnVtID0gMDtcbiAgbGV0IG11bHQgPSAxO1xuICBjb25zdCBsZW4gPSBkZWNvZGVyLmFyci5sZW5ndGg7XG4gIHdoaWxlIChkZWNvZGVyLnBvcyA8IGxlbikge1xuICAgIGNvbnN0IHIgPSBkZWNvZGVyLmFycltkZWNvZGVyLnBvcysrXTtcbiAgICAvLyBudW0gPSBudW0gfCAoKHIgJiBiaW5hcnkuQklUUzcpIDw8IGxlbilcbiAgICBudW0gPSBudW0gKyAociAmIEJJVFM3KSAqIG11bHQ7IC8vIHNoaWZ0ICRyIDw8ICg3KiNpdGVyYXRpb25zKSBhbmQgYWRkIGl0IHRvIG51bVxuICAgIG11bHQgKj0gMTI4OyAvLyBuZXh0IGl0ZXJhdGlvbiwgc2hpZnQgNyBcIm1vcmVcIiB0byB0aGUgbGVmdFxuICAgIGlmIChyIDwgQklUOCkge1xuICAgICAgcmV0dXJuIG51bVxuICAgIH1cbiAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICBpZiAobnVtID4gTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgdGhyb3cgZXJyb3JJbnRlZ2VyT3V0T2ZSYW5nZVxuICAgIH1cbiAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICB9XG4gIHRocm93IGVycm9yVW5leHBlY3RlZEVuZE9mQXJyYXlcbn07XG5cbi8qKlxuICogUmVhZCBzaWduZWQgaW50ZWdlciAoMzJiaXQpIHdpdGggdmFyaWFibGUgbGVuZ3RoLlxuICogMS84dGggb2YgdGhlIHN0b3JhZ2UgaXMgdXNlZCBhcyBlbmNvZGluZyBvdmVyaGVhZC5cbiAqICAqIG51bWJlcnMgPCAyXjcgaXMgc3RvcmVkIGluIG9uZSBieXRsZW5ndGhcbiAqICAqIG51bWJlcnMgPCAyXjE0IGlzIHN0b3JlZCBpbiB0d28gYnlsZW5ndGhcbiAqIEB0b2RvIFRoaXMgc2hvdWxkIHByb2JhYmx5IGNyZWF0ZSB0aGUgaW52ZXJzZSB+bnVtIGlmIG51bWJlciBpcyBuZWdhdGl2ZSAtIGJ1dCB0aGlzIHdvdWxkIGJlIGEgYnJlYWtpbmcgY2hhbmdlLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtEZWNvZGVyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEFuIHVuc2lnbmVkIGludGVnZXIubGVuZ3RoXG4gKi9cbmNvbnN0IHJlYWRWYXJJbnQgPSBkZWNvZGVyID0+IHtcbiAgbGV0IHIgPSBkZWNvZGVyLmFycltkZWNvZGVyLnBvcysrXTtcbiAgbGV0IG51bSA9IHIgJiBCSVRTNjtcbiAgbGV0IG11bHQgPSA2NDtcbiAgY29uc3Qgc2lnbiA9IChyICYgQklUNykgPiAwID8gLTEgOiAxO1xuICBpZiAoKHIgJiBCSVQ4KSA9PT0gMCkge1xuICAgIC8vIGRvbid0IGNvbnRpbnVlIHJlYWRpbmdcbiAgICByZXR1cm4gc2lnbiAqIG51bVxuICB9XG4gIGNvbnN0IGxlbiA9IGRlY29kZXIuYXJyLmxlbmd0aDtcbiAgd2hpbGUgKGRlY29kZXIucG9zIDwgbGVuKSB7XG4gICAgciA9IGRlY29kZXIuYXJyW2RlY29kZXIucG9zKytdO1xuICAgIC8vIG51bSA9IG51bSB8ICgociAmIGJpbmFyeS5CSVRTNykgPDwgbGVuKVxuICAgIG51bSA9IG51bSArIChyICYgQklUUzcpICogbXVsdDtcbiAgICBtdWx0ICo9IDEyODtcbiAgICBpZiAociA8IEJJVDgpIHtcbiAgICAgIHJldHVybiBzaWduICogbnVtXG4gICAgfVxuICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgIGlmIChudW0gPiBNQVhfU0FGRV9JTlRFR0VSKSB7XG4gICAgICB0aHJvdyBlcnJvckludGVnZXJPdXRPZlJhbmdlXG4gICAgfVxuICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gIH1cbiAgdGhyb3cgZXJyb3JVbmV4cGVjdGVkRW5kT2ZBcnJheVxufTtcblxuLyoqXG4gKiBXZSBkb24ndCB0ZXN0IHRoaXMgZnVuY3Rpb24gYW55bW9yZSBhcyB3ZSB1c2UgbmF0aXZlIGRlY29kaW5nL2VuY29kaW5nIGJ5IGRlZmF1bHQgbm93LlxuICogQmV0dGVyIG5vdCBtb2RpZnkgdGhpcyBhbnltb3JlLi5cbiAqXG4gKiBUcmFuc2Zvcm1pbmcgdXRmOCB0byBhIHN0cmluZyBpcyBwcmV0dHkgZXhwZW5zaXZlLiBUaGUgY29kZSBwZXJmb3JtcyAxMHggYmV0dGVyXG4gKiB3aGVuIFN0cmluZy5mcm9tQ29kZVBvaW50IGlzIGZlZCB3aXRoIGFsbCBjaGFyYWN0ZXJzIGFzIGFyZ3VtZW50cy5cbiAqIEJ1dCBtb3N0IGVudmlyb25tZW50cyBoYXZlIGEgbWF4aW11bSBudW1iZXIgb2YgYXJndW1lbnRzIHBlciBmdW5jdGlvbnMuXG4gKiBGb3IgZWZmaWVuY3kgcmVhc29ucyB3ZSBhcHBseSBhIG1heGltdW0gb2YgMTAwMDAgY2hhcmFjdGVycyBhdCBvbmNlLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtEZWNvZGVyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSByZWFkIFN0cmluZy5cbiAqL1xuLyogYzggaWdub3JlIHN0YXJ0ICovXG5jb25zdCBfcmVhZFZhclN0cmluZ1BvbHlmaWxsID0gZGVjb2RlciA9PiB7XG4gIGxldCByZW1haW5pbmdMZW4gPSByZWFkVmFyVWludChkZWNvZGVyKTtcbiAgaWYgKHJlbWFpbmluZ0xlbiA9PT0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9IGVsc2Uge1xuICAgIGxldCBlbmNvZGVkU3RyaW5nID0gU3RyaW5nLmZyb21Db2RlUG9pbnQocmVhZFVpbnQ4KGRlY29kZXIpKTsgLy8gcmVtZW1iZXIgdG8gZGVjcmVhc2UgcmVtYWluaW5nTGVuXG4gICAgaWYgKC0tcmVtYWluaW5nTGVuIDwgMTAwKSB7IC8vIGRvIG5vdCBjcmVhdGUgYSBVaW50OEFycmF5IGZvciBzbWFsbCBzdHJpbmdzXG4gICAgICB3aGlsZSAocmVtYWluaW5nTGVuLS0pIHtcbiAgICAgICAgZW5jb2RlZFN0cmluZyArPSBTdHJpbmcuZnJvbUNvZGVQb2ludChyZWFkVWludDgoZGVjb2RlcikpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB3aGlsZSAocmVtYWluaW5nTGVuID4gMCkge1xuICAgICAgICBjb25zdCBuZXh0TGVuID0gcmVtYWluaW5nTGVuIDwgMTAwMDAgPyByZW1haW5pbmdMZW4gOiAxMDAwMDtcbiAgICAgICAgLy8gdGhpcyBpcyBkYW5nZXJvdXMsIHdlIGNyZWF0ZSBhIGZyZXNoIGFycmF5IHZpZXcgZnJvbSB0aGUgZXhpc3RpbmcgYnVmZmVyXG4gICAgICAgIGNvbnN0IGJ5dGVzID0gZGVjb2Rlci5hcnIuc3ViYXJyYXkoZGVjb2Rlci5wb3MsIGRlY29kZXIucG9zICsgbmV4dExlbik7XG4gICAgICAgIGRlY29kZXIucG9zICs9IG5leHRMZW47XG4gICAgICAgIC8vIFN0YXJ0aW5nIHdpdGggRVM1LjEgd2UgY2FuIHN1cHBseSBhIGdlbmVyaWMgYXJyYXktbGlrZSBvYmplY3QgYXMgYXJndW1lbnRzXG4gICAgICAgIGVuY29kZWRTdHJpbmcgKz0gU3RyaW5nLmZyb21Db2RlUG9pbnQuYXBwbHkobnVsbCwgLyoqIEB0eXBlIHthbnl9ICovIChieXRlcykpO1xuICAgICAgICByZW1haW5pbmdMZW4gLT0gbmV4dExlbjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChlc2NhcGUoZW5jb2RlZFN0cmluZykpXG4gIH1cbn07XG4vKiBjOCBpZ25vcmUgc3RvcCAqL1xuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtEZWNvZGVyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSByZWFkIFN0cmluZ1xuICovXG5jb25zdCBfcmVhZFZhclN0cmluZ05hdGl2ZSA9IGRlY29kZXIgPT5cbiAgLyoqIEB0eXBlIGFueSAqLyAodXRmOFRleHREZWNvZGVyKS5kZWNvZGUocmVhZFZhclVpbnQ4QXJyYXkoZGVjb2RlcikpO1xuXG4vKipcbiAqIFJlYWQgc3RyaW5nIG9mIHZhcmlhYmxlIGxlbmd0aFxuICogKiB2YXJVaW50IGlzIHVzZWQgdG8gc3RvcmUgdGhlIGxlbmd0aCBvZiB0aGUgc3RyaW5nXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge1N0cmluZ30gVGhlIHJlYWQgU3RyaW5nXG4gKlxuICovXG4vKiBjOCBpZ25vcmUgbmV4dCAqL1xuY29uc3QgcmVhZFZhclN0cmluZyA9IHV0ZjhUZXh0RGVjb2RlciA/IF9yZWFkVmFyU3RyaW5nTmF0aXZlIDogX3JlYWRWYXJTdHJpbmdQb2x5ZmlsbDtcblxuLyoqXG4gKiBMb29rIGFoZWFkIGFuZCByZWFkIHZhclN0cmluZyB3aXRob3V0IGluY3JlbWVudGluZyBwb3NpdGlvblxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtEZWNvZGVyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmNvbnN0IHBlZWtWYXJTdHJpbmcgPSBkZWNvZGVyID0+IHtcbiAgY29uc3QgcG9zID0gZGVjb2Rlci5wb3M7XG4gIGNvbnN0IHMgPSByZWFkVmFyU3RyaW5nKGRlY29kZXIpO1xuICBkZWNvZGVyLnBvcyA9IHBvcztcbiAgcmV0dXJuIHNcbn07XG5cbi8qKlxuICogVXRpbGl0eSBtb2R1bGUgdG8gd29yayB3aXRoIHRpbWUuXG4gKlxuICogQG1vZHVsZSB0aW1lXG4gKi9cblxuXG4vKipcbiAqIFJldHVybiBjdXJyZW50IHVuaXggdGltZS5cbiAqXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmNvbnN0IGdldFVuaXhUaW1lID0gRGF0ZS5ub3c7XG5cbi8qKlxuICogVXRpbGl0eSBtb2R1bGUgdG8gd29yayB3aXRoIGtleS12YWx1ZSBzdG9yZXMuXG4gKlxuICogQG1vZHVsZSBtYXBcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgTWFwIGluc3RhbmNlLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHJldHVybiB7TWFwPGFueSwgYW55Pn1cbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgY3JlYXRlID0gKCkgPT4gbmV3IE1hcCgpO1xuXG4vKipcbiAqIEdldCBtYXAgcHJvcGVydHkuIENyZWF0ZSBUIGlmIHByb3BlcnR5IGlzIHVuZGVmaW5lZCBhbmQgc2V0IFQgb24gbWFwLlxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCBsaXN0ZW5lcnMgPSBtYXAuc2V0SWZVbmRlZmluZWQoZXZlbnRzLCAnZXZlbnROYW1lJywgc2V0LmNyZWF0ZSlcbiAqIGxpc3RlbmVycy5hZGQobGlzdGVuZXIpXG4gKiBgYGBcbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEB0ZW1wbGF0ZSB7TWFwPGFueSwgYW55Pn0gTUFQXG4gKiBAdGVtcGxhdGUge01BUCBleHRlbmRzIE1hcDxhbnksaW5mZXIgVj4gPyBmdW5jdGlvbigpOlYgOiB1bmtub3dufSBDRlxuICogQHBhcmFtIHtNQVB9IG1hcFxuICogQHBhcmFtIHtNQVAgZXh0ZW5kcyBNYXA8aW5mZXIgSyxhbnk+ID8gSyA6IHVua25vd259IGtleVxuICogQHBhcmFtIHtDRn0gY3JlYXRlVFxuICogQHJldHVybiB7UmV0dXJuVHlwZTxDRj59XG4gKi9cbmNvbnN0IHNldElmVW5kZWZpbmVkID0gKG1hcCwga2V5LCBjcmVhdGVUKSA9PiB7XG4gIGxldCBzZXQgPSBtYXAuZ2V0KGtleSk7XG4gIGlmIChzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIG1hcC5zZXQoa2V5LCBzZXQgPSBjcmVhdGVUKCkpO1xuICB9XG4gIHJldHVybiBzZXRcbn07XG5cbi8qKlxuICogT2JzZXJ2YWJsZSBjbGFzcyBwcm90b3R5cGUuXG4gKlxuICogQG1vZHVsZSBvYnNlcnZhYmxlXG4gKi9cblxuXG4vKiBjOCBpZ25vcmUgc3RhcnQgKi9cbi8qKlxuICogSGFuZGxlcyBuYW1lZCBldmVudHMuXG4gKlxuICogQGRlcHJlY2F0ZWRcbiAqIEB0ZW1wbGF0ZSBOXG4gKi9cbmNsYXNzIE9ic2VydmFibGUge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgLyoqXG4gICAgICogU29tZSBkZXNjLlxuICAgICAqIEB0eXBlIHtNYXA8TiwgYW55Pn1cbiAgICAgKi9cbiAgICB0aGlzLl9vYnNlcnZlcnMgPSBjcmVhdGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge059IG5hbWVcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gZlxuICAgKi9cbiAgb24gKG5hbWUsIGYpIHtcbiAgICBzZXRJZlVuZGVmaW5lZCh0aGlzLl9vYnNlcnZlcnMsIG5hbWUsIGNyZWF0ZSQyKS5hZGQoZik7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtOfSBuYW1lXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZcbiAgICovXG4gIG9uY2UgKG5hbWUsIGYpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gIHsuLi5hbnl9IGFyZ3NcbiAgICAgKi9cbiAgICBjb25zdCBfZiA9ICguLi5hcmdzKSA9PiB7XG4gICAgICB0aGlzLm9mZihuYW1lLCBfZik7XG4gICAgICBmKC4uLmFyZ3MpO1xuICAgIH07XG4gICAgdGhpcy5vbihuYW1lLCBfZik7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtOfSBuYW1lXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZcbiAgICovXG4gIG9mZiAobmFtZSwgZikge1xuICAgIGNvbnN0IG9ic2VydmVycyA9IHRoaXMuX29ic2VydmVycy5nZXQobmFtZSk7XG4gICAgaWYgKG9ic2VydmVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBvYnNlcnZlcnMuZGVsZXRlKGYpO1xuICAgICAgaWYgKG9ic2VydmVycy5zaXplID09PSAwKSB7XG4gICAgICAgIHRoaXMuX29ic2VydmVycy5kZWxldGUobmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEVtaXQgYSBuYW1lZCBldmVudC4gQWxsIHJlZ2lzdGVyZWQgZXZlbnQgbGlzdGVuZXJzIHRoYXQgbGlzdGVuIHRvIHRoZVxuICAgKiBzcGVjaWZpZWQgbmFtZSB3aWxsIHJlY2VpdmUgdGhlIGV2ZW50LlxuICAgKlxuICAgKiBAdG9kbyBUaGlzIHNob3VsZCBjYXRjaCBleGNlcHRpb25zXG4gICAqXG4gICAqIEBwYXJhbSB7Tn0gbmFtZSBUaGUgZXZlbnQgbmFtZS5cbiAgICogQHBhcmFtIHtBcnJheTxhbnk+fSBhcmdzIFRoZSBhcmd1bWVudHMgdGhhdCBhcmUgYXBwbGllZCB0byB0aGUgZXZlbnQgbGlzdGVuZXIuXG4gICAqL1xuICBlbWl0IChuYW1lLCBhcmdzKSB7XG4gICAgLy8gY29weSBhbGwgbGlzdGVuZXJzIHRvIGFuIGFycmF5IGZpcnN0IHRvIG1ha2Ugc3VyZSB0aGF0IG5vIGV2ZW50IGlzIGVtaXR0ZWQgdG8gbGlzdGVuZXJzIHRoYXQgYXJlIHN1YnNjcmliZWQgd2hpbGUgdGhlIGV2ZW50IGhhbmRsZXIgaXMgY2FsbGVkLlxuICAgIHJldHVybiBmcm9tKCh0aGlzLl9vYnNlcnZlcnMuZ2V0KG5hbWUpIHx8IGNyZWF0ZSgpKS52YWx1ZXMoKSkuZm9yRWFjaChmID0+IGYoLi4uYXJncykpXG4gIH1cblxuICBkZXN0cm95ICgpIHtcbiAgICB0aGlzLl9vYnNlcnZlcnMgPSBjcmVhdGUoKTtcbiAgfVxufVxuLyogYzggaWdub3JlIGVuZCAqL1xuXG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb25zIGZvciB3b3JraW5nIHdpdGggRWNtYVNjcmlwdCBvYmplY3RzLlxuICpcbiAqIEBtb2R1bGUgb2JqZWN0XG4gKi9cblxuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZyxhbnk+fSBvYmpcbiAqL1xuY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzO1xuXG4vKipcbiAqIEBkZXByZWNhdGVkIHVzZSBvYmplY3Quc2l6ZSBpbnN0ZWFkXG4gKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsYW55Pn0gb2JqXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmNvbnN0IGxlbmd0aCA9IG9iaiA9PiBrZXlzKG9iaikubGVuZ3RoO1xuXG4vKipcbiAqIENhbGxzIGBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5YC5cbiAqXG4gKiBAcGFyYW0ge2FueX0gb2JqXG4gKiBAcGFyYW0ge3N0cmluZ3xzeW1ib2x9IGtleVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuY29uc3QgaGFzUHJvcGVydHkgPSAob2JqLCBrZXkpID0+IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XG5cbi8qKlxuICogQ29tbW9uIGZ1bmN0aW9ucyBhbmQgZnVuY3Rpb24gY2FsbCBoZWxwZXJzLlxuICpcbiAqIEBtb2R1bGUgZnVuY3Rpb25cbiAqL1xuXG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqXG4gKiBAcGFyYW0ge1R9IGFcbiAqIEBwYXJhbSB7VH0gYlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuY29uc3QgZXF1YWxpdHlTdHJpY3QgPSAoYSwgYikgPT4gYSA9PT0gYjtcblxuLyogYzggaWdub3JlIHN0YXJ0ICovXG5cbi8qKlxuICogQHBhcmFtIHthbnl9IGFcbiAqIEBwYXJhbSB7YW55fSBiXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5jb25zdCBlcXVhbGl0eURlZXAgPSAoYSwgYikgPT4ge1xuICBpZiAoYSA9PSBudWxsIHx8IGIgPT0gbnVsbCkge1xuICAgIHJldHVybiBlcXVhbGl0eVN0cmljdChhLCBiKVxuICB9XG4gIGlmIChhLmNvbnN0cnVjdG9yICE9PSBiLmNvbnN0cnVjdG9yKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgaWYgKGEgPT09IGIpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHN3aXRjaCAoYS5jb25zdHJ1Y3Rvcikge1xuICAgIGNhc2UgQXJyYXlCdWZmZXI6XG4gICAgICBhID0gbmV3IFVpbnQ4QXJyYXkoYSk7XG4gICAgICBiID0gbmV3IFVpbnQ4QXJyYXkoYik7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZhbGx0aHJvdWdoXG4gICAgY2FzZSBVaW50OEFycmF5OiB7XG4gICAgICBpZiAoYS5ieXRlTGVuZ3RoICE9PSBiLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICB9XG4gICAgY2FzZSBTZXQ6IHtcbiAgICAgIGlmIChhLnNpemUgIT09IGIuc2l6ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgYSkge1xuICAgICAgICBpZiAoIWIuaGFzKHZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVha1xuICAgIH1cbiAgICBjYXNlIE1hcDoge1xuICAgICAgaWYgKGEuc2l6ZSAhPT0gYi5zaXplKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBrZXkgb2YgYS5rZXlzKCkpIHtcbiAgICAgICAgaWYgKCFiLmhhcyhrZXkpIHx8ICFlcXVhbGl0eURlZXAoYS5nZXQoa2V5KSwgYi5nZXQoa2V5KSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICB9XG4gICAgY2FzZSBPYmplY3Q6XG4gICAgICBpZiAobGVuZ3RoKGEpICE9PSBsZW5ndGgoYikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBhKSB7XG4gICAgICAgIGlmICghaGFzUHJvcGVydHkoYSwga2V5KSB8fCAhZXF1YWxpdHlEZWVwKGFba2V5XSwgYltrZXldKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVha1xuICAgIGNhc2UgQXJyYXk6XG4gICAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghZXF1YWxpdHlEZWVwKGFbaV0sIGJbaV0pKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHJldHVybiB0cnVlXG59O1xuXG4vKipcbiAqIEBtb2R1bGUgYXdhcmVuZXNzLXByb3RvY29sXG4gKi9cblxuXG5jb25zdCBvdXRkYXRlZFRpbWVvdXQgPSAzMDAwMDtcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBNZXRhQ2xpZW50U3RhdGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBNZXRhQ2xpZW50U3RhdGUuY2xvY2tcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBNZXRhQ2xpZW50U3RhdGUubGFzdFVwZGF0ZWQgdW5peCB0aW1lc3RhbXBcbiAqL1xuXG4vKipcbiAqIFRoZSBBd2FyZW5lc3MgY2xhc3MgaW1wbGVtZW50cyBhIHNpbXBsZSBzaGFyZWQgc3RhdGUgcHJvdG9jb2wgdGhhdCBjYW4gYmUgdXNlZCBmb3Igbm9uLXBlcnNpc3RlbnQgZGF0YSBsaWtlIGF3YXJlbmVzcyBpbmZvcm1hdGlvblxuICogKGN1cnNvciwgdXNlcm5hbWUsIHN0YXR1cywgLi4pLiBFYWNoIGNsaWVudCBjYW4gdXBkYXRlIGl0cyBvd24gbG9jYWwgc3RhdGUgYW5kIGxpc3RlbiB0byBzdGF0ZSBjaGFuZ2VzIG9mXG4gKiByZW1vdGUgY2xpZW50cy4gRXZlcnkgY2xpZW50IG1heSBzZXQgYSBzdGF0ZSBvZiBhIHJlbW90ZSBwZWVyIHRvIGBudWxsYCB0byBtYXJrIHRoZSBjbGllbnQgYXMgb2ZmbGluZS5cbiAqXG4gKiBFYWNoIGNsaWVudCBpcyBpZGVudGlmaWVkIGJ5IGEgdW5pcXVlIGNsaWVudCBpZCAoc29tZXRoaW5nIHdlIGJvcnJvdyBmcm9tIGBkb2MuY2xpZW50SURgKS4gQSBjbGllbnQgY2FuIG92ZXJyaWRlXG4gKiBpdHMgb3duIHN0YXRlIGJ5IHByb3BhZ2F0aW5nIGEgbWVzc2FnZSB3aXRoIGFuIGluY3JlYXNpbmcgdGltZXN0YW1wIChgY2xvY2tgKS4gSWYgc3VjaCBhIG1lc3NhZ2UgaXMgcmVjZWl2ZWQsIGl0IGlzXG4gKiBhcHBsaWVkIGlmIHRoZSBrbm93biBzdGF0ZSBvZiB0aGF0IGNsaWVudCBpcyBvbGRlciB0aGFuIHRoZSBuZXcgc3RhdGUgKGBjbG9jayA8IG5ld0Nsb2NrYCkuIElmIGEgY2xpZW50IHRoaW5rcyB0aGF0XG4gKiBhIHJlbW90ZSBjbGllbnQgaXMgb2ZmbGluZSwgaXQgbWF5IHByb3BhZ2F0ZSBhIG1lc3NhZ2Ugd2l0aFxuICogYHsgY2xvY2s6IGN1cnJlbnRDbGllbnRDbG9jaywgc3RhdGU6IG51bGwsIGNsaWVudDogcmVtb3RlQ2xpZW50IH1gLiBJZiBzdWNoIGFcbiAqIG1lc3NhZ2UgaXMgcmVjZWl2ZWQsIGFuZCB0aGUga25vd24gY2xvY2sgb2YgdGhhdCBjbGllbnQgZXF1YWxzIHRoZSByZWNlaXZlZCBjbG9jaywgaXQgd2lsbCBvdmVycmlkZSB0aGUgc3RhdGUgd2l0aCBgbnVsbGAuXG4gKlxuICogQmVmb3JlIGEgY2xpZW50IGRpc2Nvbm5lY3RzLCBpdCBzaG91bGQgcHJvcGFnYXRlIGEgYG51bGxgIHN0YXRlIHdpdGggYW4gdXBkYXRlZCBjbG9jay5cbiAqXG4gKiBBd2FyZW5lc3Mgc3RhdGVzIG11c3QgYmUgdXBkYXRlZCBldmVyeSAzMCBzZWNvbmRzLiBPdGhlcndpc2UgdGhlIEF3YXJlbmVzcyBpbnN0YW5jZSB3aWxsIGRlbGV0ZSB0aGUgY2xpZW50IHN0YXRlLlxuICpcbiAqIEBleHRlbmRzIHtPYnNlcnZhYmxlPHN0cmluZz59XG4gKi9cbmNsYXNzIEF3YXJlbmVzcyBleHRlbmRzIE9ic2VydmFibGUge1xuICAvKipcbiAgICogQHBhcmFtIHtZLkRvY30gZG9jXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoZG9jKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmRvYyA9IGRvYztcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuY2xpZW50SUQgPSBkb2MuY2xpZW50SUQ7XG4gICAgLyoqXG4gICAgICogTWFwcyBmcm9tIGNsaWVudCBpZCB0byBjbGllbnQgc3RhdGVcbiAgICAgKiBAdHlwZSB7TWFwPG51bWJlciwgT2JqZWN0PHN0cmluZywgYW55Pj59XG4gICAgICovXG4gICAgdGhpcy5zdGF0ZXMgPSBuZXcgTWFwKCk7XG4gICAgLyoqXG4gICAgICogQHR5cGUge01hcDxudW1iZXIsIE1ldGFDbGllbnRTdGF0ZT59XG4gICAgICovXG4gICAgdGhpcy5tZXRhID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuX2NoZWNrSW50ZXJ2YWwgPSAvKiogQHR5cGUge2FueX0gKi8gKHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIGNvbnN0IG5vdyA9IGdldFVuaXhUaW1lKCk7XG4gICAgICBpZiAodGhpcy5nZXRMb2NhbFN0YXRlKCkgIT09IG51bGwgJiYgKG91dGRhdGVkVGltZW91dCAvIDIgPD0gbm93IC0gLyoqIEB0eXBlIHt7bGFzdFVwZGF0ZWQ6bnVtYmVyfX0gKi8gKHRoaXMubWV0YS5nZXQodGhpcy5jbGllbnRJRCkpLmxhc3RVcGRhdGVkKSkge1xuICAgICAgICAvLyByZW5ldyBsb2NhbCBjbG9ja1xuICAgICAgICB0aGlzLnNldExvY2FsU3RhdGUodGhpcy5nZXRMb2NhbFN0YXRlKCkpO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn1cbiAgICAgICAqL1xuICAgICAgY29uc3QgcmVtb3ZlID0gW107XG4gICAgICB0aGlzLm1ldGEuZm9yRWFjaCgobWV0YSwgY2xpZW50aWQpID0+IHtcbiAgICAgICAgaWYgKGNsaWVudGlkICE9PSB0aGlzLmNsaWVudElEICYmIG91dGRhdGVkVGltZW91dCA8PSBub3cgLSBtZXRhLmxhc3RVcGRhdGVkICYmIHRoaXMuc3RhdGVzLmhhcyhjbGllbnRpZCkpIHtcbiAgICAgICAgICByZW1vdmUucHVzaChjbGllbnRpZCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKHJlbW92ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJlbW92ZUF3YXJlbmVzc1N0YXRlcyh0aGlzLCByZW1vdmUsICd0aW1lb3V0Jyk7XG4gICAgICB9XG4gICAgfSwgZmxvb3Iob3V0ZGF0ZWRUaW1lb3V0IC8gMTApKSk7XG4gICAgZG9jLm9uKCdkZXN0cm95JywgKCkgPT4ge1xuICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgfSk7XG4gICAgdGhpcy5zZXRMb2NhbFN0YXRlKHt9KTtcbiAgfVxuXG4gIGRlc3Ryb3kgKCkge1xuICAgIHRoaXMuZW1pdCgnZGVzdHJveScsIFt0aGlzXSk7XG4gICAgdGhpcy5zZXRMb2NhbFN0YXRlKG51bGwpO1xuICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICBjbGVhckludGVydmFsKHRoaXMuX2NoZWNrSW50ZXJ2YWwpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge09iamVjdDxzdHJpbmcsYW55PnxudWxsfVxuICAgKi9cbiAgZ2V0TG9jYWxTdGF0ZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGVzLmdldCh0aGlzLmNsaWVudElEKSB8fCBudWxsXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLGFueT58bnVsbH0gc3RhdGVcbiAgICovXG4gIHNldExvY2FsU3RhdGUgKHN0YXRlKSB7XG4gICAgY29uc3QgY2xpZW50SUQgPSB0aGlzLmNsaWVudElEO1xuICAgIGNvbnN0IGN1cnJMb2NhbE1ldGEgPSB0aGlzLm1ldGEuZ2V0KGNsaWVudElEKTtcbiAgICBjb25zdCBjbG9jayA9IGN1cnJMb2NhbE1ldGEgPT09IHVuZGVmaW5lZCA/IDAgOiBjdXJyTG9jYWxNZXRhLmNsb2NrICsgMTtcbiAgICBjb25zdCBwcmV2U3RhdGUgPSB0aGlzLnN0YXRlcy5nZXQoY2xpZW50SUQpO1xuICAgIGlmIChzdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5zdGF0ZXMuZGVsZXRlKGNsaWVudElEKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdGF0ZXMuc2V0KGNsaWVudElELCBzdGF0ZSk7XG4gICAgfVxuICAgIHRoaXMubWV0YS5zZXQoY2xpZW50SUQsIHtcbiAgICAgIGNsb2NrLFxuICAgICAgbGFzdFVwZGF0ZWQ6IGdldFVuaXhUaW1lKClcbiAgICB9KTtcbiAgICBjb25zdCBhZGRlZCA9IFtdO1xuICAgIGNvbnN0IHVwZGF0ZWQgPSBbXTtcbiAgICBjb25zdCBmaWx0ZXJlZFVwZGF0ZWQgPSBbXTtcbiAgICBjb25zdCByZW1vdmVkID0gW107XG4gICAgaWYgKHN0YXRlID09PSBudWxsKSB7XG4gICAgICByZW1vdmVkLnB1c2goY2xpZW50SUQpO1xuICAgIH0gZWxzZSBpZiAocHJldlN0YXRlID09IG51bGwpIHtcbiAgICAgIGlmIChzdGF0ZSAhPSBudWxsKSB7XG4gICAgICAgIGFkZGVkLnB1c2goY2xpZW50SUQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB1cGRhdGVkLnB1c2goY2xpZW50SUQpO1xuICAgICAgaWYgKCFlcXVhbGl0eURlZXAocHJldlN0YXRlLCBzdGF0ZSkpIHtcbiAgICAgICAgZmlsdGVyZWRVcGRhdGVkLnB1c2goY2xpZW50SUQpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYWRkZWQubGVuZ3RoID4gMCB8fCBmaWx0ZXJlZFVwZGF0ZWQubGVuZ3RoID4gMCB8fCByZW1vdmVkLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuZW1pdCgnY2hhbmdlJywgW3sgYWRkZWQsIHVwZGF0ZWQ6IGZpbHRlcmVkVXBkYXRlZCwgcmVtb3ZlZCB9LCAnbG9jYWwnXSk7XG4gICAgfVxuICAgIHRoaXMuZW1pdCgndXBkYXRlJywgW3sgYWRkZWQsIHVwZGF0ZWQsIHJlbW92ZWQgfSwgJ2xvY2FsJ10pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZFxuICAgKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAgICovXG4gIHNldExvY2FsU3RhdGVGaWVsZCAoZmllbGQsIHZhbHVlKSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLmdldExvY2FsU3RhdGUoKTtcbiAgICBpZiAoc3RhdGUgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuc2V0TG9jYWxTdGF0ZSh7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICBbZmllbGRdOiB2YWx1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge01hcDxudW1iZXIsT2JqZWN0PHN0cmluZyxhbnk+Pn1cbiAgICovXG4gIGdldFN0YXRlcyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGVzXG4gIH1cbn1cblxuLyoqXG4gKiBNYXJrIChyZW1vdGUpIGNsaWVudHMgYXMgaW5hY3RpdmUgYW5kIHJlbW92ZSB0aGVtIGZyb20gdGhlIGxpc3Qgb2YgYWN0aXZlIHBlZXJzLlxuICogVGhpcyBjaGFuZ2Ugd2lsbCBiZSBwcm9wYWdhdGVkIHRvIHJlbW90ZSBjbGllbnRzLlxuICpcbiAqIEBwYXJhbSB7QXdhcmVuZXNzfSBhd2FyZW5lc3NcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gY2xpZW50c1xuICogQHBhcmFtIHthbnl9IG9yaWdpblxuICovXG5jb25zdCByZW1vdmVBd2FyZW5lc3NTdGF0ZXMgPSAoYXdhcmVuZXNzLCBjbGllbnRzLCBvcmlnaW4pID0+IHtcbiAgY29uc3QgcmVtb3ZlZCA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNsaWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjbGllbnRJRCA9IGNsaWVudHNbaV07XG4gICAgaWYgKGF3YXJlbmVzcy5zdGF0ZXMuaGFzKGNsaWVudElEKSkge1xuICAgICAgYXdhcmVuZXNzLnN0YXRlcy5kZWxldGUoY2xpZW50SUQpO1xuICAgICAgaWYgKGNsaWVudElEID09PSBhd2FyZW5lc3MuY2xpZW50SUQpIHtcbiAgICAgICAgY29uc3QgY3VyTWV0YSA9IC8qKiBAdHlwZSB7TWV0YUNsaWVudFN0YXRlfSAqLyAoYXdhcmVuZXNzLm1ldGEuZ2V0KGNsaWVudElEKSk7XG4gICAgICAgIGF3YXJlbmVzcy5tZXRhLnNldChjbGllbnRJRCwge1xuICAgICAgICAgIGNsb2NrOiBjdXJNZXRhLmNsb2NrICsgMSxcbiAgICAgICAgICBsYXN0VXBkYXRlZDogZ2V0VW5peFRpbWUoKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJlbW92ZWQucHVzaChjbGllbnRJRCk7XG4gICAgfVxuICB9XG4gIGlmIChyZW1vdmVkLmxlbmd0aCA+IDApIHtcbiAgICBhd2FyZW5lc3MuZW1pdCgnY2hhbmdlJywgW3sgYWRkZWQ6IFtdLCB1cGRhdGVkOiBbXSwgcmVtb3ZlZCB9LCBvcmlnaW5dKTtcbiAgICBhd2FyZW5lc3MuZW1pdCgndXBkYXRlJywgW3sgYWRkZWQ6IFtdLCB1cGRhdGVkOiBbXSwgcmVtb3ZlZCB9LCBvcmlnaW5dKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge0F3YXJlbmVzc30gYXdhcmVuZXNzXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGNsaWVudHNcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKi9cbmNvbnN0IGVuY29kZUF3YXJlbmVzc1VwZGF0ZSA9IChhd2FyZW5lc3MsIGNsaWVudHMsIHN0YXRlcyA9IGF3YXJlbmVzcy5zdGF0ZXMpID0+IHtcbiAgY29uc3QgbGVuID0gY2xpZW50cy5sZW5ndGg7XG4gIGNvbnN0IGVuY29kZXIgPSBjcmVhdGVFbmNvZGVyKCk7XG4gIHdyaXRlVmFyVWludChlbmNvZGVyLCBsZW4pO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgY29uc3QgY2xpZW50SUQgPSBjbGllbnRzW2ldO1xuICAgIGNvbnN0IHN0YXRlID0gc3RhdGVzLmdldChjbGllbnRJRCkgfHwgbnVsbDtcbiAgICBjb25zdCBjbG9jayA9IC8qKiBAdHlwZSB7TWV0YUNsaWVudFN0YXRlfSAqLyAoYXdhcmVuZXNzLm1ldGEuZ2V0KGNsaWVudElEKSkuY2xvY2s7XG4gICAgd3JpdGVWYXJVaW50KGVuY29kZXIsIGNsaWVudElEKTtcbiAgICB3cml0ZVZhclVpbnQoZW5jb2RlciwgY2xvY2spO1xuICAgIHdyaXRlVmFyU3RyaW5nKGVuY29kZXIsIEpTT04uc3RyaW5naWZ5KHN0YXRlKSk7XG4gIH1cbiAgcmV0dXJuIHRvVWludDhBcnJheShlbmNvZGVyKVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge0F3YXJlbmVzc30gYXdhcmVuZXNzXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVwZGF0ZVxuICogQHBhcmFtIHthbnl9IG9yaWdpbiBUaGlzIHdpbGwgYmUgYWRkZWQgdG8gdGhlIGVtaXR0ZWQgY2hhbmdlIGV2ZW50XG4gKi9cbmNvbnN0IGFwcGx5QXdhcmVuZXNzVXBkYXRlID0gKGF3YXJlbmVzcywgdXBkYXRlLCBvcmlnaW4pID0+IHtcbiAgY29uc3QgZGVjb2RlciA9IGNyZWF0ZURlY29kZXIodXBkYXRlKTtcbiAgY29uc3QgdGltZXN0YW1wID0gZ2V0VW5peFRpbWUoKTtcbiAgY29uc3QgYWRkZWQgPSBbXTtcbiAgY29uc3QgdXBkYXRlZCA9IFtdO1xuICBjb25zdCBmaWx0ZXJlZFVwZGF0ZWQgPSBbXTtcbiAgY29uc3QgcmVtb3ZlZCA9IFtdO1xuICBjb25zdCBsZW4gPSByZWFkVmFyVWludChkZWNvZGVyKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGNvbnN0IGNsaWVudElEID0gcmVhZFZhclVpbnQoZGVjb2Rlcik7XG4gICAgbGV0IGNsb2NrID0gcmVhZFZhclVpbnQoZGVjb2Rlcik7XG4gICAgY29uc3Qgc3RhdGUgPSBKU09OLnBhcnNlKHJlYWRWYXJTdHJpbmcoZGVjb2RlcikpO1xuICAgIGNvbnN0IGNsaWVudE1ldGEgPSBhd2FyZW5lc3MubWV0YS5nZXQoY2xpZW50SUQpO1xuICAgIGNvbnN0IHByZXZTdGF0ZSA9IGF3YXJlbmVzcy5zdGF0ZXMuZ2V0KGNsaWVudElEKTtcbiAgICBjb25zdCBjdXJyQ2xvY2sgPSBjbGllbnRNZXRhID09PSB1bmRlZmluZWQgPyAwIDogY2xpZW50TWV0YS5jbG9jaztcbiAgICBpZiAoY3VyckNsb2NrIDwgY2xvY2sgfHwgKGN1cnJDbG9jayA9PT0gY2xvY2sgJiYgc3RhdGUgPT09IG51bGwgJiYgYXdhcmVuZXNzLnN0YXRlcy5oYXMoY2xpZW50SUQpKSkge1xuICAgICAgaWYgKHN0YXRlID09PSBudWxsKSB7XG4gICAgICAgIC8vIG5ldmVyIGxldCBhIHJlbW90ZSBjbGllbnQgcmVtb3ZlIHRoaXMgbG9jYWwgc3RhdGVcbiAgICAgICAgaWYgKGNsaWVudElEID09PSBhd2FyZW5lc3MuY2xpZW50SUQgJiYgYXdhcmVuZXNzLmdldExvY2FsU3RhdGUoKSAhPSBudWxsKSB7XG4gICAgICAgICAgLy8gcmVtb3RlIGNsaWVudCByZW1vdmVkIHRoZSBsb2NhbCBzdGF0ZS4gRG8gbm90IHJlbW90ZSBzdGF0ZS4gQnJvYWRjYXN0IGEgbWVzc2FnZSBpbmRpY2F0aW5nXG4gICAgICAgICAgLy8gdGhhdCB0aGlzIGNsaWVudCBzdGlsbCBleGlzdHMgYnkgaW5jcmVhc2luZyB0aGUgY2xvY2tcbiAgICAgICAgICBjbG9jaysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGF3YXJlbmVzcy5zdGF0ZXMuZGVsZXRlKGNsaWVudElEKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXdhcmVuZXNzLnN0YXRlcy5zZXQoY2xpZW50SUQsIHN0YXRlKTtcbiAgICAgIH1cbiAgICAgIGF3YXJlbmVzcy5tZXRhLnNldChjbGllbnRJRCwge1xuICAgICAgICBjbG9jayxcbiAgICAgICAgbGFzdFVwZGF0ZWQ6IHRpbWVzdGFtcFxuICAgICAgfSk7XG4gICAgICBpZiAoY2xpZW50TWV0YSA9PT0gdW5kZWZpbmVkICYmIHN0YXRlICE9PSBudWxsKSB7XG4gICAgICAgIGFkZGVkLnB1c2goY2xpZW50SUQpO1xuICAgICAgfSBlbHNlIGlmIChjbGllbnRNZXRhICE9PSB1bmRlZmluZWQgJiYgc3RhdGUgPT09IG51bGwpIHtcbiAgICAgICAgcmVtb3ZlZC5wdXNoKGNsaWVudElEKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKCFlcXVhbGl0eURlZXAoc3RhdGUsIHByZXZTdGF0ZSkpIHtcbiAgICAgICAgICBmaWx0ZXJlZFVwZGF0ZWQucHVzaChjbGllbnRJRCk7XG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlZC5wdXNoKGNsaWVudElEKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGFkZGVkLmxlbmd0aCA+IDAgfHwgZmlsdGVyZWRVcGRhdGVkLmxlbmd0aCA+IDAgfHwgcmVtb3ZlZC5sZW5ndGggPiAwKSB7XG4gICAgYXdhcmVuZXNzLmVtaXQoJ2NoYW5nZScsIFt7XG4gICAgICBhZGRlZCwgdXBkYXRlZDogZmlsdGVyZWRVcGRhdGVkLCByZW1vdmVkXG4gICAgfSwgb3JpZ2luXSk7XG4gIH1cbiAgaWYgKGFkZGVkLmxlbmd0aCA+IDAgfHwgdXBkYXRlZC5sZW5ndGggPiAwIHx8IHJlbW92ZWQubGVuZ3RoID4gMCkge1xuICAgIGF3YXJlbmVzcy5lbWl0KCd1cGRhdGUnLCBbe1xuICAgICAgYWRkZWQsIHVwZGF0ZWQsIHJlbW92ZWRcbiAgICB9LCBvcmlnaW5dKTtcbiAgfVxufTtcblxuY2xhc3MgRXZlbnRFbWl0dGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtZnVuY3Rpb24tdHlwZVxuICAgICAgICB0aGlzLmNhbGxiYWNrcyA9IHt9O1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1mdW5jdGlvbi10eXBlXG4gICAgb24oZXZlbnQsIGZuKSB7XG4gICAgICAgIGlmICghdGhpcy5jYWxsYmFja3NbZXZlbnRdKSB7XG4gICAgICAgICAgICB0aGlzLmNhbGxiYWNrc1tldmVudF0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhbGxiYWNrc1tldmVudF0ucHVzaChmbik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBlbWl0KGV2ZW50LCAuLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrcyA9IHRoaXMuY2FsbGJhY2tzW2V2ZW50XTtcbiAgICAgICAgaWYgKGNhbGxiYWNrcykge1xuICAgICAgICAgICAgY2FsbGJhY2tzLmZvckVhY2goY2FsbGJhY2sgPT4gY2FsbGJhY2suYXBwbHkodGhpcywgYXJncykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1mdW5jdGlvbi10eXBlXG4gICAgb2ZmKGV2ZW50LCBmbikge1xuICAgICAgICBjb25zdCBjYWxsYmFja3MgPSB0aGlzLmNhbGxiYWNrc1tldmVudF07XG4gICAgICAgIGlmIChjYWxsYmFja3MpIHtcbiAgICAgICAgICAgIGlmIChmbikge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tzW2V2ZW50XSA9IGNhbGxiYWNrcy5maWx0ZXIoY2FsbGJhY2sgPT4gY2FsbGJhY2sgIT09IGZuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmNhbGxiYWNrc1tldmVudF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJlbW92ZUFsbExpc3RlbmVycygpIHtcbiAgICAgICAgdGhpcy5jYWxsYmFja3MgPSB7fTtcbiAgICB9XG59XG5cbmNsYXNzIEluY29taW5nTWVzc2FnZSB7XG4gICAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICB0aGlzLmVuY29kZXIgPSBjcmVhdGVFbmNvZGVyKCk7XG4gICAgICAgIHRoaXMuZGVjb2RlciA9IGNyZWF0ZURlY29kZXIobmV3IFVpbnQ4QXJyYXkodGhpcy5kYXRhKSk7XG4gICAgfVxuICAgIHBlZWtWYXJTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBwZWVrVmFyU3RyaW5nKHRoaXMuZGVjb2Rlcik7XG4gICAgfVxuICAgIHJlYWRWYXJVaW50KCkge1xuICAgICAgICByZXR1cm4gcmVhZFZhclVpbnQodGhpcy5kZWNvZGVyKTtcbiAgICB9XG4gICAgcmVhZFZhclN0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHJlYWRWYXJTdHJpbmcodGhpcy5kZWNvZGVyKTtcbiAgICB9XG4gICAgcmVhZFZhclVpbnQ4QXJyYXkoKSB7XG4gICAgICAgIHJldHVybiByZWFkVmFyVWludDhBcnJheSh0aGlzLmRlY29kZXIpO1xuICAgIH1cbiAgICB3cml0ZVZhclVpbnQodHlwZSkge1xuICAgICAgICByZXR1cm4gd3JpdGVWYXJVaW50KHRoaXMuZW5jb2RlciwgdHlwZSk7XG4gICAgfVxuICAgIHdyaXRlVmFyU3RyaW5nKHN0cmluZykge1xuICAgICAgICByZXR1cm4gd3JpdGVWYXJTdHJpbmcodGhpcy5lbmNvZGVyLCBzdHJpbmcpO1xuICAgIH1cbiAgICB3cml0ZVZhclVpbnQ4QXJyYXkoZGF0YSkge1xuICAgICAgICByZXR1cm4gd3JpdGVWYXJVaW50OEFycmF5KHRoaXMuZW5jb2RlciwgZGF0YSk7XG4gICAgfVxuICAgIGxlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIGxlbmd0aCQxKHRoaXMuZW5jb2Rlcik7XG4gICAgfVxufVxuXG52YXIgTWVzc2FnZVR5cGU7XG4oZnVuY3Rpb24gKE1lc3NhZ2VUeXBlKSB7XG4gICAgTWVzc2FnZVR5cGVbTWVzc2FnZVR5cGVbXCJTeW5jXCJdID0gMF0gPSBcIlN5bmNcIjtcbiAgICBNZXNzYWdlVHlwZVtNZXNzYWdlVHlwZVtcIkF3YXJlbmVzc1wiXSA9IDFdID0gXCJBd2FyZW5lc3NcIjtcbiAgICBNZXNzYWdlVHlwZVtNZXNzYWdlVHlwZVtcIkF1dGhcIl0gPSAyXSA9IFwiQXV0aFwiO1xuICAgIE1lc3NhZ2VUeXBlW01lc3NhZ2VUeXBlW1wiUXVlcnlBd2FyZW5lc3NcIl0gPSAzXSA9IFwiUXVlcnlBd2FyZW5lc3NcIjtcbiAgICBNZXNzYWdlVHlwZVtNZXNzYWdlVHlwZVtcIlN0YXRlbGVzc1wiXSA9IDVdID0gXCJTdGF0ZWxlc3NcIjtcbiAgICBNZXNzYWdlVHlwZVtNZXNzYWdlVHlwZVtcIkNMT1NFXCJdID0gN10gPSBcIkNMT1NFXCI7XG4gICAgTWVzc2FnZVR5cGVbTWVzc2FnZVR5cGVbXCJTeW5jU3RhdHVzXCJdID0gOF0gPSBcIlN5bmNTdGF0dXNcIjtcbn0pKE1lc3NhZ2VUeXBlIHx8IChNZXNzYWdlVHlwZSA9IHt9KSk7XG52YXIgV2ViU29ja2V0U3RhdHVzO1xuKGZ1bmN0aW9uIChXZWJTb2NrZXRTdGF0dXMpIHtcbiAgICBXZWJTb2NrZXRTdGF0dXNbXCJDb25uZWN0aW5nXCJdID0gXCJjb25uZWN0aW5nXCI7XG4gICAgV2ViU29ja2V0U3RhdHVzW1wiQ29ubmVjdGVkXCJdID0gXCJjb25uZWN0ZWRcIjtcbiAgICBXZWJTb2NrZXRTdGF0dXNbXCJEaXNjb25uZWN0ZWRcIl0gPSBcImRpc2Nvbm5lY3RlZFwiO1xufSkoV2ViU29ja2V0U3RhdHVzIHx8IChXZWJTb2NrZXRTdGF0dXMgPSB7fSkpO1xuXG5jbGFzcyBPdXRnb2luZ01lc3NhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmVuY29kZXIgPSBjcmVhdGVFbmNvZGVyKCk7XG4gICAgfVxuICAgIGdldChhcmdzKSB7XG4gICAgICAgIHJldHVybiBhcmdzLmVuY29kZXI7XG4gICAgfVxuICAgIHRvVWludDhBcnJheSgpIHtcbiAgICAgICAgcmV0dXJuIHRvVWludDhBcnJheSh0aGlzLmVuY29kZXIpO1xuICAgIH1cbn1cblxuY2xhc3MgQ2xvc2VNZXNzYWdlIGV4dGVuZHMgT3V0Z29pbmdNZXNzYWdlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy50eXBlID0gTWVzc2FnZVR5cGUuQ0xPU0U7XG4gICAgICAgIHRoaXMuZGVzY3JpcHRpb24gPSAnQXNrIHRoZSBzZXJ2ZXIgdG8gY2xvc2UgdGhlIGNvbm5lY3Rpb24nO1xuICAgIH1cbiAgICBnZXQoYXJncykge1xuICAgICAgICB3cml0ZVZhclN0cmluZyh0aGlzLmVuY29kZXIsIGFyZ3MuZG9jdW1lbnROYW1lKTtcbiAgICAgICAgd3JpdGVWYXJVaW50KHRoaXMuZW5jb2RlciwgdGhpcy50eXBlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlcjtcbiAgICB9XG59XG5cbmNsYXNzIEhvY3VzcG9jdXNQcm92aWRlcldlYnNvY2tldCBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvbikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm1lc3NhZ2VRdWV1ZSA9IFtdO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24gPSB7XG4gICAgICAgICAgICB1cmw6IFwiXCIsXG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBkb2N1bWVudDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgV2ViU29ja2V0UG9seWZpbGw6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIC8vIFRPRE86IHRoaXMgc2hvdWxkIGRlcGVuZCBvbiBhd2FyZW5lc3Mub3V0ZGF0ZWRUaW1lXG4gICAgICAgICAgICBtZXNzYWdlUmVjb25uZWN0VGltZW91dDogMzAwMDAsXG4gICAgICAgICAgICAvLyAxIHNlY29uZFxuICAgICAgICAgICAgZGVsYXk6IDEwMDAsXG4gICAgICAgICAgICAvLyBpbnN0YW50XG4gICAgICAgICAgICBpbml0aWFsRGVsYXk6IDAsXG4gICAgICAgICAgICAvLyBkb3VibGUgdGhlIGRlbGF5IGVhY2ggdGltZVxuICAgICAgICAgICAgZmFjdG9yOiAyLFxuICAgICAgICAgICAgLy8gdW5saW1pdGVkIHJldHJpZXNcbiAgICAgICAgICAgIG1heEF0dGVtcHRzOiAwLFxuICAgICAgICAgICAgLy8gd2FpdCBhdCBsZWFzdCAxIHNlY29uZFxuICAgICAgICAgICAgbWluRGVsYXk6IDEwMDAsXG4gICAgICAgICAgICAvLyBhdCBsZWFzdCBldmVyeSAzMCBzZWNvbmRzXG4gICAgICAgICAgICBtYXhEZWxheTogMzAwMDAsXG4gICAgICAgICAgICAvLyByYW5kb21pemVcbiAgICAgICAgICAgIGppdHRlcjogdHJ1ZSxcbiAgICAgICAgICAgIC8vIHJldHJ5IGZvcmV2ZXJcbiAgICAgICAgICAgIHRpbWVvdXQ6IDAsXG4gICAgICAgICAgICBvbk9wZW46ICgpID0+IG51bGwsXG4gICAgICAgICAgICBvbkNvbm5lY3Q6ICgpID0+IG51bGwsXG4gICAgICAgICAgICBvbk1lc3NhZ2U6ICgpID0+IG51bGwsXG4gICAgICAgICAgICBvbk91dGdvaW5nTWVzc2FnZTogKCkgPT4gbnVsbCxcbiAgICAgICAgICAgIG9uU3RhdHVzOiAoKSA9PiBudWxsLFxuICAgICAgICAgICAgb25EaXNjb25uZWN0OiAoKSA9PiBudWxsLFxuICAgICAgICAgICAgb25DbG9zZTogKCkgPT4gbnVsbCxcbiAgICAgICAgICAgIG9uRGVzdHJveTogKCkgPT4gbnVsbCxcbiAgICAgICAgICAgIG9uQXdhcmVuZXNzVXBkYXRlOiAoKSA9PiBudWxsLFxuICAgICAgICAgICAgb25Bd2FyZW5lc3NDaGFuZ2U6ICgpID0+IG51bGwsXG4gICAgICAgICAgICBwcm92aWRlck1hcDogbmV3IE1hcCgpLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLndlYlNvY2tldCA9IG51bGw7XG4gICAgICAgIHRoaXMud2ViU29ja2V0SGFuZGxlcnMgPSB7fTtcbiAgICAgICAgdGhpcy5zaG91bGRDb25uZWN0ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBXZWJTb2NrZXRTdGF0dXMuRGlzY29ubmVjdGVkO1xuICAgICAgICB0aGlzLmxhc3RNZXNzYWdlUmVjZWl2ZWQgPSAwO1xuICAgICAgICB0aGlzLmlkZW50aWZpZXIgPSAwO1xuICAgICAgICB0aGlzLmludGVydmFscyA9IHtcbiAgICAgICAgICAgIGNvbm5lY3Rpb25DaGVja2VyOiBudWxsLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb25BdHRlbXB0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZWNlaXZlZE9uT3BlblBheWxvYWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuY2xvc2VUcmllcyA9IDA7XG4gICAgICAgIHRoaXMuc2V0Q29uZmlndXJhdGlvbihjb25maWd1cmF0aW9uKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uLldlYlNvY2tldFBvbHlmaWxsID0gY29uZmlndXJhdGlvbi5XZWJTb2NrZXRQb2x5ZmlsbFxuICAgICAgICAgICAgPyBjb25maWd1cmF0aW9uLldlYlNvY2tldFBvbHlmaWxsXG4gICAgICAgICAgICA6IFdlYlNvY2tldDtcbiAgICAgICAgdGhpcy5vbihcIm9wZW5cIiwgdGhpcy5jb25maWd1cmF0aW9uLm9uT3Blbik7XG4gICAgICAgIHRoaXMub24oXCJvcGVuXCIsIHRoaXMub25PcGVuLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLm9uKFwiY29ubmVjdFwiLCB0aGlzLmNvbmZpZ3VyYXRpb24ub25Db25uZWN0KTtcbiAgICAgICAgdGhpcy5vbihcIm1lc3NhZ2VcIiwgdGhpcy5jb25maWd1cmF0aW9uLm9uTWVzc2FnZSk7XG4gICAgICAgIHRoaXMub24oXCJvdXRnb2luZ01lc3NhZ2VcIiwgdGhpcy5jb25maWd1cmF0aW9uLm9uT3V0Z29pbmdNZXNzYWdlKTtcbiAgICAgICAgdGhpcy5vbihcInN0YXR1c1wiLCB0aGlzLmNvbmZpZ3VyYXRpb24ub25TdGF0dXMpO1xuICAgICAgICB0aGlzLm9uKFwiZGlzY29ubmVjdFwiLCB0aGlzLmNvbmZpZ3VyYXRpb24ub25EaXNjb25uZWN0KTtcbiAgICAgICAgdGhpcy5vbihcImNsb3NlXCIsIHRoaXMuY29uZmlndXJhdGlvbi5vbkNsb3NlKTtcbiAgICAgICAgdGhpcy5vbihcImRlc3Ryb3lcIiwgdGhpcy5jb25maWd1cmF0aW9uLm9uRGVzdHJveSk7XG4gICAgICAgIHRoaXMub24oXCJhd2FyZW5lc3NVcGRhdGVcIiwgdGhpcy5jb25maWd1cmF0aW9uLm9uQXdhcmVuZXNzVXBkYXRlKTtcbiAgICAgICAgdGhpcy5vbihcImF3YXJlbmVzc0NoYW5nZVwiLCB0aGlzLmNvbmZpZ3VyYXRpb24ub25Bd2FyZW5lc3NDaGFuZ2UpO1xuICAgICAgICB0aGlzLm9uKFwiY2xvc2VcIiwgdGhpcy5vbkNsb3NlLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLm9uKFwibWVzc2FnZVwiLCB0aGlzLm9uTWVzc2FnZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5pbnRlcnZhbHMuY29ubmVjdGlvbkNoZWNrZXIgPSBzZXRJbnRlcnZhbCh0aGlzLmNoZWNrQ29ubmVjdGlvbi5iaW5kKHRoaXMpLCB0aGlzLmNvbmZpZ3VyYXRpb24ubWVzc2FnZVJlY29ubmVjdFRpbWVvdXQgLyAxMCk7XG4gICAgICAgIGlmICghdGhpcy5zaG91bGRDb25uZWN0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb25uZWN0KCk7XG4gICAgfVxuICAgIGFzeW5jIG9uT3BlbihldmVudCkge1xuICAgICAgICB0aGlzLmNhbmNlbFdlYnNvY2tldFJldHJ5ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnJlY2VpdmVkT25PcGVuUGF5bG9hZCA9IGV2ZW50O1xuICAgIH1cbiAgICBhdHRhY2gocHJvdmlkZXIpIHtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uLnByb3ZpZGVyTWFwLnNldChwcm92aWRlci5jb25maWd1cmF0aW9uLm5hbWUsIHByb3ZpZGVyKTtcbiAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSBXZWJTb2NrZXRTdGF0dXMuRGlzY29ubmVjdGVkICYmIHRoaXMuc2hvdWxkQ29ubmVjdCkge1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmVjZWl2ZWRPbk9wZW5QYXlsb2FkICYmXG4gICAgICAgICAgICB0aGlzLnN0YXR1cyA9PT0gV2ViU29ja2V0U3RhdHVzLkNvbm5lY3RlZCkge1xuICAgICAgICAgICAgcHJvdmlkZXIub25PcGVuKHRoaXMucmVjZWl2ZWRPbk9wZW5QYXlsb2FkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZXRhY2gocHJvdmlkZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbi5wcm92aWRlck1hcC5oYXMocHJvdmlkZXIuY29uZmlndXJhdGlvbi5uYW1lKSkge1xuICAgICAgICAgICAgcHJvdmlkZXIuc2VuZChDbG9zZU1lc3NhZ2UsIHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudE5hbWU6IHByb3ZpZGVyLmNvbmZpZ3VyYXRpb24ubmFtZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uLnByb3ZpZGVyTWFwLmRlbGV0ZShwcm92aWRlci5jb25maWd1cmF0aW9uLm5hbWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldENvbmZpZ3VyYXRpb24oY29uZmlndXJhdGlvbiA9IHt9KSB7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvbiA9IHsgLi4udGhpcy5jb25maWd1cmF0aW9uLCAuLi5jb25maWd1cmF0aW9uIH07XG4gICAgfVxuICAgIGFzeW5jIGNvbm5lY3QoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gV2ViU29ja2V0U3RhdHVzLkNvbm5lY3RlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFsd2F5cyBjYW5jZWwgYW55IHByZXZpb3VzbHkgaW5pdGlhdGVkIGNvbm5lY3Rpb24gcmV0cnllciBpbnN0YW5jZXNcbiAgICAgICAgaWYgKHRoaXMuY2FuY2VsV2Vic29ja2V0UmV0cnkpIHtcbiAgICAgICAgICAgIHRoaXMuY2FuY2VsV2Vic29ja2V0UmV0cnkoKTtcbiAgICAgICAgICAgIHRoaXMuY2FuY2VsV2Vic29ja2V0UmV0cnkgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZWNlaXZlZE9uT3BlblBheWxvYWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuc2hvdWxkQ29ubmVjdCA9IHRydWU7XG4gICAgICAgIGNvbnN0IGFib3J0YWJsZVJldHJ5ID0gKCkgPT4ge1xuICAgICAgICAgICAgbGV0IGNhbmNlbEF0dGVtcHQgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IHJldHJ5UHJvbWlzZSA9IHJldHJ5KHRoaXMuY3JlYXRlV2ViU29ja2V0Q29ubmVjdGlvbi5iaW5kKHRoaXMpLCB7XG4gICAgICAgICAgICAgICAgZGVsYXk6IHRoaXMuY29uZmlndXJhdGlvbi5kZWxheSxcbiAgICAgICAgICAgICAgICBpbml0aWFsRGVsYXk6IHRoaXMuY29uZmlndXJhdGlvbi5pbml0aWFsRGVsYXksXG4gICAgICAgICAgICAgICAgZmFjdG9yOiB0aGlzLmNvbmZpZ3VyYXRpb24uZmFjdG9yLFxuICAgICAgICAgICAgICAgIG1heEF0dGVtcHRzOiB0aGlzLmNvbmZpZ3VyYXRpb24ubWF4QXR0ZW1wdHMsXG4gICAgICAgICAgICAgICAgbWluRGVsYXk6IHRoaXMuY29uZmlndXJhdGlvbi5taW5EZWxheSxcbiAgICAgICAgICAgICAgICBtYXhEZWxheTogdGhpcy5jb25maWd1cmF0aW9uLm1heERlbGF5LFxuICAgICAgICAgICAgICAgIGppdHRlcjogdGhpcy5jb25maWd1cmF0aW9uLmppdHRlcixcbiAgICAgICAgICAgICAgICB0aW1lb3V0OiB0aGlzLmNvbmZpZ3VyYXRpb24udGltZW91dCxcbiAgICAgICAgICAgICAgICBiZWZvcmVBdHRlbXB0OiAoY29udGV4dCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc2hvdWxkQ29ubmVjdCB8fCBjYW5jZWxBdHRlbXB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgYWJvcnRlZCB0aGUgY29ubmVjdGlvbiBhdHRlbXB0IHRoZW4gZG9u4oCZdCB0aHJvdyBhbiBlcnJvclxuICAgICAgICAgICAgICAgIC8vIHJlZjogaHR0cHM6Ly9naXRodWIuY29tL2xpZmVvbWljL2F0dGVtcHQvYmxvYi9tYXN0ZXIvc3JjL2luZGV4LnRzI0wxMzZcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IgJiYgZXJyb3IuY29kZSAhPT0gXCJBVFRFTVBUX0FCT1JURURcIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcmV0cnlQcm9taXNlLFxuICAgICAgICAgICAgICAgIGNhbmNlbEZ1bmM6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsQXR0ZW1wdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHsgcmV0cnlQcm9taXNlLCBjYW5jZWxGdW5jIH0gPSBhYm9ydGFibGVSZXRyeSgpO1xuICAgICAgICB0aGlzLmNhbmNlbFdlYnNvY2tldFJldHJ5ID0gY2FuY2VsRnVuYztcbiAgICAgICAgcmV0dXJuIHJldHJ5UHJvbWlzZTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtZnVuY3Rpb24tdHlwZVxuICAgIGF0dGFjaFdlYlNvY2tldExpc3RlbmVycyh3cywgcmVqZWN0KSB7XG4gICAgICAgIGNvbnN0IHsgaWRlbnRpZmllciB9ID0gd3M7XG4gICAgICAgIGNvbnN0IG9uTWVzc2FnZUhhbmRsZXIgPSAocGF5bG9hZCkgPT4gdGhpcy5lbWl0KFwibWVzc2FnZVwiLCBwYXlsb2FkKTtcbiAgICAgICAgY29uc3Qgb25DbG9zZUhhbmRsZXIgPSAocGF5bG9hZCkgPT4gdGhpcy5lbWl0KFwiY2xvc2VcIiwgeyBldmVudDogcGF5bG9hZCB9KTtcbiAgICAgICAgY29uc3Qgb25PcGVuSGFuZGxlciA9IChwYXlsb2FkKSA9PiB0aGlzLmVtaXQoXCJvcGVuXCIsIHBheWxvYWQpO1xuICAgICAgICBjb25zdCBvbkVycm9ySGFuZGxlciA9IChlcnIpID0+IHtcbiAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLndlYlNvY2tldEhhbmRsZXJzW2lkZW50aWZpZXJdID0ge1xuICAgICAgICAgICAgbWVzc2FnZTogb25NZXNzYWdlSGFuZGxlcixcbiAgICAgICAgICAgIGNsb3NlOiBvbkNsb3NlSGFuZGxlcixcbiAgICAgICAgICAgIG9wZW46IG9uT3BlbkhhbmRsZXIsXG4gICAgICAgICAgICBlcnJvcjogb25FcnJvckhhbmRsZXIsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGhhbmRsZXJzID0gdGhpcy53ZWJTb2NrZXRIYW5kbGVyc1t3cy5pZGVudGlmaWVyXTtcbiAgICAgICAgT2JqZWN0LmtleXMoaGFuZGxlcnMpLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgICAgICAgIHdzLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgaGFuZGxlcnNbbmFtZV0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2xlYW51cFdlYlNvY2tldCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLndlYlNvY2tldCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgaWRlbnRpZmllciB9ID0gdGhpcy53ZWJTb2NrZXQ7XG4gICAgICAgIGNvbnN0IGhhbmRsZXJzID0gdGhpcy53ZWJTb2NrZXRIYW5kbGVyc1tpZGVudGlmaWVyXTtcbiAgICAgICAgT2JqZWN0LmtleXMoaGFuZGxlcnMpLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIChfYSA9IHRoaXMud2ViU29ja2V0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCBoYW5kbGVyc1tuYW1lXSk7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy53ZWJTb2NrZXRIYW5kbGVyc1tpZGVudGlmaWVyXTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMud2ViU29ja2V0LmNsb3NlKCk7XG4gICAgICAgIHRoaXMud2ViU29ja2V0ID0gbnVsbDtcbiAgICB9XG4gICAgY3JlYXRlV2ViU29ja2V0Q29ubmVjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLndlYlNvY2tldCkge1xuICAgICAgICAgICAgICAgIHRoaXMubWVzc2FnZVF1ZXVlID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhbnVwV2ViU29ja2V0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmxhc3RNZXNzYWdlUmVjZWl2ZWQgPSAwO1xuICAgICAgICAgICAgdGhpcy5pZGVudGlmaWVyICs9IDE7XG4gICAgICAgICAgICAvLyBJbml0IHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvblxuICAgICAgICAgICAgY29uc3Qgd3MgPSBuZXcgdGhpcy5jb25maWd1cmF0aW9uLldlYlNvY2tldFBvbHlmaWxsKHRoaXMudXJsKTtcbiAgICAgICAgICAgIHdzLmJpbmFyeVR5cGUgPSBcImFycmF5YnVmZmVyXCI7XG4gICAgICAgICAgICB3cy5pZGVudGlmaWVyID0gdGhpcy5pZGVudGlmaWVyO1xuICAgICAgICAgICAgdGhpcy5hdHRhY2hXZWJTb2NrZXRMaXN0ZW5lcnMod3MsIHJlamVjdCk7XG4gICAgICAgICAgICB0aGlzLndlYlNvY2tldCA9IHdzO1xuICAgICAgICAgICAgLy8gUmVzZXQgdGhlIHN0YXR1c1xuICAgICAgICAgICAgdGhpcy5zdGF0dXMgPSBXZWJTb2NrZXRTdGF0dXMuQ29ubmVjdGluZztcbiAgICAgICAgICAgIHRoaXMuZW1pdChcInN0YXR1c1wiLCB7IHN0YXR1czogV2ViU29ja2V0U3RhdHVzLkNvbm5lY3RpbmcgfSk7XG4gICAgICAgICAgICAvLyBTdG9yZSByZXNvbHZlL3JlamVjdCBmb3IgbGF0ZXIgdXNlXG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25BdHRlbXB0ID0ge1xuICAgICAgICAgICAgICAgIHJlc29sdmUsXG4gICAgICAgICAgICAgICAgcmVqZWN0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG9uTWVzc2FnZShldmVudCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMucmVzb2x2ZUNvbm5lY3Rpb25BdHRlbXB0KCk7XG4gICAgICAgIHRoaXMubGFzdE1lc3NhZ2VSZWNlaXZlZCA9IGdldFVuaXhUaW1lKCk7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBuZXcgSW5jb21pbmdNZXNzYWdlKGV2ZW50LmRhdGEpO1xuICAgICAgICBjb25zdCBkb2N1bWVudE5hbWUgPSBtZXNzYWdlLnBlZWtWYXJTdHJpbmcoKTtcbiAgICAgICAgKF9hID0gdGhpcy5jb25maWd1cmF0aW9uLnByb3ZpZGVyTWFwLmdldChkb2N1bWVudE5hbWUpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub25NZXNzYWdlKGV2ZW50KTtcbiAgICB9XG4gICAgcmVzb2x2ZUNvbm5lY3Rpb25BdHRlbXB0KCkge1xuICAgICAgICBpZiAodGhpcy5jb25uZWN0aW9uQXR0ZW1wdCkge1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uQXR0ZW1wdC5yZXNvbHZlKCk7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25BdHRlbXB0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzID0gV2ViU29ja2V0U3RhdHVzLkNvbm5lY3RlZDtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcInN0YXR1c1wiLCB7IHN0YXR1czogV2ViU29ja2V0U3RhdHVzLkNvbm5lY3RlZCB9KTtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImNvbm5lY3RcIik7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2VRdWV1ZS5mb3JFYWNoKChtZXNzYWdlKSA9PiB0aGlzLnNlbmQobWVzc2FnZSkpO1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlUXVldWUgPSBbXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdG9wQ29ubmVjdGlvbkF0dGVtcHQoKSB7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbkF0dGVtcHQgPSBudWxsO1xuICAgIH1cbiAgICByZWplY3RDb25uZWN0aW9uQXR0ZW1wdCgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSB0aGlzLmNvbm5lY3Rpb25BdHRlbXB0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVqZWN0KCk7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbkF0dGVtcHQgPSBudWxsO1xuICAgIH1cbiAgICBjaGVja0Nvbm5lY3Rpb24oKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgLy8gRG9u4oCZdCBjaGVjayB0aGUgY29ubmVjdGlvbiB3aGVuIGl04oCZcyBub3QgZXZlbiBlc3RhYmxpc2hlZFxuICAgICAgICBpZiAodGhpcy5zdGF0dXMgIT09IFdlYlNvY2tldFN0YXR1cy5Db25uZWN0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBEb27igJl0IGNsb3NlIHRoZSBjb25uZWN0aW9uIHdoaWxlIHdhaXRpbmcgZm9yIHRoZSBmaXJzdCBtZXNzYWdlXG4gICAgICAgIGlmICghdGhpcy5sYXN0TWVzc2FnZVJlY2VpdmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gRG9u4oCZdCBjbG9zZSB0aGUgY29ubmVjdGlvbiB3aGVuIGEgbWVzc2FnZSB3YXMgcmVjZWl2ZWQgcmVjZW50bHlcbiAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbi5tZXNzYWdlUmVjb25uZWN0VGltZW91dCA+PVxuICAgICAgICAgICAgZ2V0VW5peFRpbWUoKSAtIHRoaXMubGFzdE1lc3NhZ2VSZWNlaXZlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vIG1lc3NhZ2UgcmVjZWl2ZWQgaW4gYSBsb25nIHRpbWUsIG5vdCBldmVuIHlvdXIgb3duXG4gICAgICAgIC8vIEF3YXJlbmVzcyB1cGRhdGVzLCB3aGljaCBhcmUgdXBkYXRlZCBldmVyeSAxNSBzZWNvbmRzXG4gICAgICAgIC8vIGlmIGF3YXJlbmVzcyBpcyBlbmFibGVkLlxuICAgICAgICB0aGlzLmNsb3NlVHJpZXMgKz0gMTtcbiAgICAgICAgLy8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTI0Nzk0M1xuICAgICAgICBpZiAodGhpcy5jbG9zZVRyaWVzID4gMikge1xuICAgICAgICAgICAgdGhpcy5vbkNsb3NlKHtcbiAgICAgICAgICAgICAgICBldmVudDoge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiA0NDA4LFxuICAgICAgICAgICAgICAgICAgICByZWFzb246IFwiZm9yY2VkXCIsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5jbG9zZVRyaWVzID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIChfYSA9IHRoaXMud2ViU29ja2V0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2xvc2UoKTtcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZVF1ZXVlID0gW107XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gRW5zdXJlIHRoYXQgdGhlIFVSTCBuZXZlciBlbmRzIHdpdGggL1xuICAgIGdldCBzZXJ2ZXJVcmwoKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLmNvbmZpZ3VyYXRpb24udXJsW3RoaXMuY29uZmlndXJhdGlvbi51cmwubGVuZ3RoIC0gMV0gPT09IFwiL1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25maWd1cmF0aW9uLnVybC5zbGljZSgwLCB0aGlzLmNvbmZpZ3VyYXRpb24udXJsLmxlbmd0aCAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZ3VyYXRpb24udXJsO1xuICAgIH1cbiAgICBnZXQgdXJsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXJ2ZXJVcmw7XG4gICAgfVxuICAgIGRpc2Nvbm5lY3QoKSB7XG4gICAgICAgIHRoaXMuc2hvdWxkQ29ubmVjdCA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy53ZWJTb2NrZXQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy53ZWJTb2NrZXQuY2xvc2UoKTtcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZVF1ZXVlID0gW107XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2VuZChtZXNzYWdlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCgoX2EgPSB0aGlzLndlYlNvY2tldCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlYWR5U3RhdGUpID09PSBXc1JlYWR5U3RhdGVzLk9wZW4pIHtcbiAgICAgICAgICAgIHRoaXMud2ViU29ja2V0LnNlbmQobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2VRdWV1ZS5wdXNoKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9uQ2xvc2UoeyBldmVudCB9KSB7XG4gICAgICAgIHRoaXMuY2xvc2VUcmllcyA9IDA7XG4gICAgICAgIHRoaXMuY2xlYW51cFdlYlNvY2tldCgpO1xuICAgICAgICBpZiAodGhpcy5jb25uZWN0aW9uQXR0ZW1wdCkge1xuICAgICAgICAgICAgLy8gVGhhdCBjb25uZWN0aW9uIGF0dGVtcHQgZmFpbGVkLlxuICAgICAgICAgICAgdGhpcy5yZWplY3RDb25uZWN0aW9uQXR0ZW1wdCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIExldOKAmXMgdXBkYXRlIHRoZSBjb25uZWN0aW9uIHN0YXR1cy5cbiAgICAgICAgdGhpcy5zdGF0dXMgPSBXZWJTb2NrZXRTdGF0dXMuRGlzY29ubmVjdGVkO1xuICAgICAgICB0aGlzLmVtaXQoXCJzdGF0dXNcIiwgeyBzdGF0dXM6IFdlYlNvY2tldFN0YXR1cy5EaXNjb25uZWN0ZWQgfSk7XG4gICAgICAgIHRoaXMuZW1pdChcImRpc2Nvbm5lY3RcIiwgeyBldmVudCB9KTtcbiAgICAgICAgLy8gdHJpZ2dlciBjb25uZWN0IGlmIG5vIHJldHJ5IGlzIHJ1bm5pbmcgYW5kIHdlIHdhbnQgdG8gaGF2ZSBhIGNvbm5lY3Rpb25cbiAgICAgICAgaWYgKCF0aGlzLmNhbmNlbFdlYnNvY2tldFJldHJ5ICYmIHRoaXMuc2hvdWxkQ29ubmVjdCkge1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0KCk7XG4gICAgICAgICAgICB9LCB0aGlzLmNvbmZpZ3VyYXRpb24uZGVsYXkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZW1pdChcImRlc3Ryb3lcIik7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5pbnRlcnZhbHMuY29ubmVjdGlvbkNoZWNrZXIpO1xuICAgICAgICAvLyBJZiB0aGVyZSBpcyBzdGlsbCBhIGNvbm5lY3Rpb24gYXR0ZW1wdCBvdXRzdGFuZGluZyB0aGVuIHdlIHNob3VsZCBzdG9wXG4gICAgICAgIC8vIGl0IGJlZm9yZSBjYWxsaW5nIGRpc2Nvbm5lY3QsIG90aGVyd2lzZSBpdCB3aWxsIGJlIHJlamVjdGVkIGluIHRoZSBvbkNsb3NlXG4gICAgICAgIC8vIGhhbmRsZXIgYW5kIHRyaWdnZXIgYSByZXRyeVxuICAgICAgICB0aGlzLnN0b3BDb25uZWN0aW9uQXR0ZW1wdCgpO1xuICAgICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgICAgdGhpcy5jbGVhbnVwV2ViU29ja2V0KCk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBtb2R1bGUgc3luYy1wcm90b2NvbFxuICovXG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7TWFwPG51bWJlciwgbnVtYmVyPn0gU3RhdGVNYXBcbiAqL1xuXG4vKipcbiAqIENvcmUgWWpzIGRlZmluZXMgdHdvIG1lc3NhZ2UgdHlwZXM6XG4gKiDigKIgWWpzU3luY1N0ZXAxOiBJbmNsdWRlcyB0aGUgU3RhdGUgU2V0IG9mIHRoZSBzZW5kaW5nIGNsaWVudC4gV2hlbiByZWNlaXZlZCwgdGhlIGNsaWVudCBzaG91bGQgcmVwbHkgd2l0aCBZanNTeW5jU3RlcDIuXG4gKiDigKIgWWpzU3luY1N0ZXAyOiBJbmNsdWRlcyBhbGwgbWlzc2luZyBzdHJ1Y3RzIGFuZCB0aGUgY29tcGxldGUgZGVsZXRlIHNldC4gV2hlbiByZWNlaXZlZCwgdGhlIGNsaWVudCBpcyBhc3N1cmVkIHRoYXQgaXRcbiAqICAgcmVjZWl2ZWQgYWxsIGluZm9ybWF0aW9uIGZyb20gdGhlIHJlbW90ZSBjbGllbnQuXG4gKlxuICogSW4gYSBwZWVyLXRvLXBlZXIgbmV0d29yaywgeW91IG1heSB3YW50IHRvIGludHJvZHVjZSBhIFN5bmNEb25lIG1lc3NhZ2UgdHlwZS4gQm90aCBwYXJ0aWVzIHNob3VsZCBpbml0aWF0ZSB0aGUgY29ubmVjdGlvblxuICogd2l0aCBTeW5jU3RlcDEuIFdoZW4gYSBjbGllbnQgcmVjZWl2ZWQgU3luY1N0ZXAyLCBpdCBzaG91bGQgcmVwbHkgd2l0aCBTeW5jRG9uZS4gV2hlbiB0aGUgbG9jYWwgY2xpZW50IHJlY2VpdmVkIGJvdGhcbiAqIFN5bmNTdGVwMiBhbmQgU3luY0RvbmUsIGl0IGlzIGFzc3VyZWQgdGhhdCBpdCBpcyBzeW5jZWQgdG8gdGhlIHJlbW90ZSBjbGllbnQuXG4gKlxuICogSW4gYSBjbGllbnQtc2VydmVyIG1vZGVsLCB5b3Ugd2FudCB0byBoYW5kbGUgdGhpcyBkaWZmZXJlbnRseTogVGhlIGNsaWVudCBzaG91bGQgaW5pdGlhdGUgdGhlIGNvbm5lY3Rpb24gd2l0aCBTeW5jU3RlcDEuXG4gKiBXaGVuIHRoZSBzZXJ2ZXIgcmVjZWl2ZXMgU3luY1N0ZXAxLCBpdCBzaG91bGQgcmVwbHkgd2l0aCBTeW5jU3RlcDIgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgU3luY1N0ZXAxLiBUaGUgY2xpZW50IHJlcGxpZXNcbiAqIHdpdGggU3luY1N0ZXAyIHdoZW4gaXQgcmVjZWl2ZXMgU3luY1N0ZXAxLiBPcHRpb25hbGx5IHRoZSBzZXJ2ZXIgbWF5IHNlbmQgYSBTeW5jRG9uZSBhZnRlciBpdCByZWNlaXZlZCBTeW5jU3RlcDIsIHNvIHRoZVxuICogY2xpZW50IGtub3dzIHRoYXQgdGhlIHN5bmMgaXMgZmluaXNoZWQuICBUaGVyZSBhcmUgdHdvIHJlYXNvbnMgZm9yIHRoaXMgbW9yZSBlbGFib3JhdGVkIHN5bmMgbW9kZWw6IDEuIFRoaXMgcHJvdG9jb2wgY2FuXG4gKiBlYXNpbHkgYmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mIGh0dHAgYW5kIHdlYnNvY2tldHMuIDIuIFRoZSBzZXJ2ZXIgc2hvdWxkIG9ubHkgcmVwbHkgdG8gcmVxdWVzdHMsIGFuZCBub3QgaW5pdGlhdGUgdGhlbS5cbiAqIFRoZXJlZm9yZSBpdCBpcyBuZWNlc3NhcnkgdGhhdCB0aGUgY2xpZW50IGluaXRpYXRlcyB0aGUgc3luYy5cbiAqXG4gKiBDb25zdHJ1Y3Rpb24gb2YgYSBtZXNzYWdlOlxuICogW21lc3NhZ2VUeXBlIDogdmFyVWludCwgbWVzc2FnZSBkZWZpbml0aW9uLi5dXG4gKlxuICogTm90ZTogQSBtZXNzYWdlIGRvZXMgbm90IGluY2x1ZGUgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHJvb20gbmFtZS4gVGhpcyBtdXN0IHRvIGJlIGhhbmRsZWQgYnkgdGhlIHVwcGVyIGxheWVyIHByb3RvY29sIVxuICpcbiAqIHN0cmluZ2lmeVttZXNzYWdlVHlwZV0gc3RyaW5naWZpZXMgYSBtZXNzYWdlIGRlZmluaXRpb24gKG1lc3NhZ2VUeXBlIGlzIGFscmVhZHkgcmVhZCBmcm9tIHRoZSBidWZmZmVyKVxuICovXG5cbmNvbnN0IG1lc3NhZ2VZanNTeW5jU3RlcDEgPSAwO1xuY29uc3QgbWVzc2FnZVlqc1N5bmNTdGVwMiA9IDE7XG5jb25zdCBtZXNzYWdlWWpzVXBkYXRlID0gMjtcblxuLyoqXG4gKiBDcmVhdGUgYSBzeW5jIHN0ZXAgMSBtZXNzYWdlIGJhc2VkIG9uIHRoZSBzdGF0ZSBvZiB0aGUgY3VycmVudCBzaGFyZWQgZG9jdW1lbnQuXG4gKlxuICogQHBhcmFtIHtlbmNvZGluZy5FbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge1kuRG9jfSBkb2NcbiAqL1xuY29uc3Qgd3JpdGVTeW5jU3RlcDEgPSAoZW5jb2RlciwgZG9jKSA9PiB7XG4gIHdyaXRlVmFyVWludChlbmNvZGVyLCBtZXNzYWdlWWpzU3luY1N0ZXAxKTtcbiAgY29uc3Qgc3YgPSBZLmVuY29kZVN0YXRlVmVjdG9yKGRvYyk7XG4gIHdyaXRlVmFyVWludDhBcnJheShlbmNvZGVyLCBzdik7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7ZW5jb2RpbmcuRW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtZLkRvY30gZG9jXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IFtlbmNvZGVkU3RhdGVWZWN0b3JdXG4gKi9cbmNvbnN0IHdyaXRlU3luY1N0ZXAyID0gKGVuY29kZXIsIGRvYywgZW5jb2RlZFN0YXRlVmVjdG9yKSA9PiB7XG4gIHdyaXRlVmFyVWludChlbmNvZGVyLCBtZXNzYWdlWWpzU3luY1N0ZXAyKTtcbiAgd3JpdGVWYXJVaW50OEFycmF5KGVuY29kZXIsIFkuZW5jb2RlU3RhdGVBc1VwZGF0ZShkb2MsIGVuY29kZWRTdGF0ZVZlY3RvcikpO1xufTtcblxuLyoqXG4gKiBSZWFkIFN5bmNTdGVwMSBtZXNzYWdlIGFuZCByZXBseSB3aXRoIFN5bmNTdGVwMi5cbiAqXG4gKiBAcGFyYW0ge2RlY29kaW5nLkRlY29kZXJ9IGRlY29kZXIgVGhlIHJlcGx5IHRvIHRoZSByZWNlaXZlZCBtZXNzYWdlXG4gKiBAcGFyYW0ge2VuY29kaW5nLkVuY29kZXJ9IGVuY29kZXIgVGhlIHJlY2VpdmVkIG1lc3NhZ2VcbiAqIEBwYXJhbSB7WS5Eb2N9IGRvY1xuICovXG5jb25zdCByZWFkU3luY1N0ZXAxID0gKGRlY29kZXIsIGVuY29kZXIsIGRvYykgPT5cbiAgd3JpdGVTeW5jU3RlcDIoZW5jb2RlciwgZG9jLCByZWFkVmFyVWludDhBcnJheShkZWNvZGVyKSk7XG5cbi8qKlxuICogUmVhZCBhbmQgYXBwbHkgU3RydWN0cyBhbmQgdGhlbiBEZWxldGVTdG9yZSB0byBhIHkgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIHtkZWNvZGluZy5EZWNvZGVyfSBkZWNvZGVyXG4gKiBAcGFyYW0ge1kuRG9jfSBkb2NcbiAqIEBwYXJhbSB7YW55fSB0cmFuc2FjdGlvbk9yaWdpblxuICovXG5jb25zdCByZWFkU3luY1N0ZXAyID0gKGRlY29kZXIsIGRvYywgdHJhbnNhY3Rpb25PcmlnaW4pID0+IHtcbiAgdHJ5IHtcbiAgICBZLmFwcGx5VXBkYXRlKGRvYywgcmVhZFZhclVpbnQ4QXJyYXkoZGVjb2RlciksIHRyYW5zYWN0aW9uT3JpZ2luKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAvLyBUaGlzIGNhdGNoZXMgZXJyb3JzIHRoYXQgYXJlIHRocm93biBieSBldmVudCBoYW5kbGVyc1xuICAgIGNvbnNvbGUuZXJyb3IoJ0NhdWdodCBlcnJvciB3aGlsZSBoYW5kbGluZyBhIFlqcyB1cGRhdGUnLCBlcnJvcik7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtlbmNvZGluZy5FbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVwZGF0ZVxuICovXG5jb25zdCB3cml0ZVVwZGF0ZSA9IChlbmNvZGVyLCB1cGRhdGUpID0+IHtcbiAgd3JpdGVWYXJVaW50KGVuY29kZXIsIG1lc3NhZ2VZanNVcGRhdGUpO1xuICB3cml0ZVZhclVpbnQ4QXJyYXkoZW5jb2RlciwgdXBkYXRlKTtcbn07XG5cbi8qKlxuICogUmVhZCBhbmQgYXBwbHkgU3RydWN0cyBhbmQgdGhlbiBEZWxldGVTdG9yZSB0byBhIHkgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIHtkZWNvZGluZy5EZWNvZGVyfSBkZWNvZGVyXG4gKiBAcGFyYW0ge1kuRG9jfSBkb2NcbiAqIEBwYXJhbSB7YW55fSB0cmFuc2FjdGlvbk9yaWdpblxuICovXG5jb25zdCByZWFkVXBkYXRlID0gcmVhZFN5bmNTdGVwMjtcblxuLyoqXG4gKiBAcGFyYW0ge2RlY29kaW5nLkRlY29kZXJ9IGRlY29kZXIgQSBtZXNzYWdlIHJlY2VpdmVkIGZyb20gYW5vdGhlciBjbGllbnRcbiAqIEBwYXJhbSB7ZW5jb2RpbmcuRW5jb2Rlcn0gZW5jb2RlciBUaGUgcmVwbHkgbWVzc2FnZS4gRG9lcyBub3QgbmVlZCB0byBiZSBzZW50IGlmIGVtcHR5LlxuICogQHBhcmFtIHtZLkRvY30gZG9jXG4gKiBAcGFyYW0ge2FueX0gdHJhbnNhY3Rpb25PcmlnaW5cbiAqL1xuY29uc3QgcmVhZFN5bmNNZXNzYWdlID0gKGRlY29kZXIsIGVuY29kZXIsIGRvYywgdHJhbnNhY3Rpb25PcmlnaW4pID0+IHtcbiAgY29uc3QgbWVzc2FnZVR5cGUgPSByZWFkVmFyVWludChkZWNvZGVyKTtcbiAgc3dpdGNoIChtZXNzYWdlVHlwZSkge1xuICAgIGNhc2UgbWVzc2FnZVlqc1N5bmNTdGVwMTpcbiAgICAgIHJlYWRTeW5jU3RlcDEoZGVjb2RlciwgZW5jb2RlciwgZG9jKTtcbiAgICAgIGJyZWFrXG4gICAgY2FzZSBtZXNzYWdlWWpzU3luY1N0ZXAyOlxuICAgICAgcmVhZFN5bmNTdGVwMihkZWNvZGVyLCBkb2MsIHRyYW5zYWN0aW9uT3JpZ2luKTtcbiAgICAgIGJyZWFrXG4gICAgY2FzZSBtZXNzYWdlWWpzVXBkYXRlOlxuICAgICAgcmVhZFVwZGF0ZShkZWNvZGVyLCBkb2MsIHRyYW5zYWN0aW9uT3JpZ2luKTtcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBtZXNzYWdlIHR5cGUnKVxuICB9XG4gIHJldHVybiBtZXNzYWdlVHlwZVxufTtcblxuY2xhc3MgTWVzc2FnZVJlY2VpdmVyIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgfVxuICAgIGFwcGx5KHByb3ZpZGVyLCBlbWl0U3luY2VkKSB7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZSB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgdHlwZSA9IG1lc3NhZ2UucmVhZFZhclVpbnQoKTtcbiAgICAgICAgY29uc3QgZW1wdHlNZXNzYWdlTGVuZ3RoID0gbWVzc2FnZS5sZW5ndGgoKTtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLlN5bmM6XG4gICAgICAgICAgICAgICAgdGhpcy5hcHBseVN5bmNNZXNzYWdlKHByb3ZpZGVyLCBlbWl0U3luY2VkKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuQXdhcmVuZXNzOlxuICAgICAgICAgICAgICAgIHRoaXMuYXBwbHlBd2FyZW5lc3NNZXNzYWdlKHByb3ZpZGVyKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuQXV0aDpcbiAgICAgICAgICAgICAgICB0aGlzLmFwcGx5QXV0aE1lc3NhZ2UocHJvdmlkZXIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBNZXNzYWdlVHlwZS5RdWVyeUF3YXJlbmVzczpcbiAgICAgICAgICAgICAgICB0aGlzLmFwcGx5UXVlcnlBd2FyZW5lc3NNZXNzYWdlKHByb3ZpZGVyKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuU3RhdGVsZXNzOlxuICAgICAgICAgICAgICAgIHByb3ZpZGVyLnJlY2VpdmVTdGF0ZWxlc3MocmVhZFZhclN0cmluZyhtZXNzYWdlLmRlY29kZXIpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuU3luY1N0YXR1czpcbiAgICAgICAgICAgICAgICB0aGlzLmFwcGx5U3luY1N0YXR1c01lc3NhZ2UocHJvdmlkZXIsIHJlYWRWYXJJbnQobWVzc2FnZS5kZWNvZGVyKSA9PT0gMSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLkNMT1NFOlxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jYXNlLWRlY2xhcmF0aW9uc1xuICAgICAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0ge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiAxMDAwLFxuICAgICAgICAgICAgICAgICAgICByZWFzb246IHJlYWRWYXJTdHJpbmcobWVzc2FnZS5kZWNvZGVyKSxcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IHByb3ZpZGVyLmNvbmZpZ3VyYXRpb24ud2Vic29ja2V0UHJvdmlkZXIud2ViU29ja2V0LFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnY2xvc2UnLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcHJvdmlkZXIub25DbG9zZSgpO1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyLmNvbmZpZ3VyYXRpb24ub25DbG9zZSh7IGV2ZW50IH0pO1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyLmZvcndhcmRDbG9zZShldmVudCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fu4oCZdCBhcHBseSBtZXNzYWdlIG9mIHVua25vd24gdHlwZTogJHt0eXBlfWApO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlcGx5XG4gICAgICAgIGlmIChtZXNzYWdlLmxlbmd0aCgpID4gZW1wdHlNZXNzYWdlTGVuZ3RoICsgMSkgeyAvLyBsZW5ndGggb2YgZG9jdW1lbnROYW1lIChjb25zaWRlcmVkIGluIGVtcHR5TWVzc2FnZUxlbmd0aCBwbHVzIGxlbmd0aCBvZiB5anMgc3luYyB0eXBlLCBzZXQgaW4gYXBwbHlTeW5jTWVzc2FnZSlcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIHByb3ZpZGVyLnNlbmQoT3V0Z29pbmdNZXNzYWdlLCB7IGVuY29kZXI6IG1lc3NhZ2UuZW5jb2RlciB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhcHBseVN5bmNNZXNzYWdlKHByb3ZpZGVyLCBlbWl0U3luY2VkKSB7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZSB9ID0gdGhpcztcbiAgICAgICAgbWVzc2FnZS53cml0ZVZhclVpbnQoTWVzc2FnZVR5cGUuU3luYyk7XG4gICAgICAgIC8vIEFwcGx5IHVwZGF0ZVxuICAgICAgICBjb25zdCBzeW5jTWVzc2FnZVR5cGUgPSByZWFkU3luY01lc3NhZ2UobWVzc2FnZS5kZWNvZGVyLCBtZXNzYWdlLmVuY29kZXIsIHByb3ZpZGVyLmRvY3VtZW50LCBwcm92aWRlcik7XG4gICAgICAgIC8vIFN5bmNlZCBvbmNlIHdlIHJlY2VpdmUgU3RlcDJcbiAgICAgICAgaWYgKGVtaXRTeW5jZWQgJiYgc3luY01lc3NhZ2VUeXBlID09PSBtZXNzYWdlWWpzU3luY1N0ZXAyKSB7XG4gICAgICAgICAgICBwcm92aWRlci5zeW5jZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFwcGx5U3luY1N0YXR1c01lc3NhZ2UocHJvdmlkZXIsIGFwcGxpZWQpIHtcbiAgICAgICAgaWYgKGFwcGxpZWQpIHtcbiAgICAgICAgICAgIHByb3ZpZGVyLmRlY3JlbWVudFVuc3luY2VkQ2hhbmdlcygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFwcGx5QXdhcmVuZXNzTWVzc2FnZShwcm92aWRlcikge1xuICAgICAgICBpZiAoIXByb3ZpZGVyLmF3YXJlbmVzcylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlIH0gPSB0aGlzO1xuICAgICAgICBhcHBseUF3YXJlbmVzc1VwZGF0ZShwcm92aWRlci5hd2FyZW5lc3MsIG1lc3NhZ2UucmVhZFZhclVpbnQ4QXJyYXkoKSwgcHJvdmlkZXIpO1xuICAgIH1cbiAgICBhcHBseUF1dGhNZXNzYWdlKHByb3ZpZGVyKSB7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZSB9ID0gdGhpcztcbiAgICAgICAgcmVhZEF1dGhNZXNzYWdlKG1lc3NhZ2UuZGVjb2RlciwgcHJvdmlkZXIucGVybWlzc2lvbkRlbmllZEhhbmRsZXIuYmluZChwcm92aWRlciksIHByb3ZpZGVyLmF1dGhlbnRpY2F0ZWRIYW5kbGVyLmJpbmQocHJvdmlkZXIpKTtcbiAgICB9XG4gICAgYXBwbHlRdWVyeUF3YXJlbmVzc01lc3NhZ2UocHJvdmlkZXIpIHtcbiAgICAgICAgaWYgKCFwcm92aWRlci5hd2FyZW5lc3MpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZSB9ID0gdGhpcztcbiAgICAgICAgbWVzc2FnZS53cml0ZVZhclVpbnQoTWVzc2FnZVR5cGUuQXdhcmVuZXNzKTtcbiAgICAgICAgbWVzc2FnZS53cml0ZVZhclVpbnQ4QXJyYXkoZW5jb2RlQXdhcmVuZXNzVXBkYXRlKHByb3ZpZGVyLmF3YXJlbmVzcywgQXJyYXkuZnJvbShwcm92aWRlci5hd2FyZW5lc3MuZ2V0U3RhdGVzKCkua2V5cygpKSkpO1xuICAgIH1cbn1cblxuY2xhc3MgTWVzc2FnZVNlbmRlciB7XG4gICAgY29uc3RydWN0b3IoTWVzc2FnZSwgYXJncyA9IHt9KSB7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG5ldyBNZXNzYWdlKCk7XG4gICAgICAgIHRoaXMuZW5jb2RlciA9IHRoaXMubWVzc2FnZS5nZXQoYXJncyk7XG4gICAgfVxuICAgIGNyZWF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRvVWludDhBcnJheSh0aGlzLmVuY29kZXIpO1xuICAgIH1cbiAgICBzZW5kKHdlYlNvY2tldCkge1xuICAgICAgICB3ZWJTb2NrZXQgPT09IG51bGwgfHwgd2ViU29ja2V0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB3ZWJTb2NrZXQuc2VuZCh0aGlzLmNyZWF0ZSgpKTtcbiAgICB9XG59XG5cbmNsYXNzIEF1dGhlbnRpY2F0aW9uTWVzc2FnZSBleHRlbmRzIE91dGdvaW5nTWVzc2FnZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMudHlwZSA9IE1lc3NhZ2VUeXBlLkF1dGg7XG4gICAgICAgIHRoaXMuZGVzY3JpcHRpb24gPSAnQXV0aGVudGljYXRpb24nO1xuICAgIH1cbiAgICBnZXQoYXJncykge1xuICAgICAgICBpZiAodHlwZW9mIGFyZ3MudG9rZW4gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBhdXRoZW50aWNhdGlvbiBtZXNzYWdlIHJlcXVpcmVzIGB0b2tlbmAgYXMgYW4gYXJndW1lbnQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgd3JpdGVWYXJTdHJpbmcodGhpcy5lbmNvZGVyLCBhcmdzLmRvY3VtZW50TmFtZSk7XG4gICAgICAgIHdyaXRlVmFyVWludCh0aGlzLmVuY29kZXIsIHRoaXMudHlwZSk7XG4gICAgICAgIHdyaXRlQXV0aGVudGljYXRpb24odGhpcy5lbmNvZGVyLCBhcmdzLnRva2VuKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlcjtcbiAgICB9XG59XG5cbmNsYXNzIEF3YXJlbmVzc01lc3NhZ2UgZXh0ZW5kcyBPdXRnb2luZ01lc3NhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnR5cGUgPSBNZXNzYWdlVHlwZS5Bd2FyZW5lc3M7XG4gICAgICAgIHRoaXMuZGVzY3JpcHRpb24gPSAnQXdhcmVuZXNzIHN0YXRlcyB1cGRhdGUnO1xuICAgIH1cbiAgICBnZXQoYXJncykge1xuICAgICAgICBpZiAodHlwZW9mIGFyZ3MuYXdhcmVuZXNzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgYXdhcmVuZXNzIG1lc3NhZ2UgcmVxdWlyZXMgYXdhcmVuZXNzIGFzIGFuIGFyZ3VtZW50Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBhcmdzLmNsaWVudHMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBhd2FyZW5lc3MgbWVzc2FnZSByZXF1aXJlcyBjbGllbnRzIGFzIGFuIGFyZ3VtZW50Jyk7XG4gICAgICAgIH1cbiAgICAgICAgd3JpdGVWYXJTdHJpbmcodGhpcy5lbmNvZGVyLCBhcmdzLmRvY3VtZW50TmFtZSk7XG4gICAgICAgIHdyaXRlVmFyVWludCh0aGlzLmVuY29kZXIsIHRoaXMudHlwZSk7XG4gICAgICAgIGxldCBhd2FyZW5lc3NVcGRhdGU7XG4gICAgICAgIGlmIChhcmdzLnN0YXRlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhd2FyZW5lc3NVcGRhdGUgPSBlbmNvZGVBd2FyZW5lc3NVcGRhdGUoYXJncy5hd2FyZW5lc3MsIGFyZ3MuY2xpZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhd2FyZW5lc3NVcGRhdGUgPSBlbmNvZGVBd2FyZW5lc3NVcGRhdGUoYXJncy5hd2FyZW5lc3MsIGFyZ3MuY2xpZW50cywgYXJncy5zdGF0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIHdyaXRlVmFyVWludDhBcnJheSh0aGlzLmVuY29kZXIsIGF3YXJlbmVzc1VwZGF0ZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmVuY29kZXI7XG4gICAgfVxufVxuXG5jbGFzcyBTdGF0ZWxlc3NNZXNzYWdlIGV4dGVuZHMgT3V0Z29pbmdNZXNzYWdlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy50eXBlID0gTWVzc2FnZVR5cGUuU3RhdGVsZXNzO1xuICAgICAgICB0aGlzLmRlc2NyaXB0aW9uID0gJ0Egc3RhdGVsZXNzIG1lc3NhZ2UnO1xuICAgIH1cbiAgICBnZXQoYXJncykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHdyaXRlVmFyU3RyaW5nKHRoaXMuZW5jb2RlciwgYXJncy5kb2N1bWVudE5hbWUpO1xuICAgICAgICB3cml0ZVZhclVpbnQodGhpcy5lbmNvZGVyLCB0aGlzLnR5cGUpO1xuICAgICAgICB3cml0ZVZhclN0cmluZyh0aGlzLmVuY29kZXIsIChfYSA9IGFyZ3MucGF5bG9hZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJycpO1xuICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGVyO1xuICAgIH1cbn1cblxuY2xhc3MgU3luY1N0ZXBPbmVNZXNzYWdlIGV4dGVuZHMgT3V0Z29pbmdNZXNzYWdlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy50eXBlID0gTWVzc2FnZVR5cGUuU3luYztcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9ICdGaXJzdCBzeW5jIHN0ZXAnO1xuICAgIH1cbiAgICBnZXQoYXJncykge1xuICAgICAgICBpZiAodHlwZW9mIGFyZ3MuZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBzeW5jIHN0ZXAgb25lIG1lc3NhZ2UgcmVxdWlyZXMgZG9jdW1lbnQgYXMgYW4gYXJndW1lbnQnKTtcbiAgICAgICAgfVxuICAgICAgICB3cml0ZVZhclN0cmluZyh0aGlzLmVuY29kZXIsIGFyZ3MuZG9jdW1lbnROYW1lKTtcbiAgICAgICAgd3JpdGVWYXJVaW50KHRoaXMuZW5jb2RlciwgdGhpcy50eXBlKTtcbiAgICAgICAgd3JpdGVTeW5jU3RlcDEodGhpcy5lbmNvZGVyLCBhcmdzLmRvY3VtZW50KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlcjtcbiAgICB9XG59XG5cbmNsYXNzIFVwZGF0ZU1lc3NhZ2UgZXh0ZW5kcyBPdXRnb2luZ01lc3NhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnR5cGUgPSBNZXNzYWdlVHlwZS5TeW5jO1xuICAgICAgICB0aGlzLmRlc2NyaXB0aW9uID0gJ0EgZG9jdW1lbnQgdXBkYXRlJztcbiAgICB9XG4gICAgZ2V0KGFyZ3MpIHtcbiAgICAgICAgd3JpdGVWYXJTdHJpbmcodGhpcy5lbmNvZGVyLCBhcmdzLmRvY3VtZW50TmFtZSk7XG4gICAgICAgIHdyaXRlVmFyVWludCh0aGlzLmVuY29kZXIsIHRoaXMudHlwZSk7XG4gICAgICAgIHdyaXRlVXBkYXRlKHRoaXMuZW5jb2RlciwgYXJncy51cGRhdGUpO1xuICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGVyO1xuICAgIH1cbn1cblxuY2xhc3MgQXdhcmVuZXNzRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuY29kZSA9IDEwMDE7XG4gICAgfVxufVxuY2xhc3MgSG9jdXNwb2N1c1Byb3ZpZGVyIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24gPSB7XG4gICAgICAgICAgICBuYW1lOiAnJyxcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGRvY3VtZW50OiB1bmRlZmluZWQsXG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBhd2FyZW5lc3M6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHRva2VuOiBudWxsLFxuICAgICAgICAgICAgZm9yY2VTeW5jSW50ZXJ2YWw6IGZhbHNlLFxuICAgICAgICAgICAgb25BdXRoZW50aWNhdGVkOiAoKSA9PiBudWxsLFxuICAgICAgICAgICAgb25BdXRoZW50aWNhdGlvbkZhaWxlZDogKCkgPT4gbnVsbCxcbiAgICAgICAgICAgIG9uT3BlbjogKCkgPT4gbnVsbCxcbiAgICAgICAgICAgIG9uQ29ubmVjdDogKCkgPT4gbnVsbCxcbiAgICAgICAgICAgIG9uTWVzc2FnZTogKCkgPT4gbnVsbCxcbiAgICAgICAgICAgIG9uT3V0Z29pbmdNZXNzYWdlOiAoKSA9PiBudWxsLFxuICAgICAgICAgICAgb25TeW5jZWQ6ICgpID0+IG51bGwsXG4gICAgICAgICAgICBvbkRpc2Nvbm5lY3Q6ICgpID0+IG51bGwsXG4gICAgICAgICAgICBvbkNsb3NlOiAoKSA9PiBudWxsLFxuICAgICAgICAgICAgb25EZXN0cm95OiAoKSA9PiBudWxsLFxuICAgICAgICAgICAgb25Bd2FyZW5lc3NVcGRhdGU6ICgpID0+IG51bGwsXG4gICAgICAgICAgICBvbkF3YXJlbmVzc0NoYW5nZTogKCkgPT4gbnVsbCxcbiAgICAgICAgICAgIG9uU3RhdGVsZXNzOiAoKSA9PiBudWxsLFxuICAgICAgICAgICAgb25VbnN5bmNlZENoYW5nZXM6ICgpID0+IG51bGwsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaXNTeW5jZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy51bnN5bmNlZENoYW5nZXMgPSAwO1xuICAgICAgICB0aGlzLmlzQXV0aGVudGljYXRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmF1dGhvcml6ZWRTY29wZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgLy8gQGludGVybmFsXG4gICAgICAgIHRoaXMubWFuYWdlU29ja2V0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lzQXR0YWNoZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pbnRlcnZhbHMgPSB7XG4gICAgICAgICAgICBmb3JjZVN5bmM6IG51bGwsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYm91bmREb2N1bWVudFVwZGF0ZUhhbmRsZXIgPSB0aGlzLmRvY3VtZW50VXBkYXRlSGFuZGxlci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmJvdW5kQXdhcmVuZXNzVXBkYXRlSGFuZGxlciA9IHRoaXMuYXdhcmVuZXNzVXBkYXRlSGFuZGxlci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmJvdW5kUGFnZUhpZGUgPSB0aGlzLnBhZ2VIaWRlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYm91bmRPbk9wZW4gPSB0aGlzLm9uT3Blbi5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmJvdW5kT25DbG9zZSA9IHRoaXMub25DbG9zZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmZvcndhcmRDb25uZWN0ID0gKGUpID0+IHRoaXMuZW1pdCgnY29ubmVjdCcsIGUpO1xuICAgICAgICB0aGlzLmZvcndhcmRDbG9zZSA9IChlKSA9PiB0aGlzLmVtaXQoJ2Nsb3NlJywgZSk7XG4gICAgICAgIHRoaXMuZm9yd2FyZERpc2Nvbm5lY3QgPSAoZSkgPT4gdGhpcy5lbWl0KCdkaXNjb25uZWN0JywgZSk7XG4gICAgICAgIHRoaXMuZm9yd2FyZERlc3Ryb3kgPSAoZSkgPT4gdGhpcy5lbWl0KCdkZXN0cm95JywgZSk7XG4gICAgICAgIHRoaXMuc2V0Q29uZmlndXJhdGlvbihjb25maWd1cmF0aW9uKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uLmRvY3VtZW50ID0gY29uZmlndXJhdGlvbi5kb2N1bWVudCA/IGNvbmZpZ3VyYXRpb24uZG9jdW1lbnQgOiBuZXcgWS5Eb2MoKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uLmF3YXJlbmVzcyA9IGNvbmZpZ3VyYXRpb24uYXdhcmVuZXNzICE9PSB1bmRlZmluZWQgPyBjb25maWd1cmF0aW9uLmF3YXJlbmVzcyA6IG5ldyBBd2FyZW5lc3ModGhpcy5kb2N1bWVudCk7XG4gICAgICAgIHRoaXMub24oJ29wZW4nLCB0aGlzLmNvbmZpZ3VyYXRpb24ub25PcGVuKTtcbiAgICAgICAgdGhpcy5vbignbWVzc2FnZScsIHRoaXMuY29uZmlndXJhdGlvbi5vbk1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm9uKCdvdXRnb2luZ01lc3NhZ2UnLCB0aGlzLmNvbmZpZ3VyYXRpb24ub25PdXRnb2luZ01lc3NhZ2UpO1xuICAgICAgICB0aGlzLm9uKCdzeW5jZWQnLCB0aGlzLmNvbmZpZ3VyYXRpb24ub25TeW5jZWQpO1xuICAgICAgICB0aGlzLm9uKCdkZXN0cm95JywgdGhpcy5jb25maWd1cmF0aW9uLm9uRGVzdHJveSk7XG4gICAgICAgIHRoaXMub24oJ2F3YXJlbmVzc1VwZGF0ZScsIHRoaXMuY29uZmlndXJhdGlvbi5vbkF3YXJlbmVzc1VwZGF0ZSk7XG4gICAgICAgIHRoaXMub24oJ2F3YXJlbmVzc0NoYW5nZScsIHRoaXMuY29uZmlndXJhdGlvbi5vbkF3YXJlbmVzc0NoYW5nZSk7XG4gICAgICAgIHRoaXMub24oJ3N0YXRlbGVzcycsIHRoaXMuY29uZmlndXJhdGlvbi5vblN0YXRlbGVzcyk7XG4gICAgICAgIHRoaXMub24oJ3Vuc3luY2VkQ2hhbmdlcycsIHRoaXMuY29uZmlndXJhdGlvbi5vblVuc3luY2VkQ2hhbmdlcyk7XG4gICAgICAgIHRoaXMub24oJ2F1dGhlbnRpY2F0ZWQnLCB0aGlzLmNvbmZpZ3VyYXRpb24ub25BdXRoZW50aWNhdGVkKTtcbiAgICAgICAgdGhpcy5vbignYXV0aGVudGljYXRpb25GYWlsZWQnLCB0aGlzLmNvbmZpZ3VyYXRpb24ub25BdXRoZW50aWNhdGlvbkZhaWxlZCk7XG4gICAgICAgIChfYSA9IHRoaXMuYXdhcmVuZXNzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub24oJ3VwZGF0ZScsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnYXdhcmVuZXNzVXBkYXRlJywgeyBzdGF0ZXM6IGF3YXJlbmVzc1N0YXRlc1RvQXJyYXkodGhpcy5hd2FyZW5lc3MuZ2V0U3RhdGVzKCkpIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgKF9iID0gdGhpcy5hd2FyZW5lc3MpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5vbignY2hhbmdlJywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdhd2FyZW5lc3NDaGFuZ2UnLCB7IHN0YXRlczogYXdhcmVuZXNzU3RhdGVzVG9BcnJheSh0aGlzLmF3YXJlbmVzcy5nZXRTdGF0ZXMoKSkgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmRvY3VtZW50Lm9uKCd1cGRhdGUnLCB0aGlzLmJvdW5kRG9jdW1lbnRVcGRhdGVIYW5kbGVyKTtcbiAgICAgICAgKF9jID0gdGhpcy5hd2FyZW5lc3MpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5vbigndXBkYXRlJywgdGhpcy5ib3VuZEF3YXJlbmVzc1VwZGF0ZUhhbmRsZXIpO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbi5mb3JjZVN5bmNJbnRlcnZhbFxuICAgICAgICAgICAgJiYgdHlwZW9mIHRoaXMuY29uZmlndXJhdGlvbi5mb3JjZVN5bmNJbnRlcnZhbCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJ2YWxzLmZvcmNlU3luYyA9IHNldEludGVydmFsKHRoaXMuZm9yY2VTeW5jLmJpbmQodGhpcyksIHRoaXMuY29uZmlndXJhdGlvbi5mb3JjZVN5bmNJbnRlcnZhbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubWFuYWdlU29ja2V0KSB7XG4gICAgICAgICAgICB0aGlzLmF0dGFjaCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldENvbmZpZ3VyYXRpb24oY29uZmlndXJhdGlvbiA9IHt9KSB7XG4gICAgICAgIGlmICghY29uZmlndXJhdGlvbi53ZWJzb2NrZXRQcm92aWRlcikge1xuICAgICAgICAgICAgY29uc3Qgd2Vic29ja2V0UHJvdmlkZXJDb25maWcgPSBjb25maWd1cmF0aW9uO1xuICAgICAgICAgICAgdGhpcy5tYW5hZ2VTb2NrZXQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uLndlYnNvY2tldFByb3ZpZGVyID0gbmV3IEhvY3VzcG9jdXNQcm92aWRlcldlYnNvY2tldCh7XG4gICAgICAgICAgICAgICAgdXJsOiB3ZWJzb2NrZXRQcm92aWRlckNvbmZpZy51cmwsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24gPSB7IC4uLnRoaXMuY29uZmlndXJhdGlvbiwgLi4uY29uZmlndXJhdGlvbiB9O1xuICAgIH1cbiAgICBnZXQgZG9jdW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZ3VyYXRpb24uZG9jdW1lbnQ7XG4gICAgfVxuICAgIGdldCBpc0F0dGFjaGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNBdHRhY2hlZDtcbiAgICB9XG4gICAgZ2V0IGF3YXJlbmVzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlndXJhdGlvbi5hd2FyZW5lc3M7XG4gICAgfVxuICAgIGdldCBoYXNVbnN5bmNlZENoYW5nZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVuc3luY2VkQ2hhbmdlcyA+IDA7XG4gICAgfVxuICAgIHJlc2V0VW5zeW5jZWRDaGFuZ2VzKCkge1xuICAgICAgICB0aGlzLnVuc3luY2VkQ2hhbmdlcyA9IDE7XG4gICAgICAgIHRoaXMuZW1pdCgndW5zeW5jZWRDaGFuZ2VzJywgeyBudW1iZXI6IHRoaXMudW5zeW5jZWRDaGFuZ2VzIH0pO1xuICAgIH1cbiAgICBpbmNyZW1lbnRVbnN5bmNlZENoYW5nZXMoKSB7XG4gICAgICAgIHRoaXMudW5zeW5jZWRDaGFuZ2VzICs9IDE7XG4gICAgICAgIHRoaXMuZW1pdCgndW5zeW5jZWRDaGFuZ2VzJywgeyBudW1iZXI6IHRoaXMudW5zeW5jZWRDaGFuZ2VzIH0pO1xuICAgIH1cbiAgICBkZWNyZW1lbnRVbnN5bmNlZENoYW5nZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLnVuc3luY2VkQ2hhbmdlcyA+IDApIHtcbiAgICAgICAgICAgIHRoaXMudW5zeW5jZWRDaGFuZ2VzIC09IDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudW5zeW5jZWRDaGFuZ2VzID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnN5bmNlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0KCd1bnN5bmNlZENoYW5nZXMnLCB7IG51bWJlcjogdGhpcy51bnN5bmNlZENoYW5nZXMgfSk7XG4gICAgfVxuICAgIGZvcmNlU3luYygpIHtcbiAgICAgICAgdGhpcy5yZXNldFVuc3luY2VkQ2hhbmdlcygpO1xuICAgICAgICB0aGlzLnNlbmQoU3luY1N0ZXBPbmVNZXNzYWdlLCB7IGRvY3VtZW50OiB0aGlzLmRvY3VtZW50LCBkb2N1bWVudE5hbWU6IHRoaXMuY29uZmlndXJhdGlvbi5uYW1lIH0pO1xuICAgIH1cbiAgICBwYWdlSGlkZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuYXdhcmVuZXNzKSB7XG4gICAgICAgICAgICByZW1vdmVBd2FyZW5lc3NTdGF0ZXModGhpcy5hd2FyZW5lc3MsIFt0aGlzLmRvY3VtZW50LmNsaWVudElEXSwgJ3BhZ2UgaGlkZScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlZ2lzdGVyRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fCAhKCdhZGRFdmVudExpc3RlbmVyJyBpbiB3aW5kb3cpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BhZ2VoaWRlJywgdGhpcy5ib3VuZFBhZ2VIaWRlKTtcbiAgICB9XG4gICAgc2VuZFN0YXRlbGVzcyhwYXlsb2FkKSB7XG4gICAgICAgIHRoaXMuc2VuZChTdGF0ZWxlc3NNZXNzYWdlLCB7IGRvY3VtZW50TmFtZTogdGhpcy5jb25maWd1cmF0aW9uLm5hbWUsIHBheWxvYWQgfSk7XG4gICAgfVxuICAgIGRvY3VtZW50VXBkYXRlSGFuZGxlcih1cGRhdGUsIG9yaWdpbikge1xuICAgICAgICBpZiAob3JpZ2luID09PSB0aGlzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbmNyZW1lbnRVbnN5bmNlZENoYW5nZXMoKTtcbiAgICAgICAgdGhpcy5zZW5kKFVwZGF0ZU1lc3NhZ2UsIHsgdXBkYXRlLCBkb2N1bWVudE5hbWU6IHRoaXMuY29uZmlndXJhdGlvbi5uYW1lIH0pO1xuICAgIH1cbiAgICBhd2FyZW5lc3NVcGRhdGVIYW5kbGVyKHsgYWRkZWQsIHVwZGF0ZWQsIHJlbW92ZWQgfSwgb3JpZ2luKSB7XG4gICAgICAgIGNvbnN0IGNoYW5nZWRDbGllbnRzID0gYWRkZWQuY29uY2F0KHVwZGF0ZWQpLmNvbmNhdChyZW1vdmVkKTtcbiAgICAgICAgdGhpcy5zZW5kKEF3YXJlbmVzc01lc3NhZ2UsIHtcbiAgICAgICAgICAgIGF3YXJlbmVzczogdGhpcy5hd2FyZW5lc3MsXG4gICAgICAgICAgICBjbGllbnRzOiBjaGFuZ2VkQ2xpZW50cyxcbiAgICAgICAgICAgIGRvY3VtZW50TmFtZTogdGhpcy5jb25maWd1cmF0aW9uLm5hbWUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciBhIGZpcnN0IGhhbmRzaGFrZSB3aXRoIHRoZSBzZXJ2ZXIgaGFzIGJlZW4gZXN0YWJsaXNoZWRcbiAgICAgKlxuICAgICAqIE5vdGU6IHRoaXMgZG9lcyBub3QgbWVhbiBhbGwgdXBkYXRlcyBmcm9tIHRoZSBjbGllbnQgaGF2ZSBiZWVuIHBlcnNpc3RlZCB0byB0aGUgYmFja2VuZC4gRm9yIHRoaXMsXG4gICAgICogdXNlIGBoYXNVbnN5bmNlZENoYW5nZXNgLlxuICAgICAqL1xuICAgIGdldCBzeW5jZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzU3luY2VkO1xuICAgIH1cbiAgICBzZXQgc3luY2VkKHN0YXRlKSB7XG4gICAgICAgIGlmICh0aGlzLmlzU3luY2VkID09PSBzdGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNTeW5jZWQgPSBzdGF0ZTtcbiAgICAgICAgaWYgKHN0YXRlKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3N5bmNlZCcsIHsgc3RhdGUgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVjZWl2ZVN0YXRlbGVzcyhwYXlsb2FkKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnc3RhdGVsZXNzJywgeyBwYXlsb2FkIH0pO1xuICAgIH1cbiAgICAvLyBub3QgbmVlZGVkLCBidXQgcHJvdmlkZXMgYmFja3dhcmQgY29tcGF0aWJpbGl0eSB3aXRoIGUuZy4gbGV4aWNhbC95anNcbiAgICBhc3luYyBjb25uZWN0KCkge1xuICAgICAgICBpZiAodGhpcy5tYW5hZ2VTb2NrZXQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbmZpZ3VyYXRpb24ud2Vic29ja2V0UHJvdmlkZXIuY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUud2FybignSG9jdXNwb2N1c1Byb3ZpZGVyOjpjb25uZWN0KCkgaXMgZGVwcmVjYXRlZCBhbmQgZG9lcyBub3QgZG8gYW55dGhpbmcuIFBsZWFzZSBjb25uZWN0L2Rpc2Nvbm5lY3Qgb24gdGhlIHdlYnNvY2tldFByb3ZpZGVyLCBvciBhdHRhY2gvZGVhdHRhY2ggcHJvdmlkZXJzLicpO1xuICAgIH1cbiAgICBkaXNjb25uZWN0KCkge1xuICAgICAgICBpZiAodGhpcy5tYW5hZ2VTb2NrZXQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbmZpZ3VyYXRpb24ud2Vic29ja2V0UHJvdmlkZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUud2FybignSG9jdXNwb2N1c1Byb3ZpZGVyOjpkaXNjb25uZWN0KCkgaXMgZGVwcmVjYXRlZCBhbmQgZG9lcyBub3QgZG8gYW55dGhpbmcuIFBsZWFzZSBjb25uZWN0L2Rpc2Nvbm5lY3Qgb24gdGhlIHdlYnNvY2tldFByb3ZpZGVyLCBvciBhdHRhY2gvZGVhdHRhY2ggcHJvdmlkZXJzLicpO1xuICAgIH1cbiAgICBhc3luYyBvbk9wZW4oZXZlbnQpIHtcbiAgICAgICAgdGhpcy5pc0F1dGhlbnRpY2F0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5lbWl0KCdvcGVuJywgeyBldmVudCB9KTtcbiAgICAgICAgbGV0IHRva2VuO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdG9rZW4gPSBhd2FpdCB0aGlzLmdldFRva2VuKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLnBlcm1pc3Npb25EZW5pZWRIYW5kbGVyKGBGYWlsZWQgdG8gZ2V0IHRva2VuOiAke2Vycm9yfWApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VuZChBdXRoZW50aWNhdGlvbk1lc3NhZ2UsIHtcbiAgICAgICAgICAgIHRva2VuOiB0b2tlbiAhPT0gbnVsbCAmJiB0b2tlbiAhPT0gdm9pZCAwID8gdG9rZW4gOiAnJyxcbiAgICAgICAgICAgIGRvY3VtZW50TmFtZTogdGhpcy5jb25maWd1cmF0aW9uLm5hbWUsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnN0YXJ0U3luYygpO1xuICAgIH1cbiAgICBhc3luYyBnZXRUb2tlbigpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmNvbmZpZ3VyYXRpb24udG9rZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNvbnN0IHRva2VuID0gYXdhaXQgdGhpcy5jb25maWd1cmF0aW9uLnRva2VuKCk7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlndXJhdGlvbi50b2tlbjtcbiAgICB9XG4gICAgc3RhcnRTeW5jKCkge1xuICAgICAgICB0aGlzLnJlc2V0VW5zeW5jZWRDaGFuZ2VzKCk7XG4gICAgICAgIHRoaXMuc2VuZChTeW5jU3RlcE9uZU1lc3NhZ2UsIHsgZG9jdW1lbnQ6IHRoaXMuZG9jdW1lbnQsIGRvY3VtZW50TmFtZTogdGhpcy5jb25maWd1cmF0aW9uLm5hbWUgfSk7XG4gICAgICAgIGlmICh0aGlzLmF3YXJlbmVzcyAmJiB0aGlzLmF3YXJlbmVzcy5nZXRMb2NhbFN0YXRlKCkgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuc2VuZChBd2FyZW5lc3NNZXNzYWdlLCB7XG4gICAgICAgICAgICAgICAgYXdhcmVuZXNzOiB0aGlzLmF3YXJlbmVzcyxcbiAgICAgICAgICAgICAgICBjbGllbnRzOiBbdGhpcy5kb2N1bWVudC5jbGllbnRJRF0sXG4gICAgICAgICAgICAgICAgZG9jdW1lbnROYW1lOiB0aGlzLmNvbmZpZ3VyYXRpb24ubmFtZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNlbmQobWVzc2FnZSwgYXJncykge1xuICAgICAgICBpZiAoIXRoaXMuX2lzQXR0YWNoZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VTZW5kZXIgPSBuZXcgTWVzc2FnZVNlbmRlcihtZXNzYWdlLCBhcmdzKTtcbiAgICAgICAgdGhpcy5lbWl0KCdvdXRnb2luZ01lc3NhZ2UnLCB7IG1lc3NhZ2U6IG1lc3NhZ2VTZW5kZXIubWVzc2FnZSB9KTtcbiAgICAgICAgbWVzc2FnZVNlbmRlci5zZW5kKHRoaXMuY29uZmlndXJhdGlvbi53ZWJzb2NrZXRQcm92aWRlcik7XG4gICAgfVxuICAgIG9uTWVzc2FnZShldmVudCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gbmV3IEluY29taW5nTWVzc2FnZShldmVudC5kYXRhKTtcbiAgICAgICAgY29uc3QgZG9jdW1lbnROYW1lID0gbWVzc2FnZS5yZWFkVmFyU3RyaW5nKCk7XG4gICAgICAgIG1lc3NhZ2Uud3JpdGVWYXJTdHJpbmcoZG9jdW1lbnROYW1lKTtcbiAgICAgICAgdGhpcy5lbWl0KCdtZXNzYWdlJywgeyBldmVudCwgbWVzc2FnZTogbmV3IEluY29taW5nTWVzc2FnZShldmVudC5kYXRhKSB9KTtcbiAgICAgICAgbmV3IE1lc3NhZ2VSZWNlaXZlcihtZXNzYWdlKS5hcHBseSh0aGlzLCB0cnVlKTtcbiAgICB9XG4gICAgb25DbG9zZSgpIHtcbiAgICAgICAgdGhpcy5pc0F1dGhlbnRpY2F0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zeW5jZWQgPSBmYWxzZTtcbiAgICAgICAgLy8gdXBkYXRlIGF3YXJlbmVzcyAoYWxsIHVzZXJzIGV4Y2VwdCBsb2NhbCBsZWZ0KVxuICAgICAgICBpZiAodGhpcy5hd2FyZW5lc3MpIHtcbiAgICAgICAgICAgIHJlbW92ZUF3YXJlbmVzc1N0YXRlcyh0aGlzLmF3YXJlbmVzcywgQXJyYXkuZnJvbSh0aGlzLmF3YXJlbmVzcy5nZXRTdGF0ZXMoKS5rZXlzKCkpLmZpbHRlcihjbGllbnQgPT4gY2xpZW50ICE9PSB0aGlzLmRvY3VtZW50LmNsaWVudElEKSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5lbWl0KCdkZXN0cm95Jyk7XG4gICAgICAgIGlmICh0aGlzLmludGVydmFscy5mb3JjZVN5bmMpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5pbnRlcnZhbHMuZm9yY2VTeW5jKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hd2FyZW5lc3MpIHtcbiAgICAgICAgICAgIHJlbW92ZUF3YXJlbmVzc1N0YXRlcyh0aGlzLmF3YXJlbmVzcywgW3RoaXMuZG9jdW1lbnQuY2xpZW50SURdLCAncHJvdmlkZXIgZGVzdHJveScpO1xuICAgICAgICAgICAgdGhpcy5hd2FyZW5lc3Mub2ZmKCd1cGRhdGUnLCB0aGlzLmJvdW5kQXdhcmVuZXNzVXBkYXRlSGFuZGxlcik7XG4gICAgICAgICAgICB0aGlzLmF3YXJlbmVzcy5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kb2N1bWVudC5vZmYoJ3VwZGF0ZScsIHRoaXMuYm91bmREb2N1bWVudFVwZGF0ZUhhbmRsZXIpO1xuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICB0aGlzLmRldGFjaCgpO1xuICAgICAgICBpZiAodGhpcy5tYW5hZ2VTb2NrZXQpIHtcbiAgICAgICAgICAgIHRoaXMuY29uZmlndXJhdGlvbi53ZWJzb2NrZXRQcm92aWRlci5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8ICEoJ3JlbW92ZUV2ZW50TGlzdGVuZXInIGluIHdpbmRvdykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncGFnZWhpZGUnLCB0aGlzLmJvdW5kUGFnZUhpZGUpO1xuICAgIH1cbiAgICBkZXRhY2goKSB7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvbi53ZWJzb2NrZXRQcm92aWRlci5vZmYoJ2Nvbm5lY3QnLCB0aGlzLmNvbmZpZ3VyYXRpb24ub25Db25uZWN0KTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uLndlYnNvY2tldFByb3ZpZGVyLm9mZignY29ubmVjdCcsIHRoaXMuZm9yd2FyZENvbm5lY3QpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24ud2Vic29ja2V0UHJvdmlkZXIub2ZmKCdvcGVuJywgdGhpcy5ib3VuZE9uT3Blbik7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvbi53ZWJzb2NrZXRQcm92aWRlci5vZmYoJ2Nsb3NlJywgdGhpcy5ib3VuZE9uQ2xvc2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24ud2Vic29ja2V0UHJvdmlkZXIub2ZmKCdjbG9zZScsIHRoaXMuY29uZmlndXJhdGlvbi5vbkNsb3NlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uLndlYnNvY2tldFByb3ZpZGVyLm9mZignY2xvc2UnLCB0aGlzLmZvcndhcmRDbG9zZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvbi53ZWJzb2NrZXRQcm92aWRlci5vZmYoJ2Rpc2Nvbm5lY3QnLCB0aGlzLmNvbmZpZ3VyYXRpb24ub25EaXNjb25uZWN0KTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uLndlYnNvY2tldFByb3ZpZGVyLm9mZignZGlzY29ubmVjdCcsIHRoaXMuZm9yd2FyZERpc2Nvbm5lY3QpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24ud2Vic29ja2V0UHJvdmlkZXIub2ZmKCdkZXN0cm95JywgdGhpcy5jb25maWd1cmF0aW9uLm9uRGVzdHJveSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvbi53ZWJzb2NrZXRQcm92aWRlci5vZmYoJ2Rlc3Ryb3knLCB0aGlzLmZvcndhcmREZXN0cm95KTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uLndlYnNvY2tldFByb3ZpZGVyLmRldGFjaCh0aGlzKTtcbiAgICAgICAgdGhpcy5faXNBdHRhY2hlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBhdHRhY2goKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc0F0dGFjaGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24ud2Vic29ja2V0UHJvdmlkZXIub24oJ2Nvbm5lY3QnLCB0aGlzLmNvbmZpZ3VyYXRpb24ub25Db25uZWN0KTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uLndlYnNvY2tldFByb3ZpZGVyLm9uKCdjb25uZWN0JywgdGhpcy5mb3J3YXJkQ29ubmVjdCk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvbi53ZWJzb2NrZXRQcm92aWRlci5vbignb3BlbicsIHRoaXMuYm91bmRPbk9wZW4pO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24ud2Vic29ja2V0UHJvdmlkZXIub24oJ2Nsb3NlJywgdGhpcy5ib3VuZE9uQ2xvc2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24ud2Vic29ja2V0UHJvdmlkZXIub24oJ2Nsb3NlJywgdGhpcy5jb25maWd1cmF0aW9uLm9uQ2xvc2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24ud2Vic29ja2V0UHJvdmlkZXIub24oJ2Nsb3NlJywgdGhpcy5mb3J3YXJkQ2xvc2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24ud2Vic29ja2V0UHJvdmlkZXIub24oJ2Rpc2Nvbm5lY3QnLCB0aGlzLmNvbmZpZ3VyYXRpb24ub25EaXNjb25uZWN0KTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uLndlYnNvY2tldFByb3ZpZGVyLm9uKCdkaXNjb25uZWN0JywgdGhpcy5mb3J3YXJkRGlzY29ubmVjdCk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvbi53ZWJzb2NrZXRQcm92aWRlci5vbignZGVzdHJveScsIHRoaXMuY29uZmlndXJhdGlvbi5vbkRlc3Ryb3kpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24ud2Vic29ja2V0UHJvdmlkZXIub24oJ2Rlc3Ryb3knLCB0aGlzLmZvcndhcmREZXN0cm95KTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uLndlYnNvY2tldFByb3ZpZGVyLmF0dGFjaCh0aGlzKTtcbiAgICAgICAgdGhpcy5faXNBdHRhY2hlZCA9IHRydWU7XG4gICAgfVxuICAgIHBlcm1pc3Npb25EZW5pZWRIYW5kbGVyKHJlYXNvbikge1xuICAgICAgICB0aGlzLmVtaXQoJ2F1dGhlbnRpY2F0aW9uRmFpbGVkJywgeyByZWFzb24gfSk7XG4gICAgICAgIHRoaXMuaXNBdXRoZW50aWNhdGVkID0gZmFsc2U7XG4gICAgfVxuICAgIGF1dGhlbnRpY2F0ZWRIYW5kbGVyKHNjb3BlKSB7XG4gICAgICAgIHRoaXMuaXNBdXRoZW50aWNhdGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hdXRob3JpemVkU2NvcGUgPSBzY29wZTtcbiAgICAgICAgdGhpcy5lbWl0KCdhdXRoZW50aWNhdGVkJywgeyBzY29wZSB9KTtcbiAgICB9XG4gICAgc2V0QXdhcmVuZXNzRmllbGQoa2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMuYXdhcmVuZXNzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXdhcmVuZXNzRXJyb3IoYENhbm5vdCBzZXQgYXdhcmVuZXNzIGZpZWxkIFwiJHtrZXl9XCIgdG8gJHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9LiBZb3UgaGF2ZSBkaXNhYmxlZCBBd2FyZW5lc3MgZm9yIHRoaXMgcHJvdmlkZXIgYnkgZXhwbGljaXRseSBwYXNzaW5nIGF3YXJlbmVzczogbnVsbCBpbiB0aGUgcHJvdmlkZXIgY29uZmlndXJhdGlvbi5gKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmF3YXJlbmVzcy5zZXRMb2NhbFN0YXRlRmllbGQoa2V5LCB2YWx1ZSk7XG4gICAgfVxufVxuXG5leHBvcnQgeyBBd2FyZW5lc3NFcnJvciwgSG9jdXNwb2N1c1Byb3ZpZGVyLCBIb2N1c3BvY3VzUHJvdmlkZXJXZWJzb2NrZXQsIE1lc3NhZ2VUeXBlLCBXZWJTb2NrZXRTdGF0dXMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhvY3VzcG9jdXMtcHJvdmlkZXIuZXNtLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@hocuspocus/provider/dist/hocuspocus-provider.esm.js\n");

/***/ })

};
;