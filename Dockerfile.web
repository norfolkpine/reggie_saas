# syntax = docker/dockerfile:1.5
# Multi-stage Docker buildfile
# See https://docs.docker.com/build/building/multi-stage/

# Stage 1: Build the python dependencies
# This stage creates Python wheels for faster installation in the final image.
FROM python:3.12-slim-bookworm as build-python-wheels

WORKDIR /app

# Install build dependencies for psycopg2 and other packages if needed at wheel build time
RUN apt-get update && apt-get install -y --no-install-recommends \
    build-essential \
    libpq-dev \
    && rm -rf /var/lib/apt/lists/*

COPY ./requirements /requirements
# Using --no-cache-dir for pip wheel as we are caching at a higher level with Docker layer cache or --mount=type=cache
# Create wheels for all requirements
RUN pip wheel --no-cache-dir --no-deps --wheel-dir /wheels -r /requirements/requirements.txt

# Stage 2: Build the front end files
FROM node:22-bookworm-slim AS build-node
# RUN nodejs -v && npm -v # Optional: for debugging image build
WORKDIR /code

# Copy files required for npm install first to leverage caching
COPY package.json package-lock.json .babelrc webpack.config.js tsconfig.json /code/
COPY assets /code/assets/
COPY api-client /code/api-client/

# Prefer npm ci for reproducible builds if package-lock.json is present and reliable
# RUN npm ci
RUN npm install

# Copy the rest of the source code needed for the build
# This includes Django templates for Tailwind CSS class detection, etc.
COPY . /code/
RUN npm run build

# Stage 3: Build the final image
# Replace 'your-gcr-project/reggie-web-base:latest' with the actual published base image path
FROM your-gcr-project/reggie-web-base:latest AS final

ENV PYTHONUNBUFFERED=1
ENV DEBUG=0
# PATH is already set in the base image

WORKDIR /code

# Copy Python requirements and install them using the pre-built wheels
COPY --from=build-python-wheels /wheels /wheels
COPY ./requirements /requirements
# Use --no-cache-dir with pip install as layer caching is preferred
RUN pip install --no-cache-dir --find-links=/wheels -r /requirements/requirements.txt

# Copy application code
# Ensure this comes after installing dependencies to optimize caching
COPY --chown=django:django . /code

# Copy built static assets from the build-node stage
COPY --from=build-node /code/static /code/static

# Collect static files
# This needs to run as root if staticfiles directory is owned by root initially,
# or ensure /code/staticfiles is writable by django user.
# For simplicity, running as root then chown.
RUN DEBUG=False python /code/manage.py collectstatic --noinput --settings=bh_reggie.settings
RUN chown django:django -R /code/staticfiles

# Create SSL directory (if needed by the entrypoint script) and set ownership
RUN mkdir -p /code/ssl && chown django:django /code/ssl

# Switch to non-root user 'django' (created in base image)
USER django

COPY --chown=django:django docker_startup.sh /start
RUN chmod +x /start
CMD ["/start"]
